/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxAttach ( CUcontext * pctx, unsigned int flags )
{
  hfinf( "[trapper] cuCtxAttach() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      unsigned int flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxAttach );
  t2d_msg->data.flags = flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    CUcontext pctx;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pctx ) *pctx = d2t_msg.pctx;
  hfinf( "[trapper] cuCtxAttach() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxCreate_v2 ( CUcontext * pctx, unsigned int flags, CUdevice dev )
{
  hfinf( "[trapper] cuCtxCreate_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      unsigned int flags;
      CUdevice dev;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxCreate_v2 );
  t2d_msg->data.flags = flags;
  t2d_msg->data.dev = dev;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    CUcontext pctx;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pctx ) *pctx = d2t_msg.pctx;
  hfinf( "[trapper] cuCtxCreate_v2() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxDestroy_v2 ( CUcontext ctx )
{
  hfinf( "[trapper] cuCtxDestroy_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUcontext ctx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxDestroy_v2 );
  t2d_msg->data.ctx = ctx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuCtxDestroy_v2() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxDetach ( CUcontext ctx )
{
  hfinf( "[trapper] cuCtxDetach() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUcontext ctx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxDetach );
  t2d_msg->data.ctx = ctx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuCtxDetach() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxGetApiVersion ( CUcontext ctx, unsigned int * version )
{
  hfinf( "[trapper] cuCtxGetApiVersion() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUcontext ctx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxGetApiVersion );
  t2d_msg->data.ctx = ctx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    unsigned int version;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( version ) *version = d2t_msg.version;
  hfinf( "[trapper] cuCtxGetApiVersion() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxGetCacheConfig ( CUfunc_cache * pconfig )
{
  hfinf( "[trapper] cuCtxGetCacheConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxGetCacheConfig );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    CUfunc_cache pconfig;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pconfig ) *pconfig = d2t_msg.pconfig;
  hfinf( "[trapper] cuCtxGetCacheConfig() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxGetCurrent ( CUcontext * pctx )
{
  hfinf( "[trapper] cuCtxGetCurrent() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxGetCurrent );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    CUcontext pctx;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pctx ) *pctx = d2t_msg.pctx;
  hfinf( "[trapper] cuCtxGetCurrent() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxGetDevice ( CUdevice * device )
{
  hfinf( "[trapper] cuCtxGetDevice() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxGetDevice );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    CUdevice device;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( device ) *device = d2t_msg.device;
  hfinf( "[trapper] cuCtxGetDevice() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxGetFlags ( unsigned int * flags )
{
  hfinf( "[trapper] cuCtxGetFlags() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxGetFlags );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    unsigned int flags;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( flags ) *flags = d2t_msg.flags;
  hfinf( "[trapper] cuCtxGetFlags() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxGetLimit ( size_t * pvalue, CUlimit limit )
{
  hfinf( "[trapper] cuCtxGetLimit() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUlimit limit;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxGetLimit );
  t2d_msg->data.limit = limit;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    size_t pvalue;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pvalue ) *pvalue = d2t_msg.pvalue;
  hfinf( "[trapper] cuCtxGetLimit() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxGetSharedMemConfig ( CUsharedconfig * pConfig )
{
  hfinf( "[trapper] cuCtxGetSharedMemConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxGetSharedMemConfig );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    CUsharedconfig pConfig;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pConfig ) *pConfig = d2t_msg.pConfig;
  hfinf( "[trapper] cuCtxGetSharedMemConfig() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxGetStreamPriorityRange ( int * leastPriority, int * greatestPriority )
{
  hfinf( "[trapper] cuCtxGetStreamPriorityRange() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxGetStreamPriorityRange );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    int leastPriority;
    int greatestPriority;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( leastPriority ) *leastPriority = d2t_msg.leastPriority;
  if( greatestPriority ) *greatestPriority = d2t_msg.greatestPriority;
  hfinf( "[trapper] cuCtxGetStreamPriorityRange() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxSetCacheConfig ( CUfunc_cache config )
{
  hfinf( "[trapper] cuCtxSetCacheConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunc_cache config;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxSetCacheConfig );
  t2d_msg->data.config = config;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuCtxSetCacheConfig() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxSetCurrent ( CUcontext ctx )
{
  hfinf( "[trapper] cuCtxSetCurrent() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUcontext ctx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxSetCurrent );
  t2d_msg->data.ctx = ctx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuCtxSetCurrent() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxSetLimit ( CUlimit limit, size_t value )
{
  hfinf( "[trapper] cuCtxSetLimit() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUlimit limit;
      size_t value;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxSetLimit );
  t2d_msg->data.limit = limit;
  t2d_msg->data.value = value;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuCtxSetLimit() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxSetSharedMemConfig ( CUsharedconfig config )
{
  hfinf( "[trapper] cuCtxSetSharedMemConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUsharedconfig config;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxSetSharedMemConfig );
  t2d_msg->data.config = config;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuCtxSetSharedMemConfig() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuCtxSynchronize ( void )
{
  hfinf( "[trapper] cuCtxSynchronize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuCtxSynchronize );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuCtxSynchronize() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuDeviceComputeCapability ( int * major, int * minor, CUdevice dev )
{
  hfinf( "[trapper] cuDeviceComputeCapability() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUdevice dev;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuDeviceComputeCapability );
  t2d_msg->data.dev = dev;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    int major;
    int minor;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( major ) *major = d2t_msg.major;
  if( minor ) *minor = d2t_msg.minor;
  hfinf( "[trapper] cuDeviceComputeCapability() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuDeviceGetProperties ( CUdevprop * prop, CUdevice dev )
{
  hfinf( "[trapper] cuDeviceGetProperties() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUdevice dev;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuDeviceGetProperties );
  t2d_msg->data.dev = dev;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    CUdevprop prop;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( prop ) *prop = d2t_msg.prop;
  hfinf( "[trapper] cuDeviceGetProperties() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuDevicePrimaryCtxGetState ( CUdevice dev, unsigned int * flags, int * active )
{
  hfinf( "[trapper] cuDevicePrimaryCtxGetState() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUdevice dev;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuDevicePrimaryCtxGetState );
  t2d_msg->data.dev = dev;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    unsigned int flags;
    int active;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( flags ) *flags = d2t_msg.flags;
  if( active ) *active = d2t_msg.active;
  hfinf( "[trapper] cuDevicePrimaryCtxGetState() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuDevicePrimaryCtxRelease ( CUdevice dev )
{
  hfinf( "[trapper] cuDevicePrimaryCtxRelease() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUdevice dev;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuDevicePrimaryCtxRelease );
  t2d_msg->data.dev = dev;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuDevicePrimaryCtxRelease() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuDevicePrimaryCtxReset ( CUdevice dev )
{
  hfinf( "[trapper] cuDevicePrimaryCtxReset() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUdevice dev;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuDevicePrimaryCtxReset );
  t2d_msg->data.dev = dev;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuDevicePrimaryCtxReset() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuDevicePrimaryCtxRetain ( CUcontext * pctx, CUdevice dev )
{
  hfinf( "[trapper] cuDevicePrimaryCtxRetain() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUdevice dev;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuDevicePrimaryCtxRetain );
  t2d_msg->data.dev = dev;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    CUcontext pctx;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pctx ) *pctx = d2t_msg.pctx;
  hfinf( "[trapper] cuDevicePrimaryCtxRetain() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuDevicePrimaryCtxSetFlags ( CUdevice dev, unsigned int flags )
{
  hfinf( "[trapper] cuDevicePrimaryCtxSetFlags() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUdevice dev;
      unsigned int flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuDevicePrimaryCtxSetFlags );
  t2d_msg->data.dev = dev;
  t2d_msg->data.flags = flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuDevicePrimaryCtxSetFlags() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuDriverGetVersion ( int * driverVersion )
{
  hfinf( "[trapper] cuDriverGetVersion() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuDriverGetVersion );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    int driverVersion;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( driverVersion ) *driverVersion = d2t_msg.driverVersion;
  hfinf( "[trapper] cuDriverGetVersion() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuEventCreate ( CUevent * phEvent, unsigned int Flags )
{
  hfinf( "[trapper] cuEventCreate() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      unsigned int Flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuEventCreate );
  t2d_msg->data.Flags = Flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    CUevent phEvent;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( phEvent ) *phEvent = d2t_msg.phEvent;
  hfinf( "[trapper] cuEventCreate() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuEventDestroy_v2 ( CUevent hEvent )
{
  hfinf( "[trapper] cuEventDestroy_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUevent hEvent;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuEventDestroy_v2 );
  t2d_msg->data.hEvent = hEvent;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuEventDestroy_v2() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuEventElapsedTime ( float * pMilliseconds, CUevent hStart, CUevent hEnd )
{
  hfinf( "[trapper] cuEventElapsedTime() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUevent hStart;
      CUevent hEnd;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuEventElapsedTime );
  t2d_msg->data.hStart = hStart;
  t2d_msg->data.hEnd = hEnd;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    float pMilliseconds;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pMilliseconds ) *pMilliseconds = d2t_msg.pMilliseconds;
  hfinf( "[trapper] cuEventElapsedTime() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuEventQuery ( CUevent hEvent )
{
  hfinf( "[trapper] cuEventQuery() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUevent hEvent;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuEventQuery );
  t2d_msg->data.hEvent = hEvent;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuEventQuery() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuEventRecord ( CUevent hEvent, CUstream hStream )
{
  hfinf( "[trapper] cuEventRecord() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUevent hEvent;
      CUstream hStream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuEventRecord );
  t2d_msg->data.hEvent = hEvent;
  t2d_msg->data.hStream = hStream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuEventRecord() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuEventSynchronize ( CUevent hEvent )
{
  hfinf( "[trapper] cuEventSynchronize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUevent hEvent;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuEventSynchronize );
  t2d_msg->data.hEvent = hEvent;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuEventSynchronize() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuFuncGetAttribute ( int * pi, CUfunction_attribute attrib, CUfunction hfunc )
{
  hfinf( "[trapper] cuFuncGetAttribute() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction_attribute attrib;
      CUfunction hfunc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuFuncGetAttribute );
  t2d_msg->data.attrib = attrib;
  t2d_msg->data.hfunc = hfunc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    int pi;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pi ) *pi = d2t_msg.pi;
  hfinf( "[trapper] cuFuncGetAttribute() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuFuncSetAttribute ( CUfunction hfunc, CUfunction_attribute attrib, int value )
{
  hfinf( "[trapper] cuFuncSetAttribute() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction hfunc;
      CUfunction_attribute attrib;
      int value;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuFuncSetAttribute );
  t2d_msg->data.hfunc = hfunc;
  t2d_msg->data.attrib = attrib;
  t2d_msg->data.value = value;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuFuncSetAttribute() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuFuncSetBlockShape ( CUfunction hfunc, int x, int y, int z )
{
  hfinf( "[trapper] cuFuncSetBlockShape() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction hfunc;
      int x;
      int y;
      int z;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuFuncSetBlockShape );
  t2d_msg->data.hfunc = hfunc;
  t2d_msg->data.x = x;
  t2d_msg->data.y = y;
  t2d_msg->data.z = z;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuFuncSetBlockShape() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuFuncSetCacheConfig ( CUfunction hfunc, CUfunc_cache config )
{
  hfinf( "[trapper] cuFuncSetCacheConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction hfunc;
      CUfunc_cache config;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuFuncSetCacheConfig );
  t2d_msg->data.hfunc = hfunc;
  t2d_msg->data.config = config;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuFuncSetCacheConfig() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuFuncSetSharedMemConfig ( CUfunction hfunc, CUsharedconfig config )
{
  hfinf( "[trapper] cuFuncSetSharedMemConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction hfunc;
      CUsharedconfig config;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuFuncSetSharedMemConfig );
  t2d_msg->data.hfunc = hfunc;
  t2d_msg->data.config = config;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuFuncSetSharedMemConfig() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuFuncSetSharedSize ( CUfunction hfunc, unsigned int bytes )
{
  hfinf( "[trapper] cuFuncSetSharedSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction hfunc;
      unsigned int bytes;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuFuncSetSharedSize );
  t2d_msg->data.hfunc = hfunc;
  t2d_msg->data.bytes = bytes;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuFuncSetSharedSize() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuLaunch ( CUfunction f )
{
  hfinf( "[trapper] cuLaunch() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction f;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuLaunch );
  t2d_msg->data.f = f;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuLaunch() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuLaunchGrid ( CUfunction f, int grid_width, int grid_height )
{
  hfinf( "[trapper] cuLaunchGrid() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction f;
      int grid_width;
      int grid_height;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuLaunchGrid );
  t2d_msg->data.f = f;
  t2d_msg->data.grid_width = grid_width;
  t2d_msg->data.grid_height = grid_height;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuLaunchGrid() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuLaunchGridAsync ( CUfunction f, int grid_width, int grid_height, CUstream hStream )
{
  hfinf( "[trapper] cuLaunchGridAsync() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction f;
      int grid_width;
      int grid_height;
      CUstream hStream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuLaunchGridAsync );
  t2d_msg->data.f = f;
  t2d_msg->data.grid_width = grid_width;
  t2d_msg->data.grid_height = grid_height;
  t2d_msg->data.hStream = hStream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuLaunchGridAsync() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuParamSetSize ( CUfunction hfunc, unsigned int numbytes )
{
  hfinf( "[trapper] cuParamSetSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction hfunc;
      unsigned int numbytes;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuParamSetSize );
  t2d_msg->data.hfunc = hfunc;
  t2d_msg->data.numbytes = numbytes;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuParamSetSize() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuParamSetTexRef ( CUfunction hfunc, int texunit, CUtexref hTexRef )
{
  hfinf( "[trapper] cuParamSetTexRef() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction hfunc;
      int texunit;
      CUtexref hTexRef;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuParamSetTexRef );
  t2d_msg->data.hfunc = hfunc;
  t2d_msg->data.texunit = texunit;
  t2d_msg->data.hTexRef = hTexRef;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuParamSetTexRef() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuParamSetf ( CUfunction hfunc, int offset, float value )
{
  hfinf( "[trapper] cuParamSetf() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction hfunc;
      int offset;
      float value;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuParamSetf );
  t2d_msg->data.hfunc = hfunc;
  t2d_msg->data.offset = offset;
  t2d_msg->data.value = value;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuParamSetf() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuParamSeti ( CUfunction hfunc, int offset, unsigned int value )
{
  hfinf( "[trapper] cuParamSeti() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUfunction hfunc;
      int offset;
      unsigned int value;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuParamSeti );
  t2d_msg->data.hfunc = hfunc;
  t2d_msg->data.offset = offset;
  t2d_msg->data.value = value;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuParamSeti() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamAttachMemAsync ( CUstream hStream, CUdeviceptr dptr, size_t length, unsigned int flags )
{
  hfinf( "[trapper] cuStreamAttachMemAsync() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUstream hStream;
      CUdeviceptr dptr;
      size_t length;
      unsigned int flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamAttachMemAsync );
  t2d_msg->data.hStream = hStream;
  t2d_msg->data.dptr = dptr;
  t2d_msg->data.length = length;
  t2d_msg->data.flags = flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuStreamAttachMemAsync() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamCreate ( CUstream * phStream, unsigned int Flags )
{
  hfinf( "[trapper] cuStreamCreate() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      unsigned int Flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamCreate );
  t2d_msg->data.Flags = Flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    CUstream phStream;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( phStream ) *phStream = d2t_msg.phStream;
  hfinf( "[trapper] cuStreamCreate() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamCreateWithPriority ( CUstream * phStream, unsigned int flags, int priority )
{
  hfinf( "[trapper] cuStreamCreateWithPriority() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      unsigned int flags;
      int priority;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamCreateWithPriority );
  t2d_msg->data.flags = flags;
  t2d_msg->data.priority = priority;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    CUstream phStream;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( phStream ) *phStream = d2t_msg.phStream;
  hfinf( "[trapper] cuStreamCreateWithPriority() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamDestroy_v2 ( CUstream hStream )
{
  hfinf( "[trapper] cuStreamDestroy_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUstream hStream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamDestroy_v2 );
  t2d_msg->data.hStream = hStream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuStreamDestroy_v2() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamGetFlags ( CUstream hStream, unsigned int * flags )
{
  hfinf( "[trapper] cuStreamGetFlags() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUstream hStream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamGetFlags );
  t2d_msg->data.hStream = hStream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    unsigned int flags;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( flags ) *flags = d2t_msg.flags;
  hfinf( "[trapper] cuStreamGetFlags() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamGetPriority ( CUstream hStream, int * priority )
{
  hfinf( "[trapper] cuStreamGetPriority() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUstream hStream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamGetPriority );
  t2d_msg->data.hStream = hStream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
    int priority;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( priority ) *priority = d2t_msg.priority;
  hfinf( "[trapper] cuStreamGetPriority() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamQuery ( CUstream hStream )
{
  hfinf( "[trapper] cuStreamQuery() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUstream hStream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamQuery );
  t2d_msg->data.hStream = hStream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuStreamQuery() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamSynchronize ( CUstream hStream )
{
  hfinf( "[trapper] cuStreamSynchronize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUstream hStream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamSynchronize );
  t2d_msg->data.hStream = hStream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuStreamSynchronize() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamWaitEvent ( CUstream hStream, CUevent hEvent, unsigned int Flags )
{
  hfinf( "[trapper] cuStreamWaitEvent() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUstream hStream;
      CUevent hEvent;
      unsigned int Flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamWaitEvent );
  t2d_msg->data.hStream = hStream;
  t2d_msg->data.hEvent = hEvent;
  t2d_msg->data.Flags = Flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuStreamWaitEvent() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamWaitValue32 ( CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags )
{
  hfinf( "[trapper] cuStreamWaitValue32() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUstream stream;
      CUdeviceptr addr;
      cuuint32_t value;
      unsigned int flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamWaitValue32 );
  t2d_msg->data.stream = stream;
  t2d_msg->data.addr = addr;
  t2d_msg->data.value = value;
  t2d_msg->data.flags = flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuStreamWaitValue32() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamWaitValue64 ( CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned int flags )
{
  hfinf( "[trapper] cuStreamWaitValue64() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUstream stream;
      CUdeviceptr addr;
      cuuint64_t value;
      unsigned int flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamWaitValue64 );
  t2d_msg->data.stream = stream;
  t2d_msg->data.addr = addr;
  t2d_msg->data.value = value;
  t2d_msg->data.flags = flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuStreamWaitValue64() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamWriteValue32 ( CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags )
{
  hfinf( "[trapper] cuStreamWriteValue32() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUstream stream;
      CUdeviceptr addr;
      cuuint32_t value;
      unsigned int flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamWriteValue32 );
  t2d_msg->data.stream = stream;
  t2d_msg->data.addr = addr;
  t2d_msg->data.value = value;
  t2d_msg->data.flags = flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuStreamWriteValue32() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
CUresult
cuStreamWriteValue64 ( CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned int flags )
{
  hfinf( "[trapper] cuStreamWriteValue64() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      CUstream stream;
      CUdeviceptr addr;
      cuuint64_t value;
      unsigned int flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cuStreamWriteValue64 );
  t2d_msg->data.stream = stream;
  t2d_msg->data.addr = addr;
  t2d_msg->data.value = value;
  t2d_msg->data.flags = flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    CUresult ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cuStreamWriteValue64() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasAxpyEx ( cublasHandle_t handle, int n, const void * alpha, cudaDataType alphaType, const void * x, cudaDataType xType, int incx, void * y, cudaDataType yType, int incy, cudaDataType executiontype )
{
  hfinf( "[trapper] cublasAxpyEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } alpha;
      cudaDataType alphaType;
      const void * x;
      cudaDataType xType;
      int incx;
      void * y;
      cudaDataType yType;
      int incy;
      cudaDataType executiontype;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasAxpyEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (void *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      switch( alphaType ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.alpha.val[0] = *(uint8_t*)alpha;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.alpha.val[0] = *(uint16_t*)alpha;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.alpha.val[0] = *(uint32_t*)alpha;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          *(((uint64_t*)&t2d_msg->data.alpha.val[0]) + 1) = *(((uint64_t*)alpha) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, alphaType);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.alphaType = alphaType;
  t2d_msg->data.x = x;
  t2d_msg->data.xType = xType;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.yType = yType;
  t2d_msg->data.incy = incy;
  t2d_msg->data.executiontype = executiontype;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasAxpyEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCaxpy_v2 ( cublasHandle_t handle, int n, const cuComplex * alpha, const cuComplex * x, int incx, cuComplex * y, int incy )
{
  hfinf( "[trapper] cublasCaxpy_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * x;
      int incx;
      cuComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCaxpy_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCaxpy_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCcopy_v2 ( cublasHandle_t handle, int n, const cuComplex * x, int incx, cuComplex * y, int incy )
{
  hfinf( "[trapper] cublasCcopy_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const cuComplex * x;
      int incx;
      cuComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCcopy_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCcopy_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCdgmm ( cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const cuComplex * A, int lda, const cuComplex * x, int incx, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasCdgmm() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasSideMode_t mode;
      int m;
      int n;
      const cuComplex * A;
      int lda;
      const cuComplex * x;
      int incx;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCdgmm );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mode = mode;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCdgmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCdotc_v2 ( cublasHandle_t handle, int n, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * result )
{
  hfinf( "[trapper] cublasCdotc_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuComplex * x;
      int incx;
      const cuComplex * y;
      int incy;
      cuComplex * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCdotc_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    cuComplex result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasCdotc_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCdotu_v2 ( cublasHandle_t handle, int n, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * result )
{
  hfinf( "[trapper] cublasCdotu_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuComplex * x;
      int incx;
      const cuComplex * y;
      int incy;
      cuComplex * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCdotu_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    cuComplex result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasCdotu_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgbmv_v2 ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy )
{
  hfinf( "[trapper] cublasCgbmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      int kl;
      int ku;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgbmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.kl = kl;
  t2d_msg->data.ku = ku;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgeam ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * beta, const cuComplex * B, int ldb, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasCgeam() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      const cuComplex * B;
      int ldb;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgeam );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgeam() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgelsBatched ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, cuComplex * Aarray [], int lda, cuComplex * Carray [], int ldc, int * info, int * devInfoArray, int batchSize )
{
  hfinf( "[trapper] cublasCgelsBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      int nrhs;
      cuComplex ** Aarray ;
      int lda;
      cuComplex ** Carray ;
      int ldc;
      int * devInfoArray;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgelsBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nrhs = nrhs;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Carray = Carray;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.devInfoArray = devInfoArray;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasCgelsBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgemm3mStridedBatched ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, long long strideA, const cuComplex * B, int ldb, long long strideB, const cuComplex * beta, cuComplex * C, int ldc, long long strideC, int batchCount )
{
  hfinf( "[trapper] cublasCgemm3mStridedBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      long long strideA;
      const cuComplex * B;
      int ldb;
      long long strideB;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
      long long strideC;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgemm3mStridedBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.strideA = strideA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.strideB = strideB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.strideC = strideC;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgemm3mStridedBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgemmBatched ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * Aarray [], int lda, const cuComplex * Barray [], int ldb, const cuComplex * beta, cuComplex * Carray [], int ldc, int batchCount )
{
  hfinf( "[trapper] cublasCgemmBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex ** Aarray ;
      int lda;
      const cuComplex ** Barray ;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex ** Carray ;
      int ldc;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgemmBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Barray = Barray;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.Carray = Carray;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgemmBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgemmEx ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const void * A, cudaDataType Atype, int lda, const void * B, cudaDataType Btype, int ldb, const cuComplex * beta, void * C, cudaDataType Ctype, int ldc )
{
  hfinf( "[trapper] cublasCgemmEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const void * A;
      cudaDataType Atype;
      int lda;
      const void * B;
      cudaDataType Btype;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      void * C;
      cudaDataType Ctype;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgemmEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.Atype = Atype;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.Btype = Btype;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.Ctype = Ctype;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgemmEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgemmStridedBatched ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, long long strideA, const cuComplex * B, int ldb, long long strideB, const cuComplex * beta, cuComplex * C, int ldc, long long strideC, int batchCount )
{
  hfinf( "[trapper] cublasCgemmStridedBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      long long strideA;
      const cuComplex * B;
      int ldb;
      long long strideB;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
      long long strideC;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgemmStridedBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.strideA = strideA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.strideB = strideB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.strideC = strideC;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgemmStridedBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgemm_v2 ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasCgemm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgemm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgemm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgemv_v2 ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy )
{
  hfinf( "[trapper] cublasCgemv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgemv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgemv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgeqrfBatched ( cublasHandle_t handle, int m, int n, cuComplex * Aarray [], int lda, cuComplex * TauArray [], int * info, int batchSize )
{
  hfinf( "[trapper] cublasCgeqrfBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int m;
      int n;
      cuComplex ** Aarray ;
      int lda;
      cuComplex ** TauArray ;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgeqrfBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.TauArray = TauArray;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasCgeqrfBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgerc_v2 ( cublasHandle_t handle, int m, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda )
{
  hfinf( "[trapper] cublasCgerc_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * x;
      int incx;
      const cuComplex * y;
      int incy;
      cuComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgerc_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgerc_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgeru_v2 ( cublasHandle_t handle, int m, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda )
{
  hfinf( "[trapper] cublasCgeru_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * x;
      int incx;
      const cuComplex * y;
      int incy;
      cuComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgeru_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgeru_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgetrfBatched ( cublasHandle_t handle, int n, cuComplex * A [], int lda, int * P, int * info, int batchSize )
{
  hfinf( "[trapper] cublasCgetrfBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      cuComplex ** A ;
      int lda;
      int * P;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgetrfBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.P = P;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgetrfBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgetriBatched ( cublasHandle_t handle, int n, const cuComplex * A [], int lda, const int * P, cuComplex * C [], int ldc, int * info, int batchSize )
{
  hfinf( "[trapper] cublasCgetriBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const cuComplex ** A ;
      int lda;
      const int * P;
      cuComplex ** C ;
      int ldc;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgetriBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.P = P;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCgetriBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCgetrsBatched ( cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const cuComplex * Aarray [], int lda, const int * devIpiv, cuComplex * Barray [], int ldb, int * info, int batchSize )
{
  hfinf( "[trapper] cublasCgetrsBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasOperation_t trans;
      int n;
      int nrhs;
      const cuComplex ** Aarray ;
      int lda;
      const int * devIpiv;
      cuComplex ** Barray ;
      int ldb;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCgetrsBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.nrhs = nrhs;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.devIpiv = devIpiv;
  t2d_msg->data.Barray = Barray;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasCgetrsBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasChbmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy )
{
  hfinf( "[trapper] cublasChbmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasChbmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasChbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasChemm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasChemm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasChemm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasChemm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasChemv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy )
{
  hfinf( "[trapper] cublasChemv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasChemv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasChemv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCher2_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda )
{
  hfinf( "[trapper] cublasCher2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * x;
      int incx;
      const cuComplex * y;
      int incy;
      cuComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCher2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCher2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCher2k_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const float * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasCher2k_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCher2k_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCher2k_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCher_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const cuComplex * x, int incx, cuComplex * A, int lda )
{
  hfinf( "[trapper] cublasCher_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const cuComplex * x;
      int incx;
      cuComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCher_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCher_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCherk3mEx ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const void * A, cudaDataType Atype, int lda, const float * beta, void * C, cudaDataType Ctype, int ldc )
{
  hfinf( "[trapper] cublasCherk3mEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const void * A;
      cudaDataType Atype;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      void * C;
      cudaDataType Ctype;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCherk3mEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.Atype = Atype;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.Ctype = Ctype;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCherk3mEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCherkEx ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const void * A, cudaDataType Atype, int lda, const float * beta, void * C, cudaDataType Ctype, int ldc )
{
  hfinf( "[trapper] cublasCherkEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const void * A;
      cudaDataType Atype;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      void * C;
      cudaDataType Ctype;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCherkEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.Atype = Atype;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.Ctype = Ctype;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCherkEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCherk_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const cuComplex * A, int lda, const float * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasCherk_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCherk_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCherk_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCherkx ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const float * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasCherkx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCherkx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCherkx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasChpmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * AP, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy )
{
  hfinf( "[trapper] cublasChpmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * AP;
      const cuComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasChpmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasChpmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasChpr2_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * AP )
{
  hfinf( "[trapper] cublasChpr2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * x;
      int incx;
      const cuComplex * y;
      int incy;
      cuComplex * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasChpr2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasChpr2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasChpr_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const cuComplex * x, int incx, cuComplex * AP )
{
  hfinf( "[trapper] cublasChpr_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const cuComplex * x;
      int incx;
      cuComplex * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasChpr_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasChpr_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCmatinvBatched ( cublasHandle_t handle, int n, const cuComplex * A [], int lda, cuComplex * Ainv [], int lda_inv, int * info, int batchSize )
{
  hfinf( "[trapper] cublasCmatinvBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const cuComplex ** A ;
      int lda;
      cuComplex ** Ainv ;
      int lda_inv;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCmatinvBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Ainv = Ainv;
  t2d_msg->data.lda_inv = lda_inv;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCmatinvBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCreate_v2 ( cublasHandle_t * handle )
{
  hfinf( "[trapper] cublasCreate_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCreate_v2 );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    cublasHandle_t handle;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( handle ) *handle = d2t_msg.handle;
  hfinf( "[trapper] cublasCreate_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCrot_v2 ( cublasHandle_t handle, int n, cuComplex * x, int incx, cuComplex * y, int incy, const float * c, const cuComplex * s )
{
  hfinf( "[trapper] cublasCrot_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      cuComplex * x;
      int incx;
      cuComplex * y;
      int incy;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } c;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } s;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCrot_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  if( c ) {
    hfcuda_am_node_t* _____c_MEMCHECK = hfcuda_am_mem_check( (float *) c, devId );
    bool _____c_PASSONHOST = ! (_____c_MEMCHECK && _____c_MEMCHECK->isdevice );
    if( _____c_PASSONHOST ) {
      t2d_msg->data.c.val = *c;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.c.ptr = c;
    }
  }
  else {
    t2d_msg->data.c.ptr = NULL;
  }
  if( s ) {
    hfcuda_am_node_t* _____s_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) s, devId );
    bool _____s_PASSONHOST = ! (_____s_MEMCHECK && _____s_MEMCHECK->isdevice );
    if( _____s_PASSONHOST ) {
      t2d_msg->data.s.val = *s;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.s.ptr = s;
    }
  }
  else {
    t2d_msg->data.s.ptr = NULL;
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCrot_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCrotg_v2 ( cublasHandle_t handle, cuComplex * a, cuComplex * b, float * c, cuComplex * s )
{
  hfinf( "[trapper] cublasCrotg_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(cuComplex *) : 0];
          cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(cuComplex *) > sizeof(cuComplex) ? sizeof(cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } a;
      union {
        struct {
          char ___dummy0[sizeof(cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(cuComplex *) : 0];
          cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(cuComplex *) > sizeof(cuComplex) ? sizeof(cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } b;
      float * c;
      cuComplex * s;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCrotg_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( a ) {
    hfcuda_am_node_t* _____a_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) a, devId );
    bool _____a_PASSONHOST = ! (_____a_MEMCHECK && _____a_MEMCHECK->isdevice );
    if( _____a_PASSONHOST ) {
      t2d_msg->data.a.val = *a;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.a.ptr = a;
    }
  }
  else {
    t2d_msg->data.a.ptr = NULL;
  }
  if( b ) {
    hfcuda_am_node_t* _____b_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) b, devId );
    bool _____b_PASSONHOST = ! (_____b_MEMCHECK && _____b_MEMCHECK->isdevice );
    if( _____b_PASSONHOST ) {
      t2d_msg->data.b.val = *b;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.b.ptr = b;
    }
  }
  else {
    t2d_msg->data.b.ptr = NULL;
  }
  t2d_msg->data.c = c;
  if( c ) {
    hfcuda_am_node_t* _____c_MEMCHECK = hfcuda_am_mem_check( (float *) c, devId );
    uint8_t _____c_PASSONHOST = ! (_____c_MEMCHECK && _____c_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____c_PASSONHOST & 0x1) << 2);
  }
  t2d_msg->data.s = s;
  if( s ) {
    hfcuda_am_node_t* _____s_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) s, devId );
    uint8_t _____s_PASSONHOST = ! (_____s_MEMCHECK && _____s_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____s_PASSONHOST & 0x1) << 3);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    cuComplex a;
    cuComplex b;
    float c;
    cuComplex s;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( a && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *a = d2t_msg.a;
  }
  if( b && ((t2d_msg->data.____CAT2_BITMAP >> 1) & 0x1) ) {
    *b = d2t_msg.b;
  }
  if( c && ((t2d_msg->data.____CAT2_BITMAP >> 2) & 0x1) ) {
    *c = d2t_msg.c;
  }
  if( s && ((t2d_msg->data.____CAT2_BITMAP >> 3) & 0x1) ) {
    *s = d2t_msg.s;
  }
  hfinf( "[trapper] cublasCrotg_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCscal_v2 ( cublasHandle_t handle, int n, const cuComplex * alpha, cuComplex * x, int incx )
{
  hfinf( "[trapper] cublasCscal_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cuComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCscal_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCscal_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCsrot_v2 ( cublasHandle_t handle, int n, cuComplex * x, int incx, cuComplex * y, int incy, const float * c, const float * s )
{
  hfinf( "[trapper] cublasCsrot_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      cuComplex * x;
      int incx;
      cuComplex * y;
      int incy;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } c;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } s;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCsrot_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  if( c ) {
    hfcuda_am_node_t* _____c_MEMCHECK = hfcuda_am_mem_check( (float *) c, devId );
    bool _____c_PASSONHOST = ! (_____c_MEMCHECK && _____c_MEMCHECK->isdevice );
    if( _____c_PASSONHOST ) {
      t2d_msg->data.c.val = *c;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.c.ptr = c;
    }
  }
  else {
    t2d_msg->data.c.ptr = NULL;
  }
  if( s ) {
    hfcuda_am_node_t* _____s_MEMCHECK = hfcuda_am_mem_check( (float *) s, devId );
    bool _____s_PASSONHOST = ! (_____s_MEMCHECK && _____s_MEMCHECK->isdevice );
    if( _____s_PASSONHOST ) {
      t2d_msg->data.s.val = *s;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.s.ptr = s;
    }
  }
  else {
    t2d_msg->data.s.ptr = NULL;
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCsrot_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCsscal_v2 ( cublasHandle_t handle, int n, const float * alpha, cuComplex * x, int incx )
{
  hfinf( "[trapper] cublasCsscal_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cuComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCsscal_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCsscal_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCswap_v2 ( cublasHandle_t handle, int n, cuComplex * x, int incx, cuComplex * y, int incy )
{
  hfinf( "[trapper] cublasCswap_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      cuComplex * x;
      int incx;
      cuComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCswap_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCswap_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCsymm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasCsymm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCsymm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCsymm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCsymv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy )
{
  hfinf( "[trapper] cublasCsymv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCsymv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCsymv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCsyr2_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda )
{
  hfinf( "[trapper] cublasCsyr2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * x;
      int incx;
      const cuComplex * y;
      int incy;
      cuComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCsyr2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCsyr2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCsyr2k_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasCsyr2k_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCsyr2k_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCsyr2k_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCsyr_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, cuComplex * A, int lda )
{
  hfinf( "[trapper] cublasCsyr_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * x;
      int incx;
      cuComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCsyr_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCsyr_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCsyrk3mEx ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const void * A, cudaDataType Atype, int lda, const cuComplex * beta, void * C, cudaDataType Ctype, int ldc )
{
  hfinf( "[trapper] cublasCsyrk3mEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const void * A;
      cudaDataType Atype;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      void * C;
      cudaDataType Ctype;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCsyrk3mEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.Atype = Atype;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.Ctype = Ctype;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCsyrk3mEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCsyrkEx ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const void * A, cudaDataType Atype, int lda, const cuComplex * beta, void * C, cudaDataType Ctype, int ldc )
{
  hfinf( "[trapper] cublasCsyrkEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const void * A;
      cudaDataType Atype;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      void * C;
      cudaDataType Ctype;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCsyrkEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.Atype = Atype;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.Ctype = Ctype;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCsyrkEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCsyrk_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasCsyrk_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCsyrk_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCsyrk_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCsyrkx ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasCsyrkx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCsyrkx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCsyrkx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCtbmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuComplex * A, int lda, cuComplex * x, int incx )
{
  hfinf( "[trapper] cublasCtbmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      int k;
      const cuComplex * A;
      int lda;
      cuComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCtbmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCtbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCtbsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuComplex * A, int lda, cuComplex * x, int incx )
{
  hfinf( "[trapper] cublasCtbsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      int k;
      const cuComplex * A;
      int lda;
      cuComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCtbsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCtbsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCtpmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * AP, cuComplex * x, int incx )
{
  hfinf( "[trapper] cublasCtpmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const cuComplex * AP;
      cuComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCtpmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCtpmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCtpsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * AP, cuComplex * x, int incx )
{
  hfinf( "[trapper] cublasCtpsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const cuComplex * AP;
      cuComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCtpsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCtpsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCtpttr ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * AP, cuComplex * A, int lda )
{
  hfinf( "[trapper] cublasCtpttr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      const cuComplex * AP;
      cuComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCtpttr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCtpttr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCtrmm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cublasCtrmm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * B;
      int ldb;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCtrmm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCtrmm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCtrmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * A, int lda, cuComplex * x, int incx )
{
  hfinf( "[trapper] cublasCtrmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const cuComplex * A;
      int lda;
      cuComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCtrmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCtrmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCtrsmBatched ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex * alpha, const cuComplex * A [], int lda, cuComplex * B [], int ldb, int batchCount )
{
  hfinf( "[trapper] cublasCtrsmBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex ** A ;
      int lda;
      cuComplex ** B ;
      int ldb;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCtrsmBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCtrsmBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCtrsm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, cuComplex * B, int ldb )
{
  hfinf( "[trapper] cublasCtrsm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      cuComplex * B;
      int ldb;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCtrsm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCtrsm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCtrsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * A, int lda, cuComplex * x, int incx )
{
  hfinf( "[trapper] cublasCtrsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const cuComplex * A;
      int lda;
      cuComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCtrsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCtrsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasCtrttp ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * A, int lda, cuComplex * AP )
{
  hfinf( "[trapper] cublasCtrttp() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      const cuComplex * A;
      int lda;
      cuComplex * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasCtrttp );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasCtrttp() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDasum_v2 ( cublasHandle_t handle, int n, const double * x, int incx, double * result )
{
  hfinf( "[trapper] cublasDasum_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const double * x;
      int incx;
      double * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDasum_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (double *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    double result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasDasum_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDaxpy_v2 ( cublasHandle_t handle, int n, const double * alpha, const double * x, int incx, double * y, int incy )
{
  hfinf( "[trapper] cublasDaxpy_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * x;
      int incx;
      double * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDaxpy_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDaxpy_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDcopy_v2 ( cublasHandle_t handle, int n, const double * x, int incx, double * y, int incy )
{
  hfinf( "[trapper] cublasDcopy_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const double * x;
      int incx;
      double * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDcopy_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDcopy_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDdgmm ( cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const double * A, int lda, const double * x, int incx, double * C, int ldc )
{
  hfinf( "[trapper] cublasDdgmm() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasSideMode_t mode;
      int m;
      int n;
      const double * A;
      int lda;
      const double * x;
      int incx;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDdgmm );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mode = mode;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDdgmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDdot_v2 ( cublasHandle_t handle, int n, const double * x, int incx, const double * y, int incy, double * result )
{
  hfinf( "[trapper] cublasDdot_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const double * x;
      int incx;
      const double * y;
      int incy;
      double * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDdot_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (double *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    double result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasDdot_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDestroy_v2 ( cublasHandle_t handle )
{
  hfinf( "[trapper] cublasDestroy_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDestroy_v2 );
  t2d_msg->data.handle = handle;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDestroy_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDgbmv_v2 ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy )
{
  hfinf( "[trapper] cublasDgbmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      int kl;
      int ku;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      const double * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDgbmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.kl = kl;
  t2d_msg->data.ku = ku;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDgbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDgeam ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const double * alpha, const double * A, int lda, const double * beta, const double * B, int ldb, double * C, int ldc )
{
  hfinf( "[trapper] cublasDgeam() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      const double * B;
      int ldb;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDgeam );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDgeam() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDgelsBatched ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, double * Aarray [], int lda, double * Carray [], int ldc, int * info, int * devInfoArray, int batchSize )
{
  hfinf( "[trapper] cublasDgelsBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      int nrhs;
      double ** Aarray ;
      int lda;
      double ** Carray ;
      int ldc;
      int * devInfoArray;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDgelsBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nrhs = nrhs;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Carray = Carray;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.devInfoArray = devInfoArray;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasDgelsBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDgemmBatched ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double * alpha, const double * Aarray [], int lda, const double * Barray [], int ldb, const double * beta, double * Carray [], int ldc, int batchCount )
{
  hfinf( "[trapper] cublasDgemmBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double ** Aarray ;
      int lda;
      const double ** Barray ;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double ** Carray ;
      int ldc;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDgemmBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Barray = Barray;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.Carray = Carray;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDgemmBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDgemmStridedBatched ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double * alpha, const double * A, int lda, long long strideA, const double * B, int ldb, long long strideB, const double * beta, double * C, int ldc, long long strideC, int batchCount )
{
  hfinf( "[trapper] cublasDgemmStridedBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      long long strideA;
      const double * B;
      int ldb;
      long long strideB;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * C;
      int ldc;
      long long strideC;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDgemmStridedBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.strideA = strideA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.strideB = strideB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.strideC = strideC;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDgemmStridedBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDgemm_v2 ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc )
{
  hfinf( "[trapper] cublasDgemm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      const double * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDgemm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDgemm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDgemv_v2 ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy )
{
  hfinf( "[trapper] cublasDgemv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      const double * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDgemv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDgemv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDgeqrfBatched ( cublasHandle_t handle, int m, int n, double * Aarray [], int lda, double * TauArray [], int * info, int batchSize )
{
  hfinf( "[trapper] cublasDgeqrfBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int m;
      int n;
      double ** Aarray ;
      int lda;
      double ** TauArray ;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDgeqrfBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.TauArray = TauArray;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasDgeqrfBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDger_v2 ( cublasHandle_t handle, int m, int n, const double * alpha, const double * x, int incx, const double * y, int incy, double * A, int lda )
{
  hfinf( "[trapper] cublasDger_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * x;
      int incx;
      const double * y;
      int incy;
      double * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDger_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDger_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDgetrfBatched ( cublasHandle_t handle, int n, double * A [], int lda, int * P, int * info, int batchSize )
{
  hfinf( "[trapper] cublasDgetrfBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      double ** A ;
      int lda;
      int * P;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDgetrfBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.P = P;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDgetrfBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDgetriBatched ( cublasHandle_t handle, int n, const double * A [], int lda, const int * P, double * C [], int ldc, int * info, int batchSize )
{
  hfinf( "[trapper] cublasDgetriBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const double ** A ;
      int lda;
      const int * P;
      double ** C ;
      int ldc;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDgetriBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.P = P;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDgetriBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDgetrsBatched ( cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const double * Aarray [], int lda, const int * devIpiv, double * Barray [], int ldb, int * info, int batchSize )
{
  hfinf( "[trapper] cublasDgetrsBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasOperation_t trans;
      int n;
      int nrhs;
      const double ** Aarray ;
      int lda;
      const int * devIpiv;
      double ** Barray ;
      int ldb;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDgetrsBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.nrhs = nrhs;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.devIpiv = devIpiv;
  t2d_msg->data.Barray = Barray;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasDgetrsBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDmatinvBatched ( cublasHandle_t handle, int n, const double * A [], int lda, double * Ainv [], int lda_inv, int * info, int batchSize )
{
  hfinf( "[trapper] cublasDmatinvBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const double ** A ;
      int lda;
      double ** Ainv ;
      int lda_inv;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDmatinvBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Ainv = Ainv;
  t2d_msg->data.lda_inv = lda_inv;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDmatinvBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDnrm2_v2 ( cublasHandle_t handle, int n, const double * x, int incx, double * result )
{
  hfinf( "[trapper] cublasDnrm2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const double * x;
      int incx;
      double * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDnrm2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (double *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    double result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasDnrm2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDrot_v2 ( cublasHandle_t handle, int n, double * x, int incx, double * y, int incy, const double * c, const double * s )
{
  hfinf( "[trapper] cublasDrot_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      double * x;
      int incx;
      double * y;
      int incy;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } c;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } s;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDrot_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  if( c ) {
    hfcuda_am_node_t* _____c_MEMCHECK = hfcuda_am_mem_check( (double *) c, devId );
    bool _____c_PASSONHOST = ! (_____c_MEMCHECK && _____c_MEMCHECK->isdevice );
    if( _____c_PASSONHOST ) {
      t2d_msg->data.c.val = *c;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.c.ptr = c;
    }
  }
  else {
    t2d_msg->data.c.ptr = NULL;
  }
  if( s ) {
    hfcuda_am_node_t* _____s_MEMCHECK = hfcuda_am_mem_check( (double *) s, devId );
    bool _____s_PASSONHOST = ! (_____s_MEMCHECK && _____s_MEMCHECK->isdevice );
    if( _____s_PASSONHOST ) {
      t2d_msg->data.s.val = *s;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.s.ptr = s;
    }
  }
  else {
    t2d_msg->data.s.ptr = NULL;
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDrot_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDrotg_v2 ( cublasHandle_t handle, double * a, double * b, double * c, double * s )
{
  hfinf( "[trapper] cublasDrotg_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(double *) < sizeof(double) ? sizeof(double)-sizeof(double *) : 0];
          double * ptr;
        };
        struct {
          char ___dummy1[sizeof(double *) > sizeof(double) ? sizeof(double *)-sizeof(double) : 0];
          double val;
        };
      } a;
      union {
        struct {
          char ___dummy0[sizeof(double *) < sizeof(double) ? sizeof(double)-sizeof(double *) : 0];
          double * ptr;
        };
        struct {
          char ___dummy1[sizeof(double *) > sizeof(double) ? sizeof(double *)-sizeof(double) : 0];
          double val;
        };
      } b;
      double * c;
      double * s;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDrotg_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( a ) {
    hfcuda_am_node_t* _____a_MEMCHECK = hfcuda_am_mem_check( (double *) a, devId );
    bool _____a_PASSONHOST = ! (_____a_MEMCHECK && _____a_MEMCHECK->isdevice );
    if( _____a_PASSONHOST ) {
      t2d_msg->data.a.val = *a;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.a.ptr = a;
    }
  }
  else {
    t2d_msg->data.a.ptr = NULL;
  }
  if( b ) {
    hfcuda_am_node_t* _____b_MEMCHECK = hfcuda_am_mem_check( (double *) b, devId );
    bool _____b_PASSONHOST = ! (_____b_MEMCHECK && _____b_MEMCHECK->isdevice );
    if( _____b_PASSONHOST ) {
      t2d_msg->data.b.val = *b;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.b.ptr = b;
    }
  }
  else {
    t2d_msg->data.b.ptr = NULL;
  }
  t2d_msg->data.c = c;
  if( c ) {
    hfcuda_am_node_t* _____c_MEMCHECK = hfcuda_am_mem_check( (double *) c, devId );
    uint8_t _____c_PASSONHOST = ! (_____c_MEMCHECK && _____c_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____c_PASSONHOST & 0x1) << 2);
  }
  t2d_msg->data.s = s;
  if( s ) {
    hfcuda_am_node_t* _____s_MEMCHECK = hfcuda_am_mem_check( (double *) s, devId );
    uint8_t _____s_PASSONHOST = ! (_____s_MEMCHECK && _____s_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____s_PASSONHOST & 0x1) << 3);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    double a;
    double b;
    double c;
    double s;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( a && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *a = d2t_msg.a;
  }
  if( b && ((t2d_msg->data.____CAT2_BITMAP >> 1) & 0x1) ) {
    *b = d2t_msg.b;
  }
  if( c && ((t2d_msg->data.____CAT2_BITMAP >> 2) & 0x1) ) {
    *c = d2t_msg.c;
  }
  if( s && ((t2d_msg->data.____CAT2_BITMAP >> 3) & 0x1) ) {
    *s = d2t_msg.s;
  }
  hfinf( "[trapper] cublasDrotg_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDrotm_v2 ( cublasHandle_t handle, int n, double * x, int incx, double * y, int incy, const double * param )
{
  hfinf( "[trapper] cublasDrotm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      double * x;
      int incx;
      double * y;
      int incy;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } param;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDrotm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  if( param ) {
    hfcuda_am_node_t* _____param_MEMCHECK = hfcuda_am_mem_check( (double *) param, devId );
    bool _____param_PASSONHOST = ! (_____param_MEMCHECK && _____param_MEMCHECK->isdevice );
    if( _____param_PASSONHOST ) {
      t2d_msg->data.param.val = *param;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.param.ptr = param;
    }
  }
  else {
    t2d_msg->data.param.ptr = NULL;
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDrotm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDrotmg_v2 ( cublasHandle_t handle, double * d1, double * d2, double * x1, const double * y1, double * param )
{
  hfinf( "[trapper] cublasDrotmg_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(double *) < sizeof(double) ? sizeof(double)-sizeof(double *) : 0];
          double * ptr;
        };
        struct {
          char ___dummy1[sizeof(double *) > sizeof(double) ? sizeof(double *)-sizeof(double) : 0];
          double val;
        };
      } d1;
      union {
        struct {
          char ___dummy0[sizeof(double *) < sizeof(double) ? sizeof(double)-sizeof(double *) : 0];
          double * ptr;
        };
        struct {
          char ___dummy1[sizeof(double *) > sizeof(double) ? sizeof(double *)-sizeof(double) : 0];
          double val;
        };
      } d2;
      union {
        struct {
          char ___dummy0[sizeof(double *) < sizeof(double) ? sizeof(double)-sizeof(double *) : 0];
          double * ptr;
        };
        struct {
          char ___dummy1[sizeof(double *) > sizeof(double) ? sizeof(double *)-sizeof(double) : 0];
          double val;
        };
      } x1;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } y1;
      double * param;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDrotmg_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( d1 ) {
    hfcuda_am_node_t* _____d1_MEMCHECK = hfcuda_am_mem_check( (double *) d1, devId );
    bool _____d1_PASSONHOST = ! (_____d1_MEMCHECK && _____d1_MEMCHECK->isdevice );
    if( _____d1_PASSONHOST ) {
      t2d_msg->data.d1.val = *d1;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.d1.ptr = d1;
    }
  }
  else {
    t2d_msg->data.d1.ptr = NULL;
  }
  if( d2 ) {
    hfcuda_am_node_t* _____d2_MEMCHECK = hfcuda_am_mem_check( (double *) d2, devId );
    bool _____d2_PASSONHOST = ! (_____d2_MEMCHECK && _____d2_MEMCHECK->isdevice );
    if( _____d2_PASSONHOST ) {
      t2d_msg->data.d2.val = *d2;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.d2.ptr = d2;
    }
  }
  else {
    t2d_msg->data.d2.ptr = NULL;
  }
  if( x1 ) {
    hfcuda_am_node_t* _____x1_MEMCHECK = hfcuda_am_mem_check( (double *) x1, devId );
    bool _____x1_PASSONHOST = ! (_____x1_MEMCHECK && _____x1_MEMCHECK->isdevice );
    if( _____x1_PASSONHOST ) {
      t2d_msg->data.x1.val = *x1;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 2);
    }
    else {
      t2d_msg->data.x1.ptr = x1;
    }
  }
  else {
    t2d_msg->data.x1.ptr = NULL;
  }
  if( y1 ) {
    hfcuda_am_node_t* _____y1_MEMCHECK = hfcuda_am_mem_check( (double *) y1, devId );
    bool _____y1_PASSONHOST = ! (_____y1_MEMCHECK && _____y1_MEMCHECK->isdevice );
    if( _____y1_PASSONHOST ) {
      t2d_msg->data.y1.val = *y1;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 3);
    }
    else {
      t2d_msg->data.y1.ptr = y1;
    }
  }
  else {
    t2d_msg->data.y1.ptr = NULL;
  }
  t2d_msg->data.param = param;
  if( param ) {
    hfcuda_am_node_t* _____param_MEMCHECK = hfcuda_am_mem_check( (double *) param, devId );
    uint8_t _____param_PASSONHOST = ! (_____param_MEMCHECK && _____param_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____param_PASSONHOST & 0x1) << 4);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    double d1;
    double d2;
    double x1;
    double param[5];
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( d1 && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *d1 = d2t_msg.d1;
  }
  if( d2 && ((t2d_msg->data.____CAT2_BITMAP >> 1) & 0x1) ) {
    *d2 = d2t_msg.d2;
  }
  if( x1 && ((t2d_msg->data.____CAT2_BITMAP >> 2) & 0x1) ) {
    *x1 = d2t_msg.x1;
  }
  if( param && ((t2d_msg->data.____CAT2_BITMAP >> 4) & 0x1) ) {
    memcpy(param, d2t_msg.param, sizeof(d2t_msg.param));
  }
  hfinf( "[trapper] cublasDrotmg_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDsbmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy )
{
  hfinf( "[trapper] cublasDsbmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      const double * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDsbmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDsbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDscal_v2 ( cublasHandle_t handle, int n, const double * alpha, double * x, int incx )
{
  hfinf( "[trapper] cublasDscal_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      double * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDscal_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDscal_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDspmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * AP, const double * x, int incx, const double * beta, double * y, int incy )
{
  hfinf( "[trapper] cublasDspmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * AP;
      const double * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDspmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDspmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDspr2_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, const double * y, int incy, double * AP )
{
  hfinf( "[trapper] cublasDspr2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * x;
      int incx;
      const double * y;
      int incy;
      double * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDspr2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDspr2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDspr_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, double * AP )
{
  hfinf( "[trapper] cublasDspr_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * x;
      int incx;
      double * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDspr_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDspr_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDswap_v2 ( cublasHandle_t handle, int n, double * x, int incx, double * y, int incy )
{
  hfinf( "[trapper] cublasDswap_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      double * x;
      int incx;
      double * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDswap_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDswap_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDsymm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc )
{
  hfinf( "[trapper] cublasDsymm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      const double * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDsymm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDsymm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDsymv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy )
{
  hfinf( "[trapper] cublasDsymv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      const double * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDsymv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDsymv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDsyr2_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, const double * y, int incy, double * A, int lda )
{
  hfinf( "[trapper] cublasDsyr2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * x;
      int incx;
      const double * y;
      int incy;
      double * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDsyr2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDsyr2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDsyr2k_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc )
{
  hfinf( "[trapper] cublasDsyr2k_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      const double * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDsyr2k_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDsyr2k_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDsyr_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, double * A, int lda )
{
  hfinf( "[trapper] cublasDsyr_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * x;
      int incx;
      double * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDsyr_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDsyr_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDsyrk_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const double * A, int lda, const double * beta, double * C, int ldc )
{
  hfinf( "[trapper] cublasDsyrk_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDsyrk_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDsyrk_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDsyrkx ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc )
{
  hfinf( "[trapper] cublasDsyrkx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      const double * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDsyrkx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDsyrkx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDtbmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const double * A, int lda, double * x, int incx )
{
  hfinf( "[trapper] cublasDtbmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      int k;
      const double * A;
      int lda;
      double * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDtbmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDtbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDtbsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const double * A, int lda, double * x, int incx )
{
  hfinf( "[trapper] cublasDtbsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      int k;
      const double * A;
      int lda;
      double * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDtbsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDtbsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDtpmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * AP, double * x, int incx )
{
  hfinf( "[trapper] cublasDtpmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const double * AP;
      double * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDtpmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDtpmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDtpsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * AP, double * x, int incx )
{
  hfinf( "[trapper] cublasDtpsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const double * AP;
      double * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDtpsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDtpsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDtpttr ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * AP, double * A, int lda )
{
  hfinf( "[trapper] cublasDtpttr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      const double * AP;
      double * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDtpttr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDtpttr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDtrmm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double * alpha, const double * A, int lda, const double * B, int ldb, double * C, int ldc )
{
  hfinf( "[trapper] cublasDtrmm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      const double * B;
      int ldb;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDtrmm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDtrmm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDtrmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * A, int lda, double * x, int incx )
{
  hfinf( "[trapper] cublasDtrmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const double * A;
      int lda;
      double * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDtrmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDtrmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDtrsmBatched ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double * alpha, const double * A [], int lda, double * B [], int ldb, int batchCount )
{
  hfinf( "[trapper] cublasDtrsmBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double ** A ;
      int lda;
      double ** B ;
      int ldb;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDtrsmBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDtrsmBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDtrsm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double * alpha, const double * A, int lda, double * B, int ldb )
{
  hfinf( "[trapper] cublasDtrsm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      double * B;
      int ldb;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDtrsm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDtrsm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDtrsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * A, int lda, double * x, int incx )
{
  hfinf( "[trapper] cublasDtrsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const double * A;
      int lda;
      double * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDtrsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDtrsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDtrttp ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * A, int lda, double * AP )
{
  hfinf( "[trapper] cublasDtrttp() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      const double * A;
      int lda;
      double * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDtrttp );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasDtrttp() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDzasum_v2 ( cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, double * result )
{
  hfinf( "[trapper] cublasDzasum_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuDoubleComplex * x;
      int incx;
      double * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDzasum_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (double *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    double result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasDzasum_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasDznrm2_v2 ( cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, double * result )
{
  hfinf( "[trapper] cublasDznrm2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuDoubleComplex * x;
      int incx;
      double * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasDznrm2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (double *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    double result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasDznrm2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasGemmBatchedEx ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void * alpha, const void * Aarray [], cudaDataType Atype, int lda, const void * Barray [], cudaDataType Btype, int ldb, const void * beta, void * Carray [], cudaDataType Ctype, int ldc, int batchCount, cudaDataType computeType, cublasGemmAlgo_t algo )
{
  hfinf( "[trapper] cublasGemmBatchedEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } alpha;
      const void ** Aarray ;
      cudaDataType Atype;
      int lda;
      const void ** Barray ;
      cudaDataType Btype;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } beta;
      void ** Carray ;
      cudaDataType Ctype;
      int ldc;
      int batchCount;
      cudaDataType computeType;
      cublasGemmAlgo_t algo;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasGemmBatchedEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (void *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      switch( computeType ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.alpha.val[0] = *(uint8_t*)alpha;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.alpha.val[0] = *(uint16_t*)alpha;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.alpha.val[0] = *(uint32_t*)alpha;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          *(((uint64_t*)&t2d_msg->data.alpha.val[0]) + 1) = *(((uint64_t*)alpha) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, computeType);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.Atype = Atype;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Barray = Barray;
  t2d_msg->data.Btype = Btype;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (void *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      switch( computeType ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.beta.val[0] = *(uint8_t*)beta;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.beta.val[0] = *(uint16_t*)beta;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.beta.val[0] = *(uint32_t*)beta;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.beta.val[0] = *(uint64_t*)beta;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.beta.val[0] = *(uint64_t*)beta;
          *(((uint64_t*)&t2d_msg->data.beta.val[0]) + 1) = *(((uint64_t*)beta) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, computeType);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.Carray = Carray;
  t2d_msg->data.Ctype = Ctype;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.batchCount = batchCount;
  t2d_msg->data.computeType = computeType;
  t2d_msg->data.algo = algo;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasGemmBatchedEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasGemmEx ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void * alpha, const void * A, cudaDataType Atype, int lda, const void * B, cudaDataType Btype, int ldb, const void * beta, void * C, cudaDataType Ctype, int ldc, cudaDataType computeType, cublasGemmAlgo_t algo )
{
  hfinf( "[trapper] cublasGemmEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } alpha;
      const void * A;
      cudaDataType Atype;
      int lda;
      const void * B;
      cudaDataType Btype;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } beta;
      void * C;
      cudaDataType Ctype;
      int ldc;
      cudaDataType computeType;
      cublasGemmAlgo_t algo;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasGemmEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (void *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      switch( computeType ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.alpha.val[0] = *(uint8_t*)alpha;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.alpha.val[0] = *(uint16_t*)alpha;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.alpha.val[0] = *(uint32_t*)alpha;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          *(((uint64_t*)&t2d_msg->data.alpha.val[0]) + 1) = *(((uint64_t*)alpha) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, computeType);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.Atype = Atype;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.Btype = Btype;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (void *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      switch( computeType ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.beta.val[0] = *(uint8_t*)beta;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.beta.val[0] = *(uint16_t*)beta;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.beta.val[0] = *(uint32_t*)beta;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.beta.val[0] = *(uint64_t*)beta;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.beta.val[0] = *(uint64_t*)beta;
          *(((uint64_t*)&t2d_msg->data.beta.val[0]) + 1) = *(((uint64_t*)beta) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, computeType);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.Ctype = Ctype;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.computeType = computeType;
  t2d_msg->data.algo = algo;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasGemmEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasGemmStridedBatchedEx ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void * alpha, const void * A, cudaDataType Atype, int lda, long long strideA, const void * B, cudaDataType Btype, int ldb, long long strideB, const void * beta, void * C, cudaDataType Ctype, int ldc, long long strideC, int batchCount, cudaDataType computeType, cublasGemmAlgo_t algo )
{
  hfinf( "[trapper] cublasGemmStridedBatchedEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } alpha;
      const void * A;
      cudaDataType Atype;
      int lda;
      long long strideA;
      const void * B;
      cudaDataType Btype;
      int ldb;
      long long strideB;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } beta;
      void * C;
      cudaDataType Ctype;
      int ldc;
      long long strideC;
      int batchCount;
      cudaDataType computeType;
      cublasGemmAlgo_t algo;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasGemmStridedBatchedEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (void *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      switch( computeType ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.alpha.val[0] = *(uint8_t*)alpha;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.alpha.val[0] = *(uint16_t*)alpha;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.alpha.val[0] = *(uint32_t*)alpha;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          *(((uint64_t*)&t2d_msg->data.alpha.val[0]) + 1) = *(((uint64_t*)alpha) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, computeType);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.Atype = Atype;
  t2d_msg->data.lda = lda;
  t2d_msg->data.strideA = strideA;
  t2d_msg->data.B = B;
  t2d_msg->data.Btype = Btype;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.strideB = strideB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (void *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      switch( computeType ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.beta.val[0] = *(uint8_t*)beta;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.beta.val[0] = *(uint16_t*)beta;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.beta.val[0] = *(uint32_t*)beta;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.beta.val[0] = *(uint64_t*)beta;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.beta.val[0] = *(uint64_t*)beta;
          *(((uint64_t*)&t2d_msg->data.beta.val[0]) + 1) = *(((uint64_t*)beta) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, computeType);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.Ctype = Ctype;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.strideC = strideC;
  t2d_msg->data.batchCount = batchCount;
  t2d_msg->data.computeType = computeType;
  t2d_msg->data.algo = algo;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasGemmStridedBatchedEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasGetAtomicsMode ( cublasHandle_t handle, cublasAtomicsMode_t * mode )
{
  hfinf( "[trapper] cublasGetAtomicsMode() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasGetAtomicsMode );
  t2d_msg->data.handle = handle;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    cublasAtomicsMode_t mode;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( mode ) *mode = d2t_msg.mode;
  hfinf( "[trapper] cublasGetAtomicsMode() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasGetMathMode ( cublasHandle_t handle, cublasMath_t * mode )
{
  hfinf( "[trapper] cublasGetMathMode() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasGetMathMode );
  t2d_msg->data.handle = handle;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    cublasMath_t mode;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( mode ) *mode = d2t_msg.mode;
  hfinf( "[trapper] cublasGetMathMode() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasGetProperty ( libraryPropertyType type, int * value )
{
  hfinf( "[trapper] cublasGetProperty() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      libraryPropertyType type;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasGetProperty );
  t2d_msg->data.type = type;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int value;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( value ) *value = d2t_msg.value;
  hfinf( "[trapper] cublasGetProperty() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasGetStream_v2 ( cublasHandle_t handle, cudaStream_t * streamId )
{
  hfinf( "[trapper] cublasGetStream_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasGetStream_v2 );
  t2d_msg->data.handle = handle;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    cudaStream_t streamId;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( streamId ) *streamId = d2t_msg.streamId;
  hfinf( "[trapper] cublasGetStream_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasGetVersion_v2 ( cublasHandle_t handle, int * version )
{
  hfinf( "[trapper] cublasGetVersion_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasGetVersion_v2 );
  t2d_msg->data.handle = handle;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int version;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( version ) *version = d2t_msg.version;
  hfinf( "[trapper] cublasGetVersion_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasIcamax_v2 ( cublasHandle_t handle, int n, const cuComplex * x, int incx, int * result )
{
  hfinf( "[trapper] cublasIcamax_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuComplex * x;
      int incx;
      int * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasIcamax_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (int *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasIcamax_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasIcamin_v2 ( cublasHandle_t handle, int n, const cuComplex * x, int incx, int * result )
{
  hfinf( "[trapper] cublasIcamin_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuComplex * x;
      int incx;
      int * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasIcamin_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (int *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasIcamin_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasIdamax_v2 ( cublasHandle_t handle, int n, const double * x, int incx, int * result )
{
  hfinf( "[trapper] cublasIdamax_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const double * x;
      int incx;
      int * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasIdamax_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (int *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasIdamax_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasIdamin_v2 ( cublasHandle_t handle, int n, const double * x, int incx, int * result )
{
  hfinf( "[trapper] cublasIdamin_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const double * x;
      int incx;
      int * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasIdamin_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (int *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasIdamin_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasIsamax_v2 ( cublasHandle_t handle, int n, const float * x, int incx, int * result )
{
  hfinf( "[trapper] cublasIsamax_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const float * x;
      int incx;
      int * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasIsamax_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (int *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasIsamax_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasIsamin_v2 ( cublasHandle_t handle, int n, const float * x, int incx, int * result )
{
  hfinf( "[trapper] cublasIsamin_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const float * x;
      int incx;
      int * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasIsamin_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (int *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasIsamin_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasIzamax_v2 ( cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, int * result )
{
  hfinf( "[trapper] cublasIzamax_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuDoubleComplex * x;
      int incx;
      int * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasIzamax_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (int *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasIzamax_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasIzamin_v2 ( cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, int * result )
{
  hfinf( "[trapper] cublasIzamin_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuDoubleComplex * x;
      int incx;
      int * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasIzamin_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (int *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasIzamin_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSasum_v2 ( cublasHandle_t handle, int n, const float * x, int incx, float * result )
{
  hfinf( "[trapper] cublasSasum_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const float * x;
      int incx;
      float * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSasum_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (float *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    float result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasSasum_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSaxpy_v2 ( cublasHandle_t handle, int n, const float * alpha, const float * x, int incx, float * y, int incy )
{
  hfinf( "[trapper] cublasSaxpy_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * x;
      int incx;
      float * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSaxpy_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSaxpy_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasScalEx ( cublasHandle_t handle, int n, const void * alpha, cudaDataType alphaType, void * x, cudaDataType xType, int incx, cudaDataType executionType )
{
  hfinf( "[trapper] cublasScalEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } alpha;
      cudaDataType alphaType;
      void * x;
      cudaDataType xType;
      int incx;
      cudaDataType executionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasScalEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (void *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      switch( alphaType ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.alpha.val[0] = *(uint8_t*)alpha;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.alpha.val[0] = *(uint16_t*)alpha;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.alpha.val[0] = *(uint32_t*)alpha;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          *(((uint64_t*)&t2d_msg->data.alpha.val[0]) + 1) = *(((uint64_t*)alpha) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, alphaType);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.alphaType = alphaType;
  t2d_msg->data.x = x;
  t2d_msg->data.xType = xType;
  t2d_msg->data.incx = incx;
  t2d_msg->data.executionType = executionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasScalEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasScasum_v2 ( cublasHandle_t handle, int n, const cuComplex * x, int incx, float * result )
{
  hfinf( "[trapper] cublasScasum_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuComplex * x;
      int incx;
      float * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasScasum_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (float *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    float result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasScasum_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasScnrm2_v2 ( cublasHandle_t handle, int n, const cuComplex * x, int incx, float * result )
{
  hfinf( "[trapper] cublasScnrm2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuComplex * x;
      int incx;
      float * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasScnrm2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (float *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    float result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasScnrm2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasScopy_v2 ( cublasHandle_t handle, int n, const float * x, int incx, float * y, int incy )
{
  hfinf( "[trapper] cublasScopy_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const float * x;
      int incx;
      float * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasScopy_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasScopy_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSdgmm ( cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const float * A, int lda, const float * x, int incx, float * C, int ldc )
{
  hfinf( "[trapper] cublasSdgmm() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasSideMode_t mode;
      int m;
      int n;
      const float * A;
      int lda;
      const float * x;
      int incx;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSdgmm );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mode = mode;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSdgmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSdot_v2 ( cublasHandle_t handle, int n, const float * x, int incx, const float * y, int incy, float * result )
{
  hfinf( "[trapper] cublasSdot_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const float * x;
      int incx;
      const float * y;
      int incy;
      float * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSdot_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (float *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    float result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasSdot_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSetAtomicsMode ( cublasHandle_t handle, cublasAtomicsMode_t mode )
{
  hfinf( "[trapper] cublasSetAtomicsMode() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasAtomicsMode_t mode;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSetAtomicsMode );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mode = mode;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSetAtomicsMode() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSetMathMode ( cublasHandle_t handle, cublasMath_t mode )
{
  hfinf( "[trapper] cublasSetMathMode() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasMath_t mode;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSetMathMode );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mode = mode;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSetMathMode() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSetStream_v2 ( cublasHandle_t handle, cudaStream_t streamId )
{
  hfinf( "[trapper] cublasSetStream_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cudaStream_t streamId;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSetStream_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.streamId = streamId;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSetStream_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgbmv_v2 ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy )
{
  hfinf( "[trapper] cublasSgbmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      int kl;
      int ku;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      const float * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgbmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.kl = kl;
  t2d_msg->data.ku = ku;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSgbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgeam ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const float * alpha, const float * A, int lda, const float * beta, const float * B, int ldb, float * C, int ldc )
{
  hfinf( "[trapper] cublasSgeam() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      const float * B;
      int ldb;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgeam );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSgeam() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgelsBatched ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, float * Aarray [], int lda, float * Carray [], int ldc, int * info, int * devInfoArray, int batchSize )
{
  hfinf( "[trapper] cublasSgelsBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      int nrhs;
      float ** Aarray ;
      int lda;
      float ** Carray ;
      int ldc;
      int * devInfoArray;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgelsBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nrhs = nrhs;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Carray = Carray;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.devInfoArray = devInfoArray;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasSgelsBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgemmBatched ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const float * Aarray [], int lda, const float * Barray [], int ldb, const float * beta, float * Carray [], int ldc, int batchCount )
{
  hfinf( "[trapper] cublasSgemmBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float ** Aarray ;
      int lda;
      const float ** Barray ;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float ** Carray ;
      int ldc;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgemmBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Barray = Barray;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.Carray = Carray;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSgemmBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgemmEx ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const void * A, cudaDataType Atype, int lda, const void * B, cudaDataType Btype, int ldb, const float * beta, void * C, cudaDataType Ctype, int ldc )
{
  hfinf( "[trapper] cublasSgemmEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const void * A;
      cudaDataType Atype;
      int lda;
      const void * B;
      cudaDataType Btype;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      void * C;
      cudaDataType Ctype;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgemmEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.Atype = Atype;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.Btype = Btype;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.Ctype = Ctype;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSgemmEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgemmStridedBatched ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const float * A, int lda, long long strideA, const float * B, int ldb, long long strideB, const float * beta, float * C, int ldc, long long strideC, int batchCount )
{
  hfinf( "[trapper] cublasSgemmStridedBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      long long strideA;
      const float * B;
      int ldb;
      long long strideB;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * C;
      int ldc;
      long long strideC;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgemmStridedBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.strideA = strideA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.strideB = strideB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.strideC = strideC;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSgemmStridedBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgemm_v2 ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc )
{
  hfinf( "[trapper] cublasSgemm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      const float * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgemm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSgemm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgemv_v2 ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy )
{
  hfinf( "[trapper] cublasSgemv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      const float * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgemv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSgemv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgeqrfBatched ( cublasHandle_t handle, int m, int n, float * Aarray [], int lda, float * TauArray [], int * info, int batchSize )
{
  hfinf( "[trapper] cublasSgeqrfBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int m;
      int n;
      float ** Aarray ;
      int lda;
      float ** TauArray ;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgeqrfBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.TauArray = TauArray;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasSgeqrfBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSger_v2 ( cublasHandle_t handle, int m, int n, const float * alpha, const float * x, int incx, const float * y, int incy, float * A, int lda )
{
  hfinf( "[trapper] cublasSger_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * x;
      int incx;
      const float * y;
      int incy;
      float * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSger_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSger_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgetrfBatched ( cublasHandle_t handle, int n, float * A [], int lda, int * P, int * info, int batchSize )
{
  hfinf( "[trapper] cublasSgetrfBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      float ** A ;
      int lda;
      int * P;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgetrfBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.P = P;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSgetrfBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgetriBatched ( cublasHandle_t handle, int n, const float * A [], int lda, const int * P, float * C [], int ldc, int * info, int batchSize )
{
  hfinf( "[trapper] cublasSgetriBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const float ** A ;
      int lda;
      const int * P;
      float ** C ;
      int ldc;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgetriBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.P = P;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSgetriBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSgetrsBatched ( cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const float * Aarray [], int lda, const int * devIpiv, float * Barray [], int ldb, int * info, int batchSize )
{
  hfinf( "[trapper] cublasSgetrsBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasOperation_t trans;
      int n;
      int nrhs;
      const float ** Aarray ;
      int lda;
      const int * devIpiv;
      float ** Barray ;
      int ldb;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSgetrsBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.nrhs = nrhs;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.devIpiv = devIpiv;
  t2d_msg->data.Barray = Barray;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasSgetrsBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSmatinvBatched ( cublasHandle_t handle, int n, const float * A [], int lda, float * Ainv [], int lda_inv, int * info, int batchSize )
{
  hfinf( "[trapper] cublasSmatinvBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const float ** A ;
      int lda;
      float ** Ainv ;
      int lda_inv;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSmatinvBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Ainv = Ainv;
  t2d_msg->data.lda_inv = lda_inv;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSmatinvBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSnrm2_v2 ( cublasHandle_t handle, int n, const float * x, int incx, float * result )
{
  hfinf( "[trapper] cublasSnrm2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const float * x;
      int incx;
      float * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSnrm2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (float *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    float result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasSnrm2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSrot_v2 ( cublasHandle_t handle, int n, float * x, int incx, float * y, int incy, const float * c, const float * s )
{
  hfinf( "[trapper] cublasSrot_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      float * x;
      int incx;
      float * y;
      int incy;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } c;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } s;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSrot_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  if( c ) {
    hfcuda_am_node_t* _____c_MEMCHECK = hfcuda_am_mem_check( (float *) c, devId );
    bool _____c_PASSONHOST = ! (_____c_MEMCHECK && _____c_MEMCHECK->isdevice );
    if( _____c_PASSONHOST ) {
      t2d_msg->data.c.val = *c;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.c.ptr = c;
    }
  }
  else {
    t2d_msg->data.c.ptr = NULL;
  }
  if( s ) {
    hfcuda_am_node_t* _____s_MEMCHECK = hfcuda_am_mem_check( (float *) s, devId );
    bool _____s_PASSONHOST = ! (_____s_MEMCHECK && _____s_MEMCHECK->isdevice );
    if( _____s_PASSONHOST ) {
      t2d_msg->data.s.val = *s;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.s.ptr = s;
    }
  }
  else {
    t2d_msg->data.s.ptr = NULL;
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSrot_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSrotg_v2 ( cublasHandle_t handle, float * a, float * b, float * c, float * s )
{
  hfinf( "[trapper] cublasSrotg_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(float *) < sizeof(float) ? sizeof(float)-sizeof(float *) : 0];
          float * ptr;
        };
        struct {
          char ___dummy1[sizeof(float *) > sizeof(float) ? sizeof(float *)-sizeof(float) : 0];
          float val;
        };
      } a;
      union {
        struct {
          char ___dummy0[sizeof(float *) < sizeof(float) ? sizeof(float)-sizeof(float *) : 0];
          float * ptr;
        };
        struct {
          char ___dummy1[sizeof(float *) > sizeof(float) ? sizeof(float *)-sizeof(float) : 0];
          float val;
        };
      } b;
      float * c;
      float * s;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSrotg_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( a ) {
    hfcuda_am_node_t* _____a_MEMCHECK = hfcuda_am_mem_check( (float *) a, devId );
    bool _____a_PASSONHOST = ! (_____a_MEMCHECK && _____a_MEMCHECK->isdevice );
    if( _____a_PASSONHOST ) {
      t2d_msg->data.a.val = *a;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.a.ptr = a;
    }
  }
  else {
    t2d_msg->data.a.ptr = NULL;
  }
  if( b ) {
    hfcuda_am_node_t* _____b_MEMCHECK = hfcuda_am_mem_check( (float *) b, devId );
    bool _____b_PASSONHOST = ! (_____b_MEMCHECK && _____b_MEMCHECK->isdevice );
    if( _____b_PASSONHOST ) {
      t2d_msg->data.b.val = *b;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.b.ptr = b;
    }
  }
  else {
    t2d_msg->data.b.ptr = NULL;
  }
  t2d_msg->data.c = c;
  if( c ) {
    hfcuda_am_node_t* _____c_MEMCHECK = hfcuda_am_mem_check( (float *) c, devId );
    uint8_t _____c_PASSONHOST = ! (_____c_MEMCHECK && _____c_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____c_PASSONHOST & 0x1) << 2);
  }
  t2d_msg->data.s = s;
  if( s ) {
    hfcuda_am_node_t* _____s_MEMCHECK = hfcuda_am_mem_check( (float *) s, devId );
    uint8_t _____s_PASSONHOST = ! (_____s_MEMCHECK && _____s_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____s_PASSONHOST & 0x1) << 3);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    float a;
    float b;
    float c;
    float s;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( a && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *a = d2t_msg.a;
  }
  if( b && ((t2d_msg->data.____CAT2_BITMAP >> 1) & 0x1) ) {
    *b = d2t_msg.b;
  }
  if( c && ((t2d_msg->data.____CAT2_BITMAP >> 2) & 0x1) ) {
    *c = d2t_msg.c;
  }
  if( s && ((t2d_msg->data.____CAT2_BITMAP >> 3) & 0x1) ) {
    *s = d2t_msg.s;
  }
  hfinf( "[trapper] cublasSrotg_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSrotm_v2 ( cublasHandle_t handle, int n, float * x, int incx, float * y, int incy, const float * param )
{
  hfinf( "[trapper] cublasSrotm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      float * x;
      int incx;
      float * y;
      int incy;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } param;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSrotm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  if( param ) {
    hfcuda_am_node_t* _____param_MEMCHECK = hfcuda_am_mem_check( (float *) param, devId );
    bool _____param_PASSONHOST = ! (_____param_MEMCHECK && _____param_MEMCHECK->isdevice );
    if( _____param_PASSONHOST ) {
      t2d_msg->data.param.val = *param;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.param.ptr = param;
    }
  }
  else {
    t2d_msg->data.param.ptr = NULL;
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSrotm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSrotmg_v2 ( cublasHandle_t handle, float * d1, float * d2, float * x1, const float * y1, float * param )
{
  hfinf( "[trapper] cublasSrotmg_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(float *) < sizeof(float) ? sizeof(float)-sizeof(float *) : 0];
          float * ptr;
        };
        struct {
          char ___dummy1[sizeof(float *) > sizeof(float) ? sizeof(float *)-sizeof(float) : 0];
          float val;
        };
      } d1;
      union {
        struct {
          char ___dummy0[sizeof(float *) < sizeof(float) ? sizeof(float)-sizeof(float *) : 0];
          float * ptr;
        };
        struct {
          char ___dummy1[sizeof(float *) > sizeof(float) ? sizeof(float *)-sizeof(float) : 0];
          float val;
        };
      } d2;
      union {
        struct {
          char ___dummy0[sizeof(float *) < sizeof(float) ? sizeof(float)-sizeof(float *) : 0];
          float * ptr;
        };
        struct {
          char ___dummy1[sizeof(float *) > sizeof(float) ? sizeof(float *)-sizeof(float) : 0];
          float val;
        };
      } x1;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } y1;
      float * param;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSrotmg_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( d1 ) {
    hfcuda_am_node_t* _____d1_MEMCHECK = hfcuda_am_mem_check( (float *) d1, devId );
    bool _____d1_PASSONHOST = ! (_____d1_MEMCHECK && _____d1_MEMCHECK->isdevice );
    if( _____d1_PASSONHOST ) {
      t2d_msg->data.d1.val = *d1;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.d1.ptr = d1;
    }
  }
  else {
    t2d_msg->data.d1.ptr = NULL;
  }
  if( d2 ) {
    hfcuda_am_node_t* _____d2_MEMCHECK = hfcuda_am_mem_check( (float *) d2, devId );
    bool _____d2_PASSONHOST = ! (_____d2_MEMCHECK && _____d2_MEMCHECK->isdevice );
    if( _____d2_PASSONHOST ) {
      t2d_msg->data.d2.val = *d2;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.d2.ptr = d2;
    }
  }
  else {
    t2d_msg->data.d2.ptr = NULL;
  }
  if( x1 ) {
    hfcuda_am_node_t* _____x1_MEMCHECK = hfcuda_am_mem_check( (float *) x1, devId );
    bool _____x1_PASSONHOST = ! (_____x1_MEMCHECK && _____x1_MEMCHECK->isdevice );
    if( _____x1_PASSONHOST ) {
      t2d_msg->data.x1.val = *x1;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 2);
    }
    else {
      t2d_msg->data.x1.ptr = x1;
    }
  }
  else {
    t2d_msg->data.x1.ptr = NULL;
  }
  if( y1 ) {
    hfcuda_am_node_t* _____y1_MEMCHECK = hfcuda_am_mem_check( (float *) y1, devId );
    bool _____y1_PASSONHOST = ! (_____y1_MEMCHECK && _____y1_MEMCHECK->isdevice );
    if( _____y1_PASSONHOST ) {
      t2d_msg->data.y1.val = *y1;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 3);
    }
    else {
      t2d_msg->data.y1.ptr = y1;
    }
  }
  else {
    t2d_msg->data.y1.ptr = NULL;
  }
  t2d_msg->data.param = param;
  if( param ) {
    hfcuda_am_node_t* _____param_MEMCHECK = hfcuda_am_mem_check( (float *) param, devId );
    uint8_t _____param_PASSONHOST = ! (_____param_MEMCHECK && _____param_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____param_PASSONHOST & 0x1) << 4);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    float d1;
    float d2;
    float x1;
    float param[5];
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( d1 && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *d1 = d2t_msg.d1;
  }
  if( d2 && ((t2d_msg->data.____CAT2_BITMAP >> 1) & 0x1) ) {
    *d2 = d2t_msg.d2;
  }
  if( x1 && ((t2d_msg->data.____CAT2_BITMAP >> 2) & 0x1) ) {
    *x1 = d2t_msg.x1;
  }
  if( param && ((t2d_msg->data.____CAT2_BITMAP >> 4) & 0x1) ) {
    memcpy(param, d2t_msg.param, sizeof(d2t_msg.param));
  }
  hfinf( "[trapper] cublasSrotmg_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSsbmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy )
{
  hfinf( "[trapper] cublasSsbmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      const float * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSsbmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSsbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSscal_v2 ( cublasHandle_t handle, int n, const float * alpha, float * x, int incx )
{
  hfinf( "[trapper] cublasSscal_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      float * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSscal_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSscal_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSspmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * AP, const float * x, int incx, const float * beta, float * y, int incy )
{
  hfinf( "[trapper] cublasSspmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * AP;
      const float * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSspmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSspmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSspr2_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, const float * y, int incy, float * AP )
{
  hfinf( "[trapper] cublasSspr2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * x;
      int incx;
      const float * y;
      int incy;
      float * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSspr2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSspr2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSspr_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, float * AP )
{
  hfinf( "[trapper] cublasSspr_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * x;
      int incx;
      float * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSspr_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSspr_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSswap_v2 ( cublasHandle_t handle, int n, float * x, int incx, float * y, int incy )
{
  hfinf( "[trapper] cublasSswap_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      float * x;
      int incx;
      float * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSswap_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSswap_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSsymm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc )
{
  hfinf( "[trapper] cublasSsymm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      const float * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSsymm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSsymm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSsymv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy )
{
  hfinf( "[trapper] cublasSsymv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      const float * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSsymv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSsymv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSsyr2_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, const float * y, int incy, float * A, int lda )
{
  hfinf( "[trapper] cublasSsyr2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * x;
      int incx;
      const float * y;
      int incy;
      float * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSsyr2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSsyr2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSsyr2k_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc )
{
  hfinf( "[trapper] cublasSsyr2k_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      const float * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSsyr2k_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSsyr2k_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSsyr_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, float * A, int lda )
{
  hfinf( "[trapper] cublasSsyr_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * x;
      int incx;
      float * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSsyr_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSsyr_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSsyrk_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const float * A, int lda, const float * beta, float * C, int ldc )
{
  hfinf( "[trapper] cublasSsyrk_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSsyrk_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSsyrk_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasSsyrkx ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc )
{
  hfinf( "[trapper] cublasSsyrkx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      const float * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasSsyrkx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasSsyrkx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasStbmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const float * A, int lda, float * x, int incx )
{
  hfinf( "[trapper] cublasStbmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      int k;
      const float * A;
      int lda;
      float * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasStbmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasStbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasStbsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const float * A, int lda, float * x, int incx )
{
  hfinf( "[trapper] cublasStbsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      int k;
      const float * A;
      int lda;
      float * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasStbsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasStbsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasStpmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * AP, float * x, int incx )
{
  hfinf( "[trapper] cublasStpmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const float * AP;
      float * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasStpmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasStpmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasStpsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * AP, float * x, int incx )
{
  hfinf( "[trapper] cublasStpsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const float * AP;
      float * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasStpsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasStpsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasStpttr ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * AP, float * A, int lda )
{
  hfinf( "[trapper] cublasStpttr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      const float * AP;
      float * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasStpttr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasStpttr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasStrmm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float * alpha, const float * A, int lda, const float * B, int ldb, float * C, int ldc )
{
  hfinf( "[trapper] cublasStrmm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      const float * B;
      int ldb;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasStrmm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasStrmm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasStrmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * A, int lda, float * x, int incx )
{
  hfinf( "[trapper] cublasStrmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const float * A;
      int lda;
      float * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasStrmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasStrmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasStrsmBatched ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float * alpha, const float * A [], int lda, float * B [], int ldb, int batchCount )
{
  hfinf( "[trapper] cublasStrsmBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float ** A ;
      int lda;
      float ** B ;
      int ldb;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasStrsmBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasStrsmBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasStrsm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float * alpha, const float * A, int lda, float * B, int ldb )
{
  hfinf( "[trapper] cublasStrsm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      float * B;
      int ldb;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasStrsm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasStrsm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasStrsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * A, int lda, float * x, int incx )
{
  hfinf( "[trapper] cublasStrsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const float * A;
      int lda;
      float * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasStrsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasStrsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasStrttp ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * A, int lda, float * AP )
{
  hfinf( "[trapper] cublasStrttp() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      const float * A;
      int lda;
      float * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasStrttp );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasStrttp() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZaxpy_v2 ( cublasHandle_t handle, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy )
{
  hfinf( "[trapper] cublasZaxpy_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * x;
      int incx;
      cuDoubleComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZaxpy_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZaxpy_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZcopy_v2 ( cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy )
{
  hfinf( "[trapper] cublasZcopy_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const cuDoubleComplex * x;
      int incx;
      cuDoubleComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZcopy_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZcopy_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZdgmm ( cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZdgmm() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasSideMode_t mode;
      int m;
      int n;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * x;
      int incx;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZdgmm );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mode = mode;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZdgmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZdotc_v2 ( cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * result )
{
  hfinf( "[trapper] cublasZdotc_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuDoubleComplex * x;
      int incx;
      const cuDoubleComplex * y;
      int incy;
      cuDoubleComplex * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZdotc_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    cuDoubleComplex result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasZdotc_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZdotu_v2 ( cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * result )
{
  hfinf( "[trapper] cublasZdotu_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      const cuDoubleComplex * x;
      int incx;
      const cuDoubleComplex * y;
      int incy;
      cuDoubleComplex * result;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZdotu_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.result = result;
  if( result ) {
    hfcuda_am_node_t* _____result_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) result, devId );
    uint8_t _____result_PASSONHOST = ! (_____result_MEMCHECK && _____result_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____result_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    cuDoubleComplex result;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( result && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *result = d2t_msg.result;
  }
  hfinf( "[trapper] cublasZdotu_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZdrot_v2 ( cublasHandle_t handle, int n, cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy, const double * c, const double * s )
{
  hfinf( "[trapper] cublasZdrot_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      cuDoubleComplex * x;
      int incx;
      cuDoubleComplex * y;
      int incy;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } c;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } s;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZdrot_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  if( c ) {
    hfcuda_am_node_t* _____c_MEMCHECK = hfcuda_am_mem_check( (double *) c, devId );
    bool _____c_PASSONHOST = ! (_____c_MEMCHECK && _____c_MEMCHECK->isdevice );
    if( _____c_PASSONHOST ) {
      t2d_msg->data.c.val = *c;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.c.ptr = c;
    }
  }
  else {
    t2d_msg->data.c.ptr = NULL;
  }
  if( s ) {
    hfcuda_am_node_t* _____s_MEMCHECK = hfcuda_am_mem_check( (double *) s, devId );
    bool _____s_PASSONHOST = ! (_____s_MEMCHECK && _____s_MEMCHECK->isdevice );
    if( _____s_PASSONHOST ) {
      t2d_msg->data.s.val = *s;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.s.ptr = s;
    }
  }
  else {
    t2d_msg->data.s.ptr = NULL;
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZdrot_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZdscal_v2 ( cublasHandle_t handle, int n, const double * alpha, cuDoubleComplex * x, int incx )
{
  hfinf( "[trapper] cublasZdscal_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cuDoubleComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZdscal_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZdscal_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgbmv_v2 ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy )
{
  hfinf( "[trapper] cublasZgbmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      int kl;
      int ku;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgbmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.kl = kl;
  t2d_msg->data.ku = ku;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZgbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgeam ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * beta, const cuDoubleComplex * B, int ldb, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZgeam() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      const cuDoubleComplex * B;
      int ldb;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgeam );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZgeam() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgelsBatched ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, cuDoubleComplex * Aarray [], int lda, cuDoubleComplex * Carray [], int ldc, int * info, int * devInfoArray, int batchSize )
{
  hfinf( "[trapper] cublasZgelsBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      int nrhs;
      cuDoubleComplex ** Aarray ;
      int lda;
      cuDoubleComplex ** Carray ;
      int ldc;
      int * devInfoArray;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgelsBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nrhs = nrhs;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Carray = Carray;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.devInfoArray = devInfoArray;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasZgelsBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgemmBatched ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * Aarray [], int lda, const cuDoubleComplex * Barray [], int ldb, const cuDoubleComplex * beta, cuDoubleComplex * Carray [], int ldc, int batchCount )
{
  hfinf( "[trapper] cublasZgemmBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex ** Aarray ;
      int lda;
      const cuDoubleComplex ** Barray ;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex ** Carray ;
      int ldc;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgemmBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Barray = Barray;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.Carray = Carray;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZgemmBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgemmStridedBatched ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, long long strideA, const cuDoubleComplex * B, int ldb, long long strideB, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc, long long strideC, int batchCount )
{
  hfinf( "[trapper] cublasZgemmStridedBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      long long strideA;
      const cuDoubleComplex * B;
      int ldb;
      long long strideB;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
      long long strideC;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgemmStridedBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.strideA = strideA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.strideB = strideB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.strideC = strideC;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZgemmStridedBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgemm_v2 ( cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZgemm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t transa;
      cublasOperation_t transb;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgemm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transa = transa;
  t2d_msg->data.transb = transb;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZgemm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgemv_v2 ( cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy )
{
  hfinf( "[trapper] cublasZgemv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasOperation_t trans;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgemv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZgemv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgeqrfBatched ( cublasHandle_t handle, int m, int n, cuDoubleComplex * Aarray [], int lda, cuDoubleComplex * TauArray [], int * info, int batchSize )
{
  hfinf( "[trapper] cublasZgeqrfBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int m;
      int n;
      cuDoubleComplex ** Aarray ;
      int lda;
      cuDoubleComplex ** TauArray ;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgeqrfBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.TauArray = TauArray;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasZgeqrfBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgerc_v2 ( cublasHandle_t handle, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda )
{
  hfinf( "[trapper] cublasZgerc_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * x;
      int incx;
      const cuDoubleComplex * y;
      int incy;
      cuDoubleComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgerc_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZgerc_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgeru_v2 ( cublasHandle_t handle, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda )
{
  hfinf( "[trapper] cublasZgeru_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * x;
      int incx;
      const cuDoubleComplex * y;
      int incy;
      cuDoubleComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgeru_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZgeru_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgetrfBatched ( cublasHandle_t handle, int n, cuDoubleComplex * A [], int lda, int * P, int * info, int batchSize )
{
  hfinf( "[trapper] cublasZgetrfBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      cuDoubleComplex ** A ;
      int lda;
      int * P;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgetrfBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.P = P;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZgetrfBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgetriBatched ( cublasHandle_t handle, int n, const cuDoubleComplex * A [], int lda, const int * P, cuDoubleComplex * C [], int ldc, int * info, int batchSize )
{
  hfinf( "[trapper] cublasZgetriBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const cuDoubleComplex ** A ;
      int lda;
      const int * P;
      cuDoubleComplex ** C ;
      int ldc;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgetriBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.P = P;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZgetriBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZgetrsBatched ( cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const cuDoubleComplex * Aarray [], int lda, const int * devIpiv, cuDoubleComplex * Barray [], int ldb, int * info, int batchSize )
{
  hfinf( "[trapper] cublasZgetrsBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasOperation_t trans;
      int n;
      int nrhs;
      const cuDoubleComplex ** Aarray ;
      int lda;
      const int * devIpiv;
      cuDoubleComplex ** Barray ;
      int ldb;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZgetrsBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.nrhs = nrhs;
  t2d_msg->data.Aarray = Aarray;
  t2d_msg->data.lda = lda;
  t2d_msg->data.devIpiv = devIpiv;
  t2d_msg->data.Barray = Barray;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    int info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cublasZgetrsBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZhbmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy )
{
  hfinf( "[trapper] cublasZhbmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZhbmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZhbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZhemm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZhemm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZhemm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZhemm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZhemv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy )
{
  hfinf( "[trapper] cublasZhemv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZhemv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZhemv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZher2_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda )
{
  hfinf( "[trapper] cublasZher2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * x;
      int incx;
      const cuDoubleComplex * y;
      int incy;
      cuDoubleComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZher2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZher2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZher2k_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const double * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZher2k_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZher2k_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZher2k_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZher_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * A, int lda )
{
  hfinf( "[trapper] cublasZher_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const cuDoubleComplex * x;
      int incx;
      cuDoubleComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZher_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZher_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZherk_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const cuDoubleComplex * A, int lda, const double * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZherk_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZherk_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZherk_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZherkx ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const double * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZherkx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZherkx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZherkx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZhpmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * AP, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy )
{
  hfinf( "[trapper] cublasZhpmv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * AP;
      const cuDoubleComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZhpmv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZhpmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZhpr2_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * AP )
{
  hfinf( "[trapper] cublasZhpr2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * x;
      int incx;
      const cuDoubleComplex * y;
      int incy;
      cuDoubleComplex * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZhpr2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZhpr2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZhpr_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * AP )
{
  hfinf( "[trapper] cublasZhpr_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const cuDoubleComplex * x;
      int incx;
      cuDoubleComplex * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZhpr_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZhpr_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZmatinvBatched ( cublasHandle_t handle, int n, const cuDoubleComplex * A [], int lda, cuDoubleComplex * Ainv [], int lda_inv, int * info, int batchSize )
{
  hfinf( "[trapper] cublasZmatinvBatched() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      const cuDoubleComplex ** A ;
      int lda;
      cuDoubleComplex ** Ainv ;
      int lda_inv;
      int * info;
      int batchSize;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZmatinvBatched );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.Ainv = Ainv;
  t2d_msg->data.lda_inv = lda_inv;
  t2d_msg->data.info = info;
  t2d_msg->data.batchSize = batchSize;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZmatinvBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZrot_v2 ( cublasHandle_t handle, int n, cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy, const double * c, const cuDoubleComplex * s )
{
  hfinf( "[trapper] cublasZrot_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      cuDoubleComplex * x;
      int incx;
      cuDoubleComplex * y;
      int incy;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } c;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } s;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZrot_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  if( c ) {
    hfcuda_am_node_t* _____c_MEMCHECK = hfcuda_am_mem_check( (double *) c, devId );
    bool _____c_PASSONHOST = ! (_____c_MEMCHECK && _____c_MEMCHECK->isdevice );
    if( _____c_PASSONHOST ) {
      t2d_msg->data.c.val = *c;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.c.ptr = c;
    }
  }
  else {
    t2d_msg->data.c.ptr = NULL;
  }
  if( s ) {
    hfcuda_am_node_t* _____s_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) s, devId );
    bool _____s_PASSONHOST = ! (_____s_MEMCHECK && _____s_MEMCHECK->isdevice );
    if( _____s_PASSONHOST ) {
      t2d_msg->data.s.val = *s;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.s.ptr = s;
    }
  }
  else {
    t2d_msg->data.s.ptr = NULL;
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZrot_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZrotg_v2 ( cublasHandle_t handle, cuDoubleComplex * a, cuDoubleComplex * b, double * c, cuDoubleComplex * s )
{
  hfinf( "[trapper] cublasZrotg_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(cuDoubleComplex *) : 0];
          cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } a;
      union {
        struct {
          char ___dummy0[sizeof(cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(cuDoubleComplex *) : 0];
          cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } b;
      double * c;
      cuDoubleComplex * s;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZrotg_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( a ) {
    hfcuda_am_node_t* _____a_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) a, devId );
    bool _____a_PASSONHOST = ! (_____a_MEMCHECK && _____a_MEMCHECK->isdevice );
    if( _____a_PASSONHOST ) {
      t2d_msg->data.a.val = *a;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.a.ptr = a;
    }
  }
  else {
    t2d_msg->data.a.ptr = NULL;
  }
  if( b ) {
    hfcuda_am_node_t* _____b_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) b, devId );
    bool _____b_PASSONHOST = ! (_____b_MEMCHECK && _____b_MEMCHECK->isdevice );
    if( _____b_PASSONHOST ) {
      t2d_msg->data.b.val = *b;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.b.ptr = b;
    }
  }
  else {
    t2d_msg->data.b.ptr = NULL;
  }
  t2d_msg->data.c = c;
  if( c ) {
    hfcuda_am_node_t* _____c_MEMCHECK = hfcuda_am_mem_check( (double *) c, devId );
    uint8_t _____c_PASSONHOST = ! (_____c_MEMCHECK && _____c_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____c_PASSONHOST & 0x1) << 2);
  }
  t2d_msg->data.s = s;
  if( s ) {
    hfcuda_am_node_t* _____s_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) s, devId );
    uint8_t _____s_PASSONHOST = ! (_____s_MEMCHECK && _____s_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____s_PASSONHOST & 0x1) << 3);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
    cuDoubleComplex a;
    cuDoubleComplex b;
    double c;
    cuDoubleComplex s;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( a && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *a = d2t_msg.a;
  }
  if( b && ((t2d_msg->data.____CAT2_BITMAP >> 1) & 0x1) ) {
    *b = d2t_msg.b;
  }
  if( c && ((t2d_msg->data.____CAT2_BITMAP >> 2) & 0x1) ) {
    *c = d2t_msg.c;
  }
  if( s && ((t2d_msg->data.____CAT2_BITMAP >> 3) & 0x1) ) {
    *s = d2t_msg.s;
  }
  hfinf( "[trapper] cublasZrotg_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZscal_v2 ( cublasHandle_t handle, int n, const cuDoubleComplex * alpha, cuDoubleComplex * x, int incx )
{
  hfinf( "[trapper] cublasZscal_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cuDoubleComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZscal_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZscal_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZswap_v2 ( cublasHandle_t handle, int n, cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy )
{
  hfinf( "[trapper] cublasZswap_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      int n;
      cuDoubleComplex * x;
      int incx;
      cuDoubleComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZswap_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZswap_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZsymm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZsymm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZsymm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZsymm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZsymv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy )
{
  hfinf( "[trapper] cublasZsymv_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * x;
      int incx;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
      int incy;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZsymv_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZsymv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZsyr2_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda )
{
  hfinf( "[trapper] cublasZsyr2_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * x;
      int incx;
      const cuDoubleComplex * y;
      int incy;
      cuDoubleComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZsyr2_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.y = y;
  t2d_msg->data.incy = incy;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZsyr2_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZsyr2k_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZsyr2k_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZsyr2k_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZsyr2k_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZsyr_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * A, int lda )
{
  hfinf( "[trapper] cublasZsyr_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * x;
      int incx;
      cuDoubleComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZsyr_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZsyr_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZsyrk_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZsyrk_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZsyrk_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZsyrk_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZsyrkx ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZsyrkx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZsyrkx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZsyrkx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZtbmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx )
{
  hfinf( "[trapper] cublasZtbmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      int k;
      const cuDoubleComplex * A;
      int lda;
      cuDoubleComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZtbmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZtbmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZtbsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx )
{
  hfinf( "[trapper] cublasZtbsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      int k;
      const cuDoubleComplex * A;
      int lda;
      cuDoubleComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZtbsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZtbsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZtpmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * AP, cuDoubleComplex * x, int incx )
{
  hfinf( "[trapper] cublasZtpmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const cuDoubleComplex * AP;
      cuDoubleComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZtpmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZtpmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZtpsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * AP, cuDoubleComplex * x, int incx )
{
  hfinf( "[trapper] cublasZtpsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const cuDoubleComplex * AP;
      cuDoubleComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZtpsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZtpsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZtpttr ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * AP, cuDoubleComplex * A, int lda )
{
  hfinf( "[trapper] cublasZtpttr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      const cuDoubleComplex * AP;
      cuDoubleComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZtpttr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.AP = AP;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZtpttr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZtrmm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cublasZtrmm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * B;
      int ldb;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZtrmm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZtrmm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZtrmv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx )
{
  hfinf( "[trapper] cublasZtrmv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const cuDoubleComplex * A;
      int lda;
      cuDoubleComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZtrmv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZtrmv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZtrsmBatched ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A [], int lda, cuDoubleComplex * B [], int ldb, int batchCount )
{
  hfinf( "[trapper] cublasZtrsmBatched() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex ** A ;
      int lda;
      cuDoubleComplex ** B ;
      int ldb;
      int batchCount;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZtrsmBatched );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  t2d_msg->data.batchCount = batchCount;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZtrsmBatched() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZtrsm_v2 ( cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, cuDoubleComplex * B, int ldb )
{
  hfinf( "[trapper] cublasZtrsm_v2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cublasHandle_t handle;
      cublasSideMode_t side;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      cuDoubleComplex * B;
      int ldb;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZtrsm_v2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.side = side;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZtrsm_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZtrsv_v2 ( cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx )
{
  hfinf( "[trapper] cublasZtrsv_v2() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      cublasOperation_t trans;
      cublasDiagType_t diag;
      int n;
      const cuDoubleComplex * A;
      int lda;
      cuDoubleComplex * x;
      int incx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZtrsv_v2 );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.trans = trans;
  t2d_msg->data.diag = diag;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.x = x;
  t2d_msg->data.incx = incx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZtrsv_v2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cublasStatus_t
cublasZtrttp ( cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * A, int lda, cuDoubleComplex * AP )
{
  hfinf( "[trapper] cublasZtrttp() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cublasHandle_t handle;
      cublasFillMode_t uplo;
      int n;
      const cuDoubleComplex * A;
      int lda;
      cuDoubleComplex * AP;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cublasZtrttp );
  t2d_msg->data.handle = handle;
  t2d_msg->data.uplo = uplo;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.AP = AP;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cublasStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cublasZtrttp() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaDeviceGetAttribute ( int * value, enum cudaDeviceAttr attr, int device )
{
  hfinf( "[trapper] cudaDeviceGetAttribute() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      enum cudaDeviceAttr attr;
      int device;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaDeviceGetAttribute );
  t2d_msg->data.attr = attr;
  t2d_msg->data.device = device;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    int value;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( value ) *value = d2t_msg.value;
  hfinf( "[trapper] cudaDeviceGetAttribute() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaDeviceGetCacheConfig ( enum cudaFuncCache * pCacheConfig )
{
  hfinf( "[trapper] cudaDeviceGetCacheConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaDeviceGetCacheConfig );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    enum cudaFuncCache pCacheConfig;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pCacheConfig ) *pCacheConfig = d2t_msg.pCacheConfig;
  hfinf( "[trapper] cudaDeviceGetCacheConfig() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaDeviceGetLimit ( size_t * pValue, enum cudaLimit limit )
{
  hfinf( "[trapper] cudaDeviceGetLimit() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      enum cudaLimit limit;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaDeviceGetLimit );
  t2d_msg->data.limit = limit;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    size_t pValue;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pValue ) *pValue = d2t_msg.pValue;
  hfinf( "[trapper] cudaDeviceGetLimit() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaDeviceGetSharedMemConfig ( enum cudaSharedMemConfig * pConfig )
{
  hfinf( "[trapper] cudaDeviceGetSharedMemConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaDeviceGetSharedMemConfig );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    enum cudaSharedMemConfig pConfig;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pConfig ) *pConfig = d2t_msg.pConfig;
  hfinf( "[trapper] cudaDeviceGetSharedMemConfig() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaDeviceGetStreamPriorityRange ( int * leastPriority, int * greatestPriority )
{
  hfinf( "[trapper] cudaDeviceGetStreamPriorityRange() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      union {
        struct {
          char ___dummy0[sizeof(int *) < sizeof(int) ? sizeof(int)-sizeof(int *) : 0];
          int * ptr;
        };
        struct {
          char ___dummy1[sizeof(int *) > sizeof(int) ? sizeof(int *)-sizeof(int) : 0];
          int val;
        };
      } greatestPriority;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaDeviceGetStreamPriorityRange );
  t2d_msg->data.____CAT2_BITMAP = 0;
  if( greatestPriority ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    t2d_msg->data.greatestPriority.val = *greatestPriority;
  }
  else {
    t2d_msg->data.greatestPriority.ptr = NULL;
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    int leastPriority;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( leastPriority ) *leastPriority = d2t_msg.leastPriority;
  hfinf( "[trapper] cudaDeviceGetStreamPriorityRange() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaDeviceReset ( void )
{
  hfinf( "[trapper] cudaDeviceReset() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaDeviceReset );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaDeviceReset() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaDeviceSetCacheConfig ( enum cudaFuncCache cacheConfig )
{
  hfinf( "[trapper] cudaDeviceSetCacheConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      enum cudaFuncCache cacheConfig;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaDeviceSetCacheConfig );
  t2d_msg->data.cacheConfig = cacheConfig;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaDeviceSetCacheConfig() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaDeviceSetLimit ( enum cudaLimit limit, size_t value )
{
  hfinf( "[trapper] cudaDeviceSetLimit() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      enum cudaLimit limit;
      size_t value;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaDeviceSetLimit );
  t2d_msg->data.limit = limit;
  t2d_msg->data.value = value;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaDeviceSetLimit() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaDeviceSetSharedMemConfig ( enum cudaSharedMemConfig config )
{
  hfinf( "[trapper] cudaDeviceSetSharedMemConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      enum cudaSharedMemConfig config;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaDeviceSetSharedMemConfig );
  t2d_msg->data.config = config;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaDeviceSetSharedMemConfig() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaDeviceSynchronize ( void )
{
  hfinf( "[trapper] cudaDeviceSynchronize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaDeviceSynchronize );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaDeviceSynchronize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaDriverGetVersion ( int * driverVersion )
{
  hfinf( "[trapper] cudaDriverGetVersion() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaDriverGetVersion );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    int driverVersion;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( driverVersion ) *driverVersion = d2t_msg.driverVersion;
  hfinf( "[trapper] cudaDriverGetVersion() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaEventCreate ( cudaEvent_t * event )
{
  hfinf( "[trapper] cudaEventCreate() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaEventCreate );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    cudaEvent_t event;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( event ) *event = d2t_msg.event;
  hfinf( "[trapper] cudaEventCreate() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaEventCreateWithFlags ( cudaEvent_t * event, unsigned int flags )
{
  hfinf( "[trapper] cudaEventCreateWithFlags() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      unsigned int flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaEventCreateWithFlags );
  t2d_msg->data.flags = flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    cudaEvent_t event;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( event ) *event = d2t_msg.event;
  hfinf( "[trapper] cudaEventCreateWithFlags() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaEventDestroy ( cudaEvent_t event )
{
  hfinf( "[trapper] cudaEventDestroy() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudaEvent_t event;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaEventDestroy );
  t2d_msg->data.event = event;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaEventDestroy() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaEventElapsedTime ( float * ms, cudaEvent_t start, cudaEvent_t end )
{
  hfinf( "[trapper] cudaEventElapsedTime() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudaEvent_t start;
      cudaEvent_t end;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaEventElapsedTime );
  t2d_msg->data.start = start;
  t2d_msg->data.end = end;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    float ms;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( ms ) *ms = d2t_msg.ms;
  hfinf( "[trapper] cudaEventElapsedTime() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaEventQuery ( cudaEvent_t event )
{
  hfinf( "[trapper] cudaEventQuery() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudaEvent_t event;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaEventQuery );
  t2d_msg->data.event = event;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaEventQuery() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaEventRecord ( cudaEvent_t event, cudaStream_t stream )
{
  hfinf( "[trapper] cudaEventRecord() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudaEvent_t event;
      cudaStream_t stream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaEventRecord );
  t2d_msg->data.event = event;
  t2d_msg->data.stream = stream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaEventRecord() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaEventSynchronize ( cudaEvent_t event )
{
  hfinf( "[trapper] cudaEventSynchronize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudaEvent_t event;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaEventSynchronize );
  t2d_msg->data.event = event;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaEventSynchronize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaGetDeviceFlags ( unsigned int * flags )
{
  hfinf( "[trapper] cudaGetDeviceFlags() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaGetDeviceFlags );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    unsigned int flags;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( flags ) *flags = d2t_msg.flags;
  hfinf( "[trapper] cudaGetDeviceFlags() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaGetLastError ( void )
{
  hfinf( "[trapper] cudaGetLastError() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaGetLastError );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaGetLastError() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaMemset ( void * devPtr, int value, size_t count )
{
  hfinf( "[trapper] cudaMemset() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      void * devPtr;
      int value;
      size_t count;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaMemset );
  t2d_msg->data.devPtr = devPtr;
  t2d_msg->data.value = value;
  t2d_msg->data.count = count;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaMemset() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaMemset2D ( void * devPtr, size_t pitch, int value, size_t width, size_t height )
{
  hfinf( "[trapper] cudaMemset2D() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      void * devPtr;
      size_t pitch;
      int value;
      size_t width;
      size_t height;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaMemset2D );
  t2d_msg->data.devPtr = devPtr;
  t2d_msg->data.pitch = pitch;
  t2d_msg->data.value = value;
  t2d_msg->data.width = width;
  t2d_msg->data.height = height;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaMemset2D() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaMemset3D ( struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent )
{
  hfinf( "[trapper] cudaMemset3D() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      struct cudaPitchedPtr pitchedDevPtr;
      int value;
      struct cudaExtent extent;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaMemset3D );
  t2d_msg->data.pitchedDevPtr = pitchedDevPtr;
  t2d_msg->data.value = value;
  t2d_msg->data.extent = extent;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaMemset3D() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaPeekAtLastError ( void )
{
  hfinf( "[trapper] cudaPeekAtLastError() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaPeekAtLastError );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaPeekAtLastError() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaRuntimeGetVersion ( int * runtimeVersion )
{
  hfinf( "[trapper] cudaRuntimeGetVersion() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaRuntimeGetVersion );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    int runtimeVersion;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( runtimeVersion ) *runtimeVersion = d2t_msg.runtimeVersion;
  hfinf( "[trapper] cudaRuntimeGetVersion() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaSetDeviceFlags ( unsigned int flags )
{
  hfinf( "[trapper] cudaSetDeviceFlags() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      unsigned int flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaSetDeviceFlags );
  t2d_msg->data.flags = flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaSetDeviceFlags() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaStreamCreate ( cudaStream_t * pStream )
{
  hfinf( "[trapper] cudaStreamCreate() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaStreamCreate );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    cudaStream_t pStream;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pStream ) *pStream = d2t_msg.pStream;
  hfinf( "[trapper] cudaStreamCreate() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaStreamCreateWithFlags ( cudaStream_t * pStream, unsigned int flags )
{
  hfinf( "[trapper] cudaStreamCreateWithFlags() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      unsigned int flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaStreamCreateWithFlags );
  t2d_msg->data.flags = flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    cudaStream_t pStream;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pStream ) *pStream = d2t_msg.pStream;
  hfinf( "[trapper] cudaStreamCreateWithFlags() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaStreamCreateWithPriority ( cudaStream_t * pStream, unsigned int flags, int priority )
{
  hfinf( "[trapper] cudaStreamCreateWithPriority() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      unsigned int flags;
      int priority;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaStreamCreateWithPriority );
  t2d_msg->data.flags = flags;
  t2d_msg->data.priority = priority;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    cudaStream_t pStream;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pStream ) *pStream = d2t_msg.pStream;
  hfinf( "[trapper] cudaStreamCreateWithPriority() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaStreamDestroy ( cudaStream_t stream )
{
  hfinf( "[trapper] cudaStreamDestroy() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudaStream_t stream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaStreamDestroy );
  t2d_msg->data.stream = stream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaStreamDestroy() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaStreamGetFlags ( cudaStream_t hStream, unsigned int * flags )
{
  hfinf( "[trapper] cudaStreamGetFlags() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudaStream_t hStream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaStreamGetFlags );
  t2d_msg->data.hStream = hStream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    unsigned int flags;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( flags ) *flags = d2t_msg.flags;
  hfinf( "[trapper] cudaStreamGetFlags() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaStreamGetPriority ( cudaStream_t hStream, int * priority )
{
  hfinf( "[trapper] cudaStreamGetPriority() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudaStream_t hStream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaStreamGetPriority );
  t2d_msg->data.hStream = hStream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    int priority;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( priority ) *priority = d2t_msg.priority;
  hfinf( "[trapper] cudaStreamGetPriority() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaStreamQuery ( cudaStream_t stream )
{
  hfinf( "[trapper] cudaStreamQuery() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudaStream_t stream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaStreamQuery );
  t2d_msg->data.stream = stream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaStreamQuery() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaStreamSynchronize ( cudaStream_t stream )
{
  hfinf( "[trapper] cudaStreamSynchronize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudaStream_t stream;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaStreamSynchronize );
  t2d_msg->data.stream = stream;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaStreamSynchronize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaStreamWaitEvent ( cudaStream_t stream, cudaEvent_t event, unsigned int flags )
{
  hfinf( "[trapper] cudaStreamWaitEvent() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudaStream_t stream;
      cudaEvent_t event;
      unsigned int flags;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaStreamWaitEvent );
  t2d_msg->data.stream = stream;
  t2d_msg->data.event = event;
  t2d_msg->data.flags = flags;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaStreamWaitEvent() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaThreadExit ( void )
{
  hfinf( "[trapper] cudaThreadExit() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaThreadExit );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaThreadExit() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaThreadGetCacheConfig ( enum cudaFuncCache * pCacheConfig )
{
  hfinf( "[trapper] cudaThreadGetCacheConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaThreadGetCacheConfig );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    enum cudaFuncCache pCacheConfig;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pCacheConfig ) *pCacheConfig = d2t_msg.pCacheConfig;
  hfinf( "[trapper] cudaThreadGetCacheConfig() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaThreadGetLimit ( size_t * pValue, enum cudaLimit limit )
{
  hfinf( "[trapper] cudaThreadGetLimit() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      enum cudaLimit limit;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaThreadGetLimit );
  t2d_msg->data.limit = limit;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
    size_t pValue;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pValue ) *pValue = d2t_msg.pValue;
  hfinf( "[trapper] cudaThreadGetLimit() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaThreadSetCacheConfig ( enum cudaFuncCache cacheConfig )
{
  hfinf( "[trapper] cudaThreadSetCacheConfig() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      enum cudaFuncCache cacheConfig;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaThreadSetCacheConfig );
  t2d_msg->data.cacheConfig = cacheConfig;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaThreadSetCacheConfig() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaThreadSetLimit ( enum cudaLimit limit, size_t value )
{
  hfinf( "[trapper] cudaThreadSetLimit() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      enum cudaLimit limit;
      size_t value;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaThreadSetLimit );
  t2d_msg->data.limit = limit;
  t2d_msg->data.value = value;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaThreadSetLimit() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudaError_t
cudaThreadSynchronize ( void )
{
  hfinf( "[trapper] cudaThreadSynchronize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudaThreadSynchronize );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudaError_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudaThreadSynchronize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnActivationBackward ( cudnnHandle_t handle, cudnnActivationDescriptor_t activationDesc, const void * alpha, cudnnTensorDescriptor_t yDesc, const void * y, cudnnTensorDescriptor_t dyDesc, const void * dy, cudnnTensorDescriptor_t xDesc, const void * x, const void * beta, cudnnTensorDescriptor_t dxDesc, void * dx )
{
  hfinf( "[trapper] cudnnActivationBackward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnActivationDescriptor_t activationDesc;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t yDesc;
      const void * y;
      cudnnTensorDescriptor_t dyDesc;
      const void * dy;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t dxDesc;
      void * dx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnActivationBackward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.activationDesc = activationDesc;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____yDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, yDesc, &____yDesc_dataType ));
    switch( ____yDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____yDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.dy = dy;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____yDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, yDesc, &____yDesc_dataType ));
    switch( ____yDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____yDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.dxDesc = dxDesc;
  t2d_msg->data.dx = dx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnActivationBackward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnActivationForward ( cudnnHandle_t handle, cudnnActivationDescriptor_t activationDesc, const void * alpha, cudnnTensorDescriptor_t xDesc, const void * x, const void * beta, cudnnTensorDescriptor_t yDesc, void * y )
{
  hfinf( "[trapper] cudnnActivationForward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnActivationDescriptor_t activationDesc;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t yDesc;
      void * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnActivationForward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.activationDesc = activationDesc;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnActivationForward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnAddTensor ( cudnnHandle_t handle, const void * alpha, cudnnTensorDescriptor_t aDesc, const void * A, const void * beta, cudnnTensorDescriptor_t cDesc, void * C )
{
  hfinf( "[trapper] cudnnAddTensor() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t aDesc;
      const void * A;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t cDesc;
      void * C;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnAddTensor );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____aDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, aDesc, &____aDesc_dataType ));
    switch( ____aDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____aDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.aDesc = aDesc;
  t2d_msg->data.A = A;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____aDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, aDesc, &____aDesc_dataType ));
    switch( ____aDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____aDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.cDesc = cDesc;
  t2d_msg->data.C = C;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnAddTensor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnBatchNormalizationBackward ( cudnnHandle_t handle, cudnnBatchNormMode_t mode, const void * alphaDataDiff, const void * betaDataDiff, const void * alphaParamDiff, const void * betaParamDiff, cudnnTensorDescriptor_t xDesc, const void * x, cudnnTensorDescriptor_t dyDesc, const void * dy, cudnnTensorDescriptor_t dxDesc, void * dx, cudnnTensorDescriptor_t dBnScaleBiasDesc, const void * bnScale, void * dBnScaleResult, void * dBnBiasResult, double epsilon, const void * savedMean, const void * savedInvVariance )
{
  hfinf( "[trapper] cudnnBatchNormalizationBackward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnBatchNormMode_t mode;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alphaDataDiff;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } betaDataDiff;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alphaParamDiff;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } betaParamDiff;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      cudnnTensorDescriptor_t dyDesc;
      const void * dy;
      cudnnTensorDescriptor_t dxDesc;
      void * dx;
      cudnnTensorDescriptor_t dBnScaleBiasDesc;
      const void * bnScale;
      void * dBnScaleResult;
      void * dBnBiasResult;
      double epsilon;
      const void * savedMean;
      const void * savedInvVariance;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnBatchNormalizationBackward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.mode = mode;
  if( alphaDataDiff ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alphaDataDiff.val = *(float*)alphaDataDiff;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alphaDataDiff.val = *(double*)alphaDataDiff;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alphaDataDiff.ptr = NULL;
  }
  if( betaDataDiff ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.betaDataDiff.val = *(float*)betaDataDiff;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.betaDataDiff.val = *(double*)betaDataDiff;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.betaDataDiff.ptr = NULL;
  }
  if( alphaParamDiff ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 2);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alphaParamDiff.val = *(float*)alphaParamDiff;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alphaParamDiff.val = *(double*)alphaParamDiff;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alphaParamDiff.ptr = NULL;
  }
  if( betaParamDiff ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 3);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.betaParamDiff.val = *(float*)betaParamDiff;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.betaParamDiff.val = *(double*)betaParamDiff;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.betaParamDiff.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.dy = dy;
  t2d_msg->data.dxDesc = dxDesc;
  t2d_msg->data.dx = dx;
  t2d_msg->data.dBnScaleBiasDesc = dBnScaleBiasDesc;
  t2d_msg->data.bnScale = bnScale;
  t2d_msg->data.dBnScaleResult = dBnScaleResult;
  t2d_msg->data.dBnBiasResult = dBnBiasResult;
  t2d_msg->data.epsilon = epsilon;
  t2d_msg->data.savedMean = savedMean;
  t2d_msg->data.savedInvVariance = savedInvVariance;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnBatchNormalizationBackward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnBatchNormalizationForwardInference ( cudnnHandle_t handle, cudnnBatchNormMode_t mode, const void * alpha, const void * beta, cudnnTensorDescriptor_t xDesc, const void * x, cudnnTensorDescriptor_t yDesc, void * y, cudnnTensorDescriptor_t bnScaleBiasMeanVarDesc, const void * bnScale, const void * bnBias, const void * estimatedMean, const void * estimatedVariance, double epsilon )
{
  hfinf( "[trapper] cudnnBatchNormalizationForwardInference() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnBatchNormMode_t mode;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      cudnnTensorDescriptor_t yDesc;
      void * y;
      cudnnTensorDescriptor_t bnScaleBiasMeanVarDesc;
      const void * bnScale;
      const void * bnBias;
      const void * estimatedMean;
      const void * estimatedVariance;
      double epsilon;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnBatchNormalizationForwardInference );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.mode = mode;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  t2d_msg->data.bnScaleBiasMeanVarDesc = bnScaleBiasMeanVarDesc;
  t2d_msg->data.bnScale = bnScale;
  t2d_msg->data.bnBias = bnBias;
  t2d_msg->data.estimatedMean = estimatedMean;
  t2d_msg->data.estimatedVariance = estimatedVariance;
  t2d_msg->data.epsilon = epsilon;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnBatchNormalizationForwardInference() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnBatchNormalizationForwardTraining ( cudnnHandle_t handle, cudnnBatchNormMode_t mode, const void * alpha, const void * beta, cudnnTensorDescriptor_t xDesc, const void * x, cudnnTensorDescriptor_t yDesc, void * y, cudnnTensorDescriptor_t bnScaleBiasMeanVarDesc, const void * bnScale, const void * bnBias, double exponentialAverageFactor, void * resultRunningMean, void * resultRunningVariance, double epsilon, void * resultSaveMean, void * resultSaveInvVariance )
{
  hfinf( "[trapper] cudnnBatchNormalizationForwardTraining() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnBatchNormMode_t mode;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      cudnnTensorDescriptor_t yDesc;
      void * y;
      cudnnTensorDescriptor_t bnScaleBiasMeanVarDesc;
      const void * bnScale;
      const void * bnBias;
      double exponentialAverageFactor;
      void * resultRunningMean;
      void * resultRunningVariance;
      double epsilon;
      void * resultSaveMean;
      void * resultSaveInvVariance;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnBatchNormalizationForwardTraining );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.mode = mode;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  t2d_msg->data.bnScaleBiasMeanVarDesc = bnScaleBiasMeanVarDesc;
  t2d_msg->data.bnScale = bnScale;
  t2d_msg->data.bnBias = bnBias;
  t2d_msg->data.exponentialAverageFactor = exponentialAverageFactor;
  t2d_msg->data.resultRunningMean = resultRunningMean;
  t2d_msg->data.resultRunningVariance = resultRunningVariance;
  t2d_msg->data.epsilon = epsilon;
  t2d_msg->data.resultSaveMean = resultSaveMean;
  t2d_msg->data.resultSaveInvVariance = resultSaveInvVariance;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnBatchNormalizationForwardTraining() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnConvolutionBackwardBias ( cudnnHandle_t handle, const void * alpha, cudnnTensorDescriptor_t dyDesc, const void * dy, const void * beta, cudnnTensorDescriptor_t dbDesc, void * db )
{
  hfinf( "[trapper] cudnnConvolutionBackwardBias() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t dyDesc;
      const void * dy;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t dbDesc;
      void * db;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnConvolutionBackwardBias );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____dyDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, dyDesc, &____dyDesc_dataType ));
    switch( ____dyDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____dyDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.dy = dy;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____dyDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, dyDesc, &____dyDesc_dataType ));
    switch( ____dyDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____dyDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.dbDesc = dbDesc;
  t2d_msg->data.db = db;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnConvolutionBackwardBias() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnConvolutionBackwardData ( cudnnHandle_t handle, const void * alpha, cudnnFilterDescriptor_t wDesc, const void * w, cudnnTensorDescriptor_t dyDesc, const void * dy, cudnnConvolutionDescriptor_t convDesc, cudnnConvolutionBwdDataAlgo_t algo, void * workSpace, size_t workSpaceSizeInBytes, const void * beta, cudnnTensorDescriptor_t dxDesc, void * dx )
{
  hfinf( "[trapper] cudnnConvolutionBackwardData() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnFilterDescriptor_t wDesc;
      const void * w;
      cudnnTensorDescriptor_t dyDesc;
      const void * dy;
      cudnnConvolutionDescriptor_t convDesc;
      cudnnConvolutionBwdDataAlgo_t algo;
      void * workSpace;
      size_t workSpaceSizeInBytes;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t dxDesc;
      void * dx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnConvolutionBackwardData );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____dyDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, dyDesc, &____dyDesc_dataType ));
    switch( ____dyDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____dyDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.w = w;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.dy = dy;
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.algo = algo;
  t2d_msg->data.workSpace = workSpace;
  t2d_msg->data.workSpaceSizeInBytes = workSpaceSizeInBytes;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____dyDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, dyDesc, &____dyDesc_dataType ));
    switch( ____dyDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____dyDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.dxDesc = dxDesc;
  t2d_msg->data.dx = dx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnConvolutionBackwardData() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnConvolutionBackwardFilter ( cudnnHandle_t handle, const void * alpha, cudnnTensorDescriptor_t xDesc, const void * x, cudnnTensorDescriptor_t dyDesc, const void * dy, cudnnConvolutionDescriptor_t convDesc, cudnnConvolutionBwdFilterAlgo_t algo, void * workSpace, size_t workSpaceSizeInBytes, const void * beta, cudnnFilterDescriptor_t dwDesc, void * dw )
{
  hfinf( "[trapper] cudnnConvolutionBackwardFilter() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      cudnnTensorDescriptor_t dyDesc;
      const void * dy;
      cudnnConvolutionDescriptor_t convDesc;
      cudnnConvolutionBwdFilterAlgo_t algo;
      void * workSpace;
      size_t workSpaceSizeInBytes;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnFilterDescriptor_t dwDesc;
      void * dw;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnConvolutionBackwardFilter );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.dy = dy;
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.algo = algo;
  t2d_msg->data.workSpace = workSpace;
  t2d_msg->data.workSpaceSizeInBytes = workSpaceSizeInBytes;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.dwDesc = dwDesc;
  t2d_msg->data.dw = dw;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnConvolutionBackwardFilter() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnConvolutionForward ( cudnnHandle_t handle, const void * alpha, cudnnTensorDescriptor_t xDesc, const void * x, cudnnFilterDescriptor_t wDesc, const void * w, cudnnConvolutionDescriptor_t convDesc, cudnnConvolutionFwdAlgo_t algo, void * workSpace, size_t workSpaceSizeInBytes, const void * beta, cudnnTensorDescriptor_t yDesc, void * y )
{
  hfinf( "[trapper] cudnnConvolutionForward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      cudnnFilterDescriptor_t wDesc;
      const void * w;
      cudnnConvolutionDescriptor_t convDesc;
      cudnnConvolutionFwdAlgo_t algo;
      void * workSpace;
      size_t workSpaceSizeInBytes;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t yDesc;
      void * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnConvolutionForward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.w = w;
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.algo = algo;
  t2d_msg->data.workSpace = workSpace;
  t2d_msg->data.workSpaceSizeInBytes = workSpaceSizeInBytes;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnConvolutionForward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnCreate ( cudnnHandle_t * handle )
{
  hfinf( "[trapper] cudnnCreate() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnCreate );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnHandle_t handle;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( handle ) *handle = d2t_msg.handle;
  hfinf( "[trapper] cudnnCreate() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnCreateActivationDescriptor ( cudnnActivationDescriptor_t * activationDesc )
{
  hfinf( "[trapper] cudnnCreateActivationDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnCreateActivationDescriptor );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnActivationDescriptor_t activationDesc;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( activationDesc ) *activationDesc = d2t_msg.activationDesc;
  hfinf( "[trapper] cudnnCreateActivationDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnCreateConvolutionDescriptor ( cudnnConvolutionDescriptor_t * convDesc )
{
  hfinf( "[trapper] cudnnCreateConvolutionDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnCreateConvolutionDescriptor );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnConvolutionDescriptor_t convDesc;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( convDesc ) *convDesc = d2t_msg.convDesc;
  hfinf( "[trapper] cudnnCreateConvolutionDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnCreateDropoutDescriptor ( cudnnDropoutDescriptor_t * dropoutDesc )
{
  hfinf( "[trapper] cudnnCreateDropoutDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnCreateDropoutDescriptor );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnDropoutDescriptor_t dropoutDesc;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( dropoutDesc ) *dropoutDesc = d2t_msg.dropoutDesc;
  hfinf( "[trapper] cudnnCreateDropoutDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnCreateFilterDescriptor ( cudnnFilterDescriptor_t * filterDesc )
{
  hfinf( "[trapper] cudnnCreateFilterDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnCreateFilterDescriptor );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnFilterDescriptor_t filterDesc;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( filterDesc ) *filterDesc = d2t_msg.filterDesc;
  hfinf( "[trapper] cudnnCreateFilterDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnCreateLRNDescriptor ( cudnnLRNDescriptor_t * normDesc )
{
  hfinf( "[trapper] cudnnCreateLRNDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnCreateLRNDescriptor );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnLRNDescriptor_t normDesc;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( normDesc ) *normDesc = d2t_msg.normDesc;
  hfinf( "[trapper] cudnnCreateLRNDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnCreateOpTensorDescriptor ( cudnnOpTensorDescriptor_t * opTensorDesc )
{
  hfinf( "[trapper] cudnnCreateOpTensorDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnCreateOpTensorDescriptor );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnOpTensorDescriptor_t opTensorDesc;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( opTensorDesc ) *opTensorDesc = d2t_msg.opTensorDesc;
  hfinf( "[trapper] cudnnCreateOpTensorDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnCreatePoolingDescriptor ( cudnnPoolingDescriptor_t * poolingDesc )
{
  hfinf( "[trapper] cudnnCreatePoolingDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnCreatePoolingDescriptor );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnPoolingDescriptor_t poolingDesc;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( poolingDesc ) *poolingDesc = d2t_msg.poolingDesc;
  hfinf( "[trapper] cudnnCreatePoolingDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnCreateRNNDescriptor ( cudnnRNNDescriptor_t * rnnDesc )
{
  hfinf( "[trapper] cudnnCreateRNNDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnCreateRNNDescriptor );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnRNNDescriptor_t rnnDesc;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( rnnDesc ) *rnnDesc = d2t_msg.rnnDesc;
  hfinf( "[trapper] cudnnCreateRNNDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnCreateSpatialTransformerDescriptor ( cudnnSpatialTransformerDescriptor_t * stDesc )
{
  hfinf( "[trapper] cudnnCreateSpatialTransformerDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnCreateSpatialTransformerDescriptor );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnSpatialTransformerDescriptor_t stDesc;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( stDesc ) *stDesc = d2t_msg.stDesc;
  hfinf( "[trapper] cudnnCreateSpatialTransformerDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnCreateTensorDescriptor ( cudnnTensorDescriptor_t * tensorDesc )
{
  hfinf( "[trapper] cudnnCreateTensorDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnCreateTensorDescriptor );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnTensorDescriptor_t tensorDesc;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( tensorDesc ) *tensorDesc = d2t_msg.tensorDesc;
  hfinf( "[trapper] cudnnCreateTensorDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDeriveBNTensorDescriptor ( cudnnTensorDescriptor_t derivedBnDesc, cudnnTensorDescriptor_t xDesc, cudnnBatchNormMode_t mode )
{
  hfinf( "[trapper] cudnnDeriveBNTensorDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnTensorDescriptor_t derivedBnDesc;
      cudnnTensorDescriptor_t xDesc;
      cudnnBatchNormMode_t mode;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDeriveBNTensorDescriptor );
  t2d_msg->data.derivedBnDesc = derivedBnDesc;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.mode = mode;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDeriveBNTensorDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDestroy ( cudnnHandle_t handle )
{
  hfinf( "[trapper] cudnnDestroy() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDestroy );
  t2d_msg->data.handle = handle;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDestroy() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDestroyActivationDescriptor ( cudnnActivationDescriptor_t activationDesc )
{
  hfinf( "[trapper] cudnnDestroyActivationDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnActivationDescriptor_t activationDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDestroyActivationDescriptor );
  t2d_msg->data.activationDesc = activationDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDestroyActivationDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDestroyConvolutionDescriptor ( cudnnConvolutionDescriptor_t convDesc )
{
  hfinf( "[trapper] cudnnDestroyConvolutionDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnConvolutionDescriptor_t convDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDestroyConvolutionDescriptor );
  t2d_msg->data.convDesc = convDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDestroyConvolutionDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDestroyDropoutDescriptor ( cudnnDropoutDescriptor_t dropoutDesc )
{
  hfinf( "[trapper] cudnnDestroyDropoutDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnDropoutDescriptor_t dropoutDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDestroyDropoutDescriptor );
  t2d_msg->data.dropoutDesc = dropoutDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDestroyDropoutDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDestroyFilterDescriptor ( cudnnFilterDescriptor_t filterDesc )
{
  hfinf( "[trapper] cudnnDestroyFilterDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnFilterDescriptor_t filterDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDestroyFilterDescriptor );
  t2d_msg->data.filterDesc = filterDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDestroyFilterDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDestroyLRNDescriptor ( cudnnLRNDescriptor_t lrnDesc )
{
  hfinf( "[trapper] cudnnDestroyLRNDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnLRNDescriptor_t lrnDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDestroyLRNDescriptor );
  t2d_msg->data.lrnDesc = lrnDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDestroyLRNDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDestroyOpTensorDescriptor ( cudnnOpTensorDescriptor_t opTensorDesc )
{
  hfinf( "[trapper] cudnnDestroyOpTensorDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnOpTensorDescriptor_t opTensorDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDestroyOpTensorDescriptor );
  t2d_msg->data.opTensorDesc = opTensorDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDestroyOpTensorDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDestroyPoolingDescriptor ( cudnnPoolingDescriptor_t poolingDesc )
{
  hfinf( "[trapper] cudnnDestroyPoolingDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnPoolingDescriptor_t poolingDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDestroyPoolingDescriptor );
  t2d_msg->data.poolingDesc = poolingDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDestroyPoolingDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDestroyRNNDescriptor ( cudnnRNNDescriptor_t rnnDesc )
{
  hfinf( "[trapper] cudnnDestroyRNNDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnRNNDescriptor_t rnnDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDestroyRNNDescriptor );
  t2d_msg->data.rnnDesc = rnnDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDestroyRNNDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDestroySpatialTransformerDescriptor ( cudnnSpatialTransformerDescriptor_t stDesc )
{
  hfinf( "[trapper] cudnnDestroySpatialTransformerDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnSpatialTransformerDescriptor_t stDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDestroySpatialTransformerDescriptor );
  t2d_msg->data.stDesc = stDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDestroySpatialTransformerDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDestroyTensorDescriptor ( cudnnTensorDescriptor_t tensorDesc )
{
  hfinf( "[trapper] cudnnDestroyTensorDescriptor() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnTensorDescriptor_t tensorDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDestroyTensorDescriptor );
  t2d_msg->data.tensorDesc = tensorDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDestroyTensorDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  if( d2t_msg.____RETVAL == CUDNN_STATUS_SUCCESS ) {
    hfcheck(hfcuda_del_cudnnDataType( devId, tensorDesc ));
  }
  
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDivisiveNormalizationBackward ( cudnnHandle_t handle, cudnnLRNDescriptor_t normDesc, cudnnDivNormMode_t mode, const void * alpha, cudnnTensorDescriptor_t xDesc, const void * x, const void * means, const void * dy, void * temp, void * temp2, const void * beta, cudnnTensorDescriptor_t dXdMeansDesc, void * dx, void * dMeans )
{
  hfinf( "[trapper] cudnnDivisiveNormalizationBackward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnLRNDescriptor_t normDesc;
      cudnnDivNormMode_t mode;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      const void * means;
      const void * dy;
      void * temp;
      void * temp2;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t dXdMeansDesc;
      void * dx;
      void * dMeans;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDivisiveNormalizationBackward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.normDesc = normDesc;
  t2d_msg->data.mode = mode;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.means = means;
  t2d_msg->data.dy = dy;
  t2d_msg->data.temp = temp;
  t2d_msg->data.temp2 = temp2;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.dXdMeansDesc = dXdMeansDesc;
  t2d_msg->data.dx = dx;
  t2d_msg->data.dMeans = dMeans;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDivisiveNormalizationBackward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDivisiveNormalizationForward ( cudnnHandle_t handle, cudnnLRNDescriptor_t normDesc, cudnnDivNormMode_t mode, const void * alpha, cudnnTensorDescriptor_t xDesc, const void * x, const void * means, void * temp, void * temp2, const void * beta, cudnnTensorDescriptor_t yDesc, void * y )
{
  hfinf( "[trapper] cudnnDivisiveNormalizationForward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnLRNDescriptor_t normDesc;
      cudnnDivNormMode_t mode;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      const void * means;
      void * temp;
      void * temp2;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t yDesc;
      void * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDivisiveNormalizationForward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.normDesc = normDesc;
  t2d_msg->data.mode = mode;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.means = means;
  t2d_msg->data.temp = temp;
  t2d_msg->data.temp2 = temp2;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDivisiveNormalizationForward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDropoutBackward ( cudnnHandle_t handle, cudnnDropoutDescriptor_t dropoutDesc, cudnnTensorDescriptor_t dydesc, const void * dy, cudnnTensorDescriptor_t dxdesc, void * dx, void * reserveSpace, size_t reserveSpaceSizeInBytes )
{
  hfinf( "[trapper] cudnnDropoutBackward() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnDropoutDescriptor_t dropoutDesc;
      cudnnTensorDescriptor_t dydesc;
      const void * dy;
      cudnnTensorDescriptor_t dxdesc;
      void * dx;
      void * reserveSpace;
      size_t reserveSpaceSizeInBytes;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDropoutBackward );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dropoutDesc = dropoutDesc;
  t2d_msg->data.dydesc = dydesc;
  t2d_msg->data.dy = dy;
  t2d_msg->data.dxdesc = dxdesc;
  t2d_msg->data.dx = dx;
  t2d_msg->data.reserveSpace = reserveSpace;
  t2d_msg->data.reserveSpaceSizeInBytes = reserveSpaceSizeInBytes;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDropoutBackward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDropoutForward ( cudnnHandle_t handle, cudnnDropoutDescriptor_t dropoutDesc, cudnnTensorDescriptor_t xdesc, const void * x, cudnnTensorDescriptor_t ydesc, void * y, void * reserveSpace, size_t reserveSpaceSizeInBytes )
{
  hfinf( "[trapper] cudnnDropoutForward() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnDropoutDescriptor_t dropoutDesc;
      cudnnTensorDescriptor_t xdesc;
      const void * x;
      cudnnTensorDescriptor_t ydesc;
      void * y;
      void * reserveSpace;
      size_t reserveSpaceSizeInBytes;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDropoutForward );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dropoutDesc = dropoutDesc;
  t2d_msg->data.xdesc = xdesc;
  t2d_msg->data.x = x;
  t2d_msg->data.ydesc = ydesc;
  t2d_msg->data.y = y;
  t2d_msg->data.reserveSpace = reserveSpace;
  t2d_msg->data.reserveSpaceSizeInBytes = reserveSpaceSizeInBytes;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnDropoutForward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDropoutGetReserveSpaceSize ( cudnnTensorDescriptor_t xdesc, size_t * sizeInBytes )
{
  hfinf( "[trapper] cudnnDropoutGetReserveSpaceSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnTensorDescriptor_t xdesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDropoutGetReserveSpaceSize );
  t2d_msg->data.xdesc = xdesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    size_t sizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( sizeInBytes ) *sizeInBytes = d2t_msg.sizeInBytes;
  hfinf( "[trapper] cudnnDropoutGetReserveSpaceSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnDropoutGetStatesSize ( cudnnHandle_t handle, size_t * sizeInBytes )
{
  hfinf( "[trapper] cudnnDropoutGetStatesSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnDropoutGetStatesSize );
  t2d_msg->data.handle = handle;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    size_t sizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( sizeInBytes ) *sizeInBytes = d2t_msg.sizeInBytes;
  hfinf( "[trapper] cudnnDropoutGetStatesSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetActivationDescriptor ( cudnnActivationDescriptor_t activationDesc, cudnnActivationMode_t * mode, cudnnNanPropagation_t * reluNanOpt, double * reluCeiling )
{
  hfinf( "[trapper] cudnnGetActivationDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnActivationDescriptor_t activationDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetActivationDescriptor );
  t2d_msg->data.activationDesc = activationDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnActivationMode_t mode;
    cudnnNanPropagation_t reluNanOpt;
    double reluCeiling;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( mode ) *mode = d2t_msg.mode;
  if( reluNanOpt ) *reluNanOpt = d2t_msg.reluNanOpt;
  if( reluCeiling ) *reluCeiling = d2t_msg.reluCeiling;
  hfinf( "[trapper] cudnnGetActivationDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetConvolution2dDescriptor ( cudnnConvolutionDescriptor_t convDesc, int * pad_h, int * pad_w, int * u, int * v, int * upscalex, int * upscaley, cudnnConvolutionMode_t * mode )
{
  hfinf( "[trapper] cudnnGetConvolution2dDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnConvolutionDescriptor_t convDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetConvolution2dDescriptor );
  t2d_msg->data.convDesc = convDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    int pad_h;
    int pad_w;
    int u;
    int v;
    int upscalex;
    int upscaley;
    cudnnConvolutionMode_t mode;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pad_h ) *pad_h = d2t_msg.pad_h;
  if( pad_w ) *pad_w = d2t_msg.pad_w;
  if( u ) *u = d2t_msg.u;
  if( v ) *v = d2t_msg.v;
  if( upscalex ) *upscalex = d2t_msg.upscalex;
  if( upscaley ) *upscaley = d2t_msg.upscaley;
  if( mode ) *mode = d2t_msg.mode;
  hfinf( "[trapper] cudnnGetConvolution2dDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetConvolution2dForwardOutputDim ( cudnnConvolutionDescriptor_t convDesc, cudnnTensorDescriptor_t inputTensorDesc, cudnnFilterDescriptor_t filterDesc, int * n, int * c, int * h, int * w )
{
  hfinf( "[trapper] cudnnGetConvolution2dForwardOutputDim() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnConvolutionDescriptor_t convDesc;
      cudnnTensorDescriptor_t inputTensorDesc;
      cudnnFilterDescriptor_t filterDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetConvolution2dForwardOutputDim );
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.inputTensorDesc = inputTensorDesc;
  t2d_msg->data.filterDesc = filterDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    int n;
    int c;
    int h;
    int w;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( n ) *n = d2t_msg.n;
  if( c ) *c = d2t_msg.c;
  if( h ) *h = d2t_msg.h;
  if( w ) *w = d2t_msg.w;
  hfinf( "[trapper] cudnnGetConvolution2dForwardOutputDim() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetConvolutionBackwardDataAlgorithm ( cudnnHandle_t handle, cudnnFilterDescriptor_t wDesc, cudnnTensorDescriptor_t dyDesc, cudnnConvolutionDescriptor_t convDesc, cudnnTensorDescriptor_t dxDesc, cudnnConvolutionBwdDataPreference_t preference, size_t memoryLimitInBytes, cudnnConvolutionBwdDataAlgo_t * algo )
{
  hfinf( "[trapper] cudnnGetConvolutionBackwardDataAlgorithm() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnFilterDescriptor_t wDesc;
      cudnnTensorDescriptor_t dyDesc;
      cudnnConvolutionDescriptor_t convDesc;
      cudnnTensorDescriptor_t dxDesc;
      cudnnConvolutionBwdDataPreference_t preference;
      size_t memoryLimitInBytes;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetConvolutionBackwardDataAlgorithm );
  t2d_msg->data.handle = handle;
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.dxDesc = dxDesc;
  t2d_msg->data.preference = preference;
  t2d_msg->data.memoryLimitInBytes = memoryLimitInBytes;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnConvolutionBwdDataAlgo_t algo;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( algo ) *algo = d2t_msg.algo;
  hfinf( "[trapper] cudnnGetConvolutionBackwardDataAlgorithm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetConvolutionBackwardDataWorkspaceSize ( cudnnHandle_t handle, cudnnFilterDescriptor_t wDesc, cudnnTensorDescriptor_t dyDesc, cudnnConvolutionDescriptor_t convDesc, cudnnTensorDescriptor_t dxDesc, cudnnConvolutionBwdDataAlgo_t algo, size_t * sizeInBytes )
{
  hfinf( "[trapper] cudnnGetConvolutionBackwardDataWorkspaceSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnFilterDescriptor_t wDesc;
      cudnnTensorDescriptor_t dyDesc;
      cudnnConvolutionDescriptor_t convDesc;
      cudnnTensorDescriptor_t dxDesc;
      cudnnConvolutionBwdDataAlgo_t algo;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetConvolutionBackwardDataWorkspaceSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.dxDesc = dxDesc;
  t2d_msg->data.algo = algo;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    size_t sizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( sizeInBytes ) *sizeInBytes = d2t_msg.sizeInBytes;
  hfinf( "[trapper] cudnnGetConvolutionBackwardDataWorkspaceSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetConvolutionBackwardFilterAlgorithm ( cudnnHandle_t handle, cudnnTensorDescriptor_t xDesc, cudnnTensorDescriptor_t dyDesc, cudnnConvolutionDescriptor_t convDesc, cudnnFilterDescriptor_t dwDesc, cudnnConvolutionBwdFilterPreference_t preference, size_t memoryLimitInBytes, cudnnConvolutionBwdFilterAlgo_t * algo )
{
  hfinf( "[trapper] cudnnGetConvolutionBackwardFilterAlgorithm() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnTensorDescriptor_t xDesc;
      cudnnTensorDescriptor_t dyDesc;
      cudnnConvolutionDescriptor_t convDesc;
      cudnnFilterDescriptor_t dwDesc;
      cudnnConvolutionBwdFilterPreference_t preference;
      size_t memoryLimitInBytes;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetConvolutionBackwardFilterAlgorithm );
  t2d_msg->data.handle = handle;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.dwDesc = dwDesc;
  t2d_msg->data.preference = preference;
  t2d_msg->data.memoryLimitInBytes = memoryLimitInBytes;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnConvolutionBwdFilterAlgo_t algo;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( algo ) *algo = d2t_msg.algo;
  hfinf( "[trapper] cudnnGetConvolutionBackwardFilterAlgorithm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetConvolutionBackwardFilterWorkspaceSize ( cudnnHandle_t handle, cudnnTensorDescriptor_t xDesc, cudnnTensorDescriptor_t dyDesc, cudnnConvolutionDescriptor_t convDesc, cudnnFilterDescriptor_t gradDesc, cudnnConvolutionBwdFilterAlgo_t algo, size_t * sizeInBytes )
{
  hfinf( "[trapper] cudnnGetConvolutionBackwardFilterWorkspaceSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnTensorDescriptor_t xDesc;
      cudnnTensorDescriptor_t dyDesc;
      cudnnConvolutionDescriptor_t convDesc;
      cudnnFilterDescriptor_t gradDesc;
      cudnnConvolutionBwdFilterAlgo_t algo;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetConvolutionBackwardFilterWorkspaceSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.gradDesc = gradDesc;
  t2d_msg->data.algo = algo;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    size_t sizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( sizeInBytes ) *sizeInBytes = d2t_msg.sizeInBytes;
  hfinf( "[trapper] cudnnGetConvolutionBackwardFilterWorkspaceSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetConvolutionForwardAlgorithm ( cudnnHandle_t handle, cudnnTensorDescriptor_t xDesc, cudnnFilterDescriptor_t wDesc, cudnnConvolutionDescriptor_t convDesc, cudnnTensorDescriptor_t yDesc, cudnnConvolutionFwdPreference_t preference, size_t memoryLimitInBytes, cudnnConvolutionFwdAlgo_t * algo )
{
  hfinf( "[trapper] cudnnGetConvolutionForwardAlgorithm() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnTensorDescriptor_t xDesc;
      cudnnFilterDescriptor_t wDesc;
      cudnnConvolutionDescriptor_t convDesc;
      cudnnTensorDescriptor_t yDesc;
      cudnnConvolutionFwdPreference_t preference;
      size_t memoryLimitInBytes;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetConvolutionForwardAlgorithm );
  t2d_msg->data.handle = handle;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.preference = preference;
  t2d_msg->data.memoryLimitInBytes = memoryLimitInBytes;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnConvolutionFwdAlgo_t algo;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( algo ) *algo = d2t_msg.algo;
  hfinf( "[trapper] cudnnGetConvolutionForwardAlgorithm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetConvolutionForwardWorkspaceSize ( cudnnHandle_t handle, cudnnTensorDescriptor_t xDesc, cudnnFilterDescriptor_t wDesc, cudnnConvolutionDescriptor_t convDesc, cudnnTensorDescriptor_t yDesc, cudnnConvolutionFwdAlgo_t algo, size_t * sizeInBytes )
{
  hfinf( "[trapper] cudnnGetConvolutionForwardWorkspaceSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnTensorDescriptor_t xDesc;
      cudnnFilterDescriptor_t wDesc;
      cudnnConvolutionDescriptor_t convDesc;
      cudnnTensorDescriptor_t yDesc;
      cudnnConvolutionFwdAlgo_t algo;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetConvolutionForwardWorkspaceSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.algo = algo;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    size_t sizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( sizeInBytes ) *sizeInBytes = d2t_msg.sizeInBytes;
  hfinf( "[trapper] cudnnGetConvolutionForwardWorkspaceSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetFilter4dDescriptor ( cudnnFilterDescriptor_t filterDesc, cudnnDataType_t * dataType, cudnnTensorFormat_t * format, int * k, int * c, int * h, int * w )
{
  hfinf( "[trapper] cudnnGetFilter4dDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnFilterDescriptor_t filterDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetFilter4dDescriptor );
  t2d_msg->data.filterDesc = filterDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnDataType_t dataType;
    cudnnTensorFormat_t format;
    int k;
    int c;
    int h;
    int w;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( dataType ) *dataType = d2t_msg.dataType;
  if( format ) *format = d2t_msg.format;
  if( k ) *k = d2t_msg.k;
  if( c ) *c = d2t_msg.c;
  if( h ) *h = d2t_msg.h;
  if( w ) *w = d2t_msg.w;
  hfinf( "[trapper] cudnnGetFilter4dDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetLRNDescriptor ( cudnnLRNDescriptor_t normDesc, unsigned int * lrnN, double * lrnAlpha, double * lrnBeta, double * lrnK )
{
  hfinf( "[trapper] cudnnGetLRNDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnLRNDescriptor_t normDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetLRNDescriptor );
  t2d_msg->data.normDesc = normDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    unsigned int lrnN;
    double lrnAlpha;
    double lrnBeta;
    double lrnK;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( lrnN ) *lrnN = d2t_msg.lrnN;
  if( lrnAlpha ) *lrnAlpha = d2t_msg.lrnAlpha;
  if( lrnBeta ) *lrnBeta = d2t_msg.lrnBeta;
  if( lrnK ) *lrnK = d2t_msg.lrnK;
  hfinf( "[trapper] cudnnGetLRNDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetOpTensorDescriptor ( cudnnOpTensorDescriptor_t opTensorDesc, cudnnOpTensorOp_t * opTensorOp, cudnnDataType_t * opTensorCompType, cudnnNanPropagation_t * opTensorNanOpt )
{
  hfinf( "[trapper] cudnnGetOpTensorDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnOpTensorDescriptor_t opTensorDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetOpTensorDescriptor );
  t2d_msg->data.opTensorDesc = opTensorDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnOpTensorOp_t opTensorOp;
    cudnnDataType_t opTensorCompType;
    cudnnNanPropagation_t opTensorNanOpt;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( opTensorOp ) *opTensorOp = d2t_msg.opTensorOp;
  if( opTensorCompType ) *opTensorCompType = d2t_msg.opTensorCompType;
  if( opTensorNanOpt ) *opTensorNanOpt = d2t_msg.opTensorNanOpt;
  hfinf( "[trapper] cudnnGetOpTensorDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetPooling2dDescriptor ( cudnnPoolingDescriptor_t poolingDesc, cudnnPoolingMode_t * mode, cudnnNanPropagation_t * maxpoolingNanOpt, int * windowHeight, int * windowWidth, int * verticalPadding, int * horizontalPadding, int * verticalStride, int * horizontalStride )
{
  hfinf( "[trapper] cudnnGetPooling2dDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnPoolingDescriptor_t poolingDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetPooling2dDescriptor );
  t2d_msg->data.poolingDesc = poolingDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnPoolingMode_t mode;
    cudnnNanPropagation_t maxpoolingNanOpt;
    int windowHeight;
    int windowWidth;
    int verticalPadding;
    int horizontalPadding;
    int verticalStride;
    int horizontalStride;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( mode ) *mode = d2t_msg.mode;
  if( maxpoolingNanOpt ) *maxpoolingNanOpt = d2t_msg.maxpoolingNanOpt;
  if( windowHeight ) *windowHeight = d2t_msg.windowHeight;
  if( windowWidth ) *windowWidth = d2t_msg.windowWidth;
  if( verticalPadding ) *verticalPadding = d2t_msg.verticalPadding;
  if( horizontalPadding ) *horizontalPadding = d2t_msg.horizontalPadding;
  if( verticalStride ) *verticalStride = d2t_msg.verticalStride;
  if( horizontalStride ) *horizontalStride = d2t_msg.horizontalStride;
  hfinf( "[trapper] cudnnGetPooling2dDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetPooling2dForwardOutputDim ( cudnnPoolingDescriptor_t poolingDesc, cudnnTensorDescriptor_t inputTensorDesc, int * n, int * c, int * h, int * w )
{
  hfinf( "[trapper] cudnnGetPooling2dForwardOutputDim() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnPoolingDescriptor_t poolingDesc;
      cudnnTensorDescriptor_t inputTensorDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetPooling2dForwardOutputDim );
  t2d_msg->data.poolingDesc = poolingDesc;
  t2d_msg->data.inputTensorDesc = inputTensorDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    int n;
    int c;
    int h;
    int w;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( n ) *n = d2t_msg.n;
  if( c ) *c = d2t_msg.c;
  if( h ) *h = d2t_msg.h;
  if( w ) *w = d2t_msg.w;
  hfinf( "[trapper] cudnnGetPooling2dForwardOutputDim() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetRNNLinLayerBiasParams ( cudnnHandle_t handle, cudnnRNNDescriptor_t rnnDesc, const int layer, cudnnTensorDescriptor_t xDesc, cudnnFilterDescriptor_t wDesc, const void * w, const int linLayerID, cudnnFilterDescriptor_t linLayerBiasDesc, void ** linLayerBias )
{
  hfinf( "[trapper] cudnnGetRNNLinLayerBiasParams() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnRNNDescriptor_t rnnDesc;
      int layer;
      cudnnTensorDescriptor_t xDesc;
      cudnnFilterDescriptor_t wDesc;
      const void * w;
      int linLayerID;
      cudnnFilterDescriptor_t linLayerBiasDesc;
      void ** linLayerBias;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetRNNLinLayerBiasParams );
  t2d_msg->data.handle = handle;
  t2d_msg->data.rnnDesc = rnnDesc;
  t2d_msg->data.layer = layer;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.w = w;
  t2d_msg->data.linLayerID = linLayerID;
  t2d_msg->data.linLayerBiasDesc = linLayerBiasDesc;
  t2d_msg->data.linLayerBias = linLayerBias;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnGetRNNLinLayerBiasParams() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetRNNLinLayerMatrixParams ( cudnnHandle_t handle, cudnnRNNDescriptor_t rnnDesc, const int layer, cudnnTensorDescriptor_t xDesc, cudnnFilterDescriptor_t wDesc, const void * w, const int linLayerID, cudnnFilterDescriptor_t linLayerMatDesc, void ** linLayerMat )
{
  hfinf( "[trapper] cudnnGetRNNLinLayerMatrixParams() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnRNNDescriptor_t rnnDesc;
      int layer;
      cudnnTensorDescriptor_t xDesc;
      cudnnFilterDescriptor_t wDesc;
      const void * w;
      int linLayerID;
      cudnnFilterDescriptor_t linLayerMatDesc;
      void ** linLayerMat;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetRNNLinLayerMatrixParams );
  t2d_msg->data.handle = handle;
  t2d_msg->data.rnnDesc = rnnDesc;
  t2d_msg->data.layer = layer;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.w = w;
  t2d_msg->data.linLayerID = linLayerID;
  t2d_msg->data.linLayerMatDesc = linLayerMatDesc;
  t2d_msg->data.linLayerMat = linLayerMat;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnGetRNNLinLayerMatrixParams() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetRNNParamsSize ( cudnnHandle_t handle, cudnnRNNDescriptor_t rnnDesc, cudnnTensorDescriptor_t xDesc, size_t * sizeInBytes, cudnnDataType_t dataType )
{
  hfinf( "[trapper] cudnnGetRNNParamsSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnRNNDescriptor_t rnnDesc;
      cudnnTensorDescriptor_t xDesc;
      cudnnDataType_t dataType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetRNNParamsSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.rnnDesc = rnnDesc;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.dataType = dataType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    size_t sizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( sizeInBytes ) *sizeInBytes = d2t_msg.sizeInBytes;
  hfinf( "[trapper] cudnnGetRNNParamsSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetStream ( cudnnHandle_t handle, cudaStream_t * streamId )
{
  hfinf( "[trapper] cudnnGetStream() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetStream );
  t2d_msg->data.handle = handle;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudaStream_t streamId;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( streamId ) *streamId = d2t_msg.streamId;
  hfinf( "[trapper] cudnnGetStream() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnGetTensor4dDescriptor ( cudnnTensorDescriptor_t tensorDesc, cudnnDataType_t * dataType, int * n, int * c, int * h, int * w, int * nStride, int * cStride, int * hStride, int * wStride )
{
  hfinf( "[trapper] cudnnGetTensor4dDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnTensorDescriptor_t tensorDesc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetTensor4dDescriptor );
  t2d_msg->data.tensorDesc = tensorDesc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
    cudnnDataType_t dataType;
    int n;
    int c;
    int h;
    int w;
    int nStride;
    int cStride;
    int hStride;
    int wStride;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( dataType ) *dataType = d2t_msg.dataType;
  if( n ) *n = d2t_msg.n;
  if( c ) *c = d2t_msg.c;
  if( h ) *h = d2t_msg.h;
  if( w ) *w = d2t_msg.w;
  if( nStride ) *nStride = d2t_msg.nStride;
  if( cStride ) *cStride = d2t_msg.cStride;
  if( hStride ) *hStride = d2t_msg.hStride;
  if( wStride ) *wStride = d2t_msg.wStride;
  hfinf( "[trapper] cudnnGetTensor4dDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
size_t
cudnnGetVersion ( void )
{
  hfinf( "[trapper] cudnnGetVersion() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnGetVersion );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    size_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnGetVersion() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnIm2Col ( cudnnHandle_t handle, cudnnTensorDescriptor_t xDesc, const void * x, cudnnFilterDescriptor_t wDesc, cudnnConvolutionDescriptor_t convDesc, void * colBuffer )
{
  hfinf( "[trapper] cudnnIm2Col() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      cudnnFilterDescriptor_t wDesc;
      cudnnConvolutionDescriptor_t convDesc;
      void * colBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnIm2Col );
  t2d_msg->data.handle = handle;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.colBuffer = colBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnIm2Col() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnLRNCrossChannelBackward ( cudnnHandle_t handle, cudnnLRNDescriptor_t normDesc, cudnnLRNMode_t lrnMode, const void * alpha, cudnnTensorDescriptor_t yDesc, const void * y, cudnnTensorDescriptor_t dyDesc, const void * dy, cudnnTensorDescriptor_t xDesc, const void * x, const void * beta, cudnnTensorDescriptor_t dxDesc, void * dx )
{
  hfinf( "[trapper] cudnnLRNCrossChannelBackward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnLRNDescriptor_t normDesc;
      cudnnLRNMode_t lrnMode;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t yDesc;
      const void * y;
      cudnnTensorDescriptor_t dyDesc;
      const void * dy;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t dxDesc;
      void * dx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnLRNCrossChannelBackward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.normDesc = normDesc;
  t2d_msg->data.lrnMode = lrnMode;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____yDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, yDesc, &____yDesc_dataType ));
    switch( ____yDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____yDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.dy = dy;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____yDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, yDesc, &____yDesc_dataType ));
    switch( ____yDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____yDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.dxDesc = dxDesc;
  t2d_msg->data.dx = dx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnLRNCrossChannelBackward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnLRNCrossChannelForward ( cudnnHandle_t handle, cudnnLRNDescriptor_t normDesc, cudnnLRNMode_t lrnMode, const void * alpha, cudnnTensorDescriptor_t xDesc, const void * x, const void * beta, cudnnTensorDescriptor_t yDesc, void * y )
{
  hfinf( "[trapper] cudnnLRNCrossChannelForward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnLRNDescriptor_t normDesc;
      cudnnLRNMode_t lrnMode;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t yDesc;
      void * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnLRNCrossChannelForward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.normDesc = normDesc;
  t2d_msg->data.lrnMode = lrnMode;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnLRNCrossChannelForward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnOpTensor ( cudnnHandle_t handle, cudnnOpTensorDescriptor_t opTensorDesc, const void * alpha1, cudnnTensorDescriptor_t aDesc, const void * A, const void * alpha2, cudnnTensorDescriptor_t bDesc, const void * B, const void * beta, cudnnTensorDescriptor_t cDesc, void * C )
{
  hfinf( "[trapper] cudnnOpTensor() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnOpTensorDescriptor_t opTensorDesc;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha1;
      cudnnTensorDescriptor_t aDesc;
      const void * A;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha2;
      cudnnTensorDescriptor_t bDesc;
      const void * B;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t cDesc;
      void * C;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnOpTensor );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.opTensorDesc = opTensorDesc;
  if( alpha1 ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____aDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, aDesc, &____aDesc_dataType ));
    switch( ____aDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha1.val = *(float*)alpha1;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha1.val = *(double*)alpha1;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____aDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha1.ptr = NULL;
  }
  t2d_msg->data.aDesc = aDesc;
  t2d_msg->data.A = A;
  if( alpha2 ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____aDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, aDesc, &____aDesc_dataType ));
    switch( ____aDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha2.val = *(float*)alpha2;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha2.val = *(double*)alpha2;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____aDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha2.ptr = NULL;
  }
  t2d_msg->data.bDesc = bDesc;
  t2d_msg->data.B = B;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 2);
    cudnnDataType_t ____aDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, aDesc, &____aDesc_dataType ));
    switch( ____aDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____aDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.cDesc = cDesc;
  t2d_msg->data.C = C;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnOpTensor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnPoolingBackward ( cudnnHandle_t handle, cudnnPoolingDescriptor_t poolingDesc, const void * alpha, cudnnTensorDescriptor_t yDesc, const void * y, cudnnTensorDescriptor_t dyDesc, const void * dy, cudnnTensorDescriptor_t xDesc, const void * x, const void * beta, cudnnTensorDescriptor_t dxDesc, void * dx )
{
  hfinf( "[trapper] cudnnPoolingBackward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnPoolingDescriptor_t poolingDesc;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t yDesc;
      const void * y;
      cudnnTensorDescriptor_t dyDesc;
      const void * dy;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t dxDesc;
      void * dx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnPoolingBackward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.poolingDesc = poolingDesc;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____yDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, yDesc, &____yDesc_dataType ));
    switch( ____yDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____yDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.dy = dy;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____yDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, yDesc, &____yDesc_dataType ));
    switch( ____yDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____yDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.dxDesc = dxDesc;
  t2d_msg->data.dx = dx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnPoolingBackward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnPoolingForward ( cudnnHandle_t handle, cudnnPoolingDescriptor_t poolingDesc, const void * alpha, cudnnTensorDescriptor_t xDesc, const void * x, const void * beta, cudnnTensorDescriptor_t yDesc, void * y )
{
  hfinf( "[trapper] cudnnPoolingForward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnPoolingDescriptor_t poolingDesc;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t yDesc;
      void * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnPoolingForward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.poolingDesc = poolingDesc;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnPoolingForward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnRNNBackwardData ( cudnnHandle_t handle, cudnnRNNDescriptor_t rnnDesc, const int seqLength, const cudnnTensorDescriptor_t * yDesc, const void * y, const cudnnTensorDescriptor_t * dyDesc, const void * dy, cudnnTensorDescriptor_t dhyDesc, const void * dhy, cudnnTensorDescriptor_t dcyDesc, const void * dcy, cudnnFilterDescriptor_t wDesc, const void * w, cudnnTensorDescriptor_t hxDesc, const void * hx, cudnnTensorDescriptor_t cxDesc, const void * cx, const cudnnTensorDescriptor_t * dxDesc, void * dx, cudnnTensorDescriptor_t dhxDesc, void * dhx, cudnnTensorDescriptor_t dcxDesc, void * dcx, void * workspace, size_t workSpaceSizeInBytes, const void * reserveSpace, size_t reserveSpaceSizeInBytes )
{
  hfinf( "[trapper] cudnnRNNBackwardData() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnRNNDescriptor_t rnnDesc;
      int seqLength;
      const cudnnTensorDescriptor_t * yDesc;
      const void * y;
      const cudnnTensorDescriptor_t * dyDesc;
      const void * dy;
      cudnnTensorDescriptor_t dhyDesc;
      const void * dhy;
      cudnnTensorDescriptor_t dcyDesc;
      const void * dcy;
      cudnnFilterDescriptor_t wDesc;
      const void * w;
      cudnnTensorDescriptor_t hxDesc;
      const void * hx;
      cudnnTensorDescriptor_t cxDesc;
      const void * cx;
      const cudnnTensorDescriptor_t * dxDesc;
      void * dx;
      cudnnTensorDescriptor_t dhxDesc;
      void * dhx;
      cudnnTensorDescriptor_t dcxDesc;
      void * dcx;
      void * workspace;
      size_t workSpaceSizeInBytes;
      const void * reserveSpace;
      size_t reserveSpaceSizeInBytes;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnRNNBackwardData );
  t2d_msg->data.handle = handle;
  t2d_msg->data.rnnDesc = rnnDesc;
  t2d_msg->data.seqLength = seqLength;
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.dy = dy;
  t2d_msg->data.dhyDesc = dhyDesc;
  t2d_msg->data.dhy = dhy;
  t2d_msg->data.dcyDesc = dcyDesc;
  t2d_msg->data.dcy = dcy;
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.w = w;
  t2d_msg->data.hxDesc = hxDesc;
  t2d_msg->data.hx = hx;
  t2d_msg->data.cxDesc = cxDesc;
  t2d_msg->data.cx = cx;
  t2d_msg->data.dxDesc = dxDesc;
  t2d_msg->data.dx = dx;
  t2d_msg->data.dhxDesc = dhxDesc;
  t2d_msg->data.dhx = dhx;
  t2d_msg->data.dcxDesc = dcxDesc;
  t2d_msg->data.dcx = dcx;
  t2d_msg->data.workspace = workspace;
  t2d_msg->data.workSpaceSizeInBytes = workSpaceSizeInBytes;
  t2d_msg->data.reserveSpace = reserveSpace;
  t2d_msg->data.reserveSpaceSizeInBytes = reserveSpaceSizeInBytes;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnRNNBackwardData() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnRNNBackwardWeights ( cudnnHandle_t handle, cudnnRNNDescriptor_t rnnDesc, const int seqLength, const cudnnTensorDescriptor_t * xDesc, const void * x, cudnnTensorDescriptor_t hxDesc, const void * hx, const cudnnTensorDescriptor_t * yDesc, const void * y, const void * workspace, size_t workSpaceSizeInBytes, cudnnFilterDescriptor_t dwDesc, void * dw, const void * reserveSpace, size_t reserveSpaceSizeInBytes )
{
  hfinf( "[trapper] cudnnRNNBackwardWeights() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnRNNDescriptor_t rnnDesc;
      int seqLength;
      const cudnnTensorDescriptor_t * xDesc;
      const void * x;
      cudnnTensorDescriptor_t hxDesc;
      const void * hx;
      const cudnnTensorDescriptor_t * yDesc;
      const void * y;
      const void * workspace;
      size_t workSpaceSizeInBytes;
      cudnnFilterDescriptor_t dwDesc;
      void * dw;
      const void * reserveSpace;
      size_t reserveSpaceSizeInBytes;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnRNNBackwardWeights );
  t2d_msg->data.handle = handle;
  t2d_msg->data.rnnDesc = rnnDesc;
  t2d_msg->data.seqLength = seqLength;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.hxDesc = hxDesc;
  t2d_msg->data.hx = hx;
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  t2d_msg->data.workspace = workspace;
  t2d_msg->data.workSpaceSizeInBytes = workSpaceSizeInBytes;
  t2d_msg->data.dwDesc = dwDesc;
  t2d_msg->data.dw = dw;
  t2d_msg->data.reserveSpace = reserveSpace;
  t2d_msg->data.reserveSpaceSizeInBytes = reserveSpaceSizeInBytes;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnRNNBackwardWeights() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnRNNForwardInference ( cudnnHandle_t handle, cudnnRNNDescriptor_t rnnDesc, const int seqLength, const cudnnTensorDescriptor_t * xDesc, const void * x, cudnnTensorDescriptor_t hxDesc, const void * hx, cudnnTensorDescriptor_t cxDesc, const void * cx, cudnnFilterDescriptor_t wDesc, const void * w, const cudnnTensorDescriptor_t * yDesc, void * y, cudnnTensorDescriptor_t hyDesc, void * hy, cudnnTensorDescriptor_t cyDesc, void * cy, void * workspace, size_t workSpaceSizeInBytes )
{
  hfinf( "[trapper] cudnnRNNForwardInference() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnRNNDescriptor_t rnnDesc;
      int seqLength;
      const cudnnTensorDescriptor_t * xDesc;
      const void * x;
      cudnnTensorDescriptor_t hxDesc;
      const void * hx;
      cudnnTensorDescriptor_t cxDesc;
      const void * cx;
      cudnnFilterDescriptor_t wDesc;
      const void * w;
      const cudnnTensorDescriptor_t * yDesc;
      void * y;
      cudnnTensorDescriptor_t hyDesc;
      void * hy;
      cudnnTensorDescriptor_t cyDesc;
      void * cy;
      void * workspace;
      size_t workSpaceSizeInBytes;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnRNNForwardInference );
  t2d_msg->data.handle = handle;
  t2d_msg->data.rnnDesc = rnnDesc;
  t2d_msg->data.seqLength = seqLength;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.hxDesc = hxDesc;
  t2d_msg->data.hx = hx;
  t2d_msg->data.cxDesc = cxDesc;
  t2d_msg->data.cx = cx;
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.w = w;
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  t2d_msg->data.hyDesc = hyDesc;
  t2d_msg->data.hy = hy;
  t2d_msg->data.cyDesc = cyDesc;
  t2d_msg->data.cy = cy;
  t2d_msg->data.workspace = workspace;
  t2d_msg->data.workSpaceSizeInBytes = workSpaceSizeInBytes;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnRNNForwardInference() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnRNNForwardTraining ( cudnnHandle_t handle, cudnnRNNDescriptor_t rnnDesc, const int seqLength, const cudnnTensorDescriptor_t * xDesc, const void * x, cudnnTensorDescriptor_t hxDesc, const void * hx, cudnnTensorDescriptor_t cxDesc, const void * cx, cudnnFilterDescriptor_t wDesc, const void * w, const cudnnTensorDescriptor_t * yDesc, void * y, cudnnTensorDescriptor_t hyDesc, void * hy, cudnnTensorDescriptor_t cyDesc, void * cy, void * workspace, size_t workSpaceSizeInBytes, void * reserveSpace, size_t reserveSpaceSizeInBytes )
{
  hfinf( "[trapper] cudnnRNNForwardTraining() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnRNNDescriptor_t rnnDesc;
      int seqLength;
      const cudnnTensorDescriptor_t * xDesc;
      const void * x;
      cudnnTensorDescriptor_t hxDesc;
      const void * hx;
      cudnnTensorDescriptor_t cxDesc;
      const void * cx;
      cudnnFilterDescriptor_t wDesc;
      const void * w;
      const cudnnTensorDescriptor_t * yDesc;
      void * y;
      cudnnTensorDescriptor_t hyDesc;
      void * hy;
      cudnnTensorDescriptor_t cyDesc;
      void * cy;
      void * workspace;
      size_t workSpaceSizeInBytes;
      void * reserveSpace;
      size_t reserveSpaceSizeInBytes;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnRNNForwardTraining );
  t2d_msg->data.handle = handle;
  t2d_msg->data.rnnDesc = rnnDesc;
  t2d_msg->data.seqLength = seqLength;
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.hxDesc = hxDesc;
  t2d_msg->data.hx = hx;
  t2d_msg->data.cxDesc = cxDesc;
  t2d_msg->data.cx = cx;
  t2d_msg->data.wDesc = wDesc;
  t2d_msg->data.w = w;
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  t2d_msg->data.hyDesc = hyDesc;
  t2d_msg->data.hy = hy;
  t2d_msg->data.cyDesc = cyDesc;
  t2d_msg->data.cy = cy;
  t2d_msg->data.workspace = workspace;
  t2d_msg->data.workSpaceSizeInBytes = workSpaceSizeInBytes;
  t2d_msg->data.reserveSpace = reserveSpace;
  t2d_msg->data.reserveSpaceSizeInBytes = reserveSpaceSizeInBytes;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnRNNForwardTraining() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnScaleTensor ( cudnnHandle_t handle, cudnnTensorDescriptor_t yDesc, void * y, const void * alpha )
{
  hfinf( "[trapper] cudnnScaleTensor() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnTensorDescriptor_t yDesc;
      void * y;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnScaleTensor );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____yDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, yDesc, &____yDesc_dataType ));
    switch( ____yDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____yDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnScaleTensor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetActivationDescriptor ( cudnnActivationDescriptor_t activationDesc, cudnnActivationMode_t mode, cudnnNanPropagation_t reluNanOpt, double reluCeiling )
{
  hfinf( "[trapper] cudnnSetActivationDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnActivationDescriptor_t activationDesc;
      cudnnActivationMode_t mode;
      cudnnNanPropagation_t reluNanOpt;
      double reluCeiling;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetActivationDescriptor );
  t2d_msg->data.activationDesc = activationDesc;
  t2d_msg->data.mode = mode;
  t2d_msg->data.reluNanOpt = reluNanOpt;
  t2d_msg->data.reluCeiling = reluCeiling;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetActivationDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetConvolution2dDescriptor ( cudnnConvolutionDescriptor_t convDesc, int pad_h, int pad_w, int u, int v, int upscalex, int upscaley, cudnnConvolutionMode_t mode )
{
  hfinf( "[trapper] cudnnSetConvolution2dDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnConvolutionDescriptor_t convDesc;
      int pad_h;
      int pad_w;
      int u;
      int v;
      int upscalex;
      int upscaley;
      cudnnConvolutionMode_t mode;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetConvolution2dDescriptor );
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.pad_h = pad_h;
  t2d_msg->data.pad_w = pad_w;
  t2d_msg->data.u = u;
  t2d_msg->data.v = v;
  t2d_msg->data.upscalex = upscalex;
  t2d_msg->data.upscaley = upscaley;
  t2d_msg->data.mode = mode;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetConvolution2dDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetConvolutionNdDescriptor ( cudnnConvolutionDescriptor_t convDesc, int arrayLength, const int  padA [], const int  filterStrideA [], const int  upscaleA [], cudnnConvolutionMode_t mode, cudnnDataType_t dataType )
{
  hfinf( "[trapper] cudnnSetConvolutionNdDescriptor() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnConvolutionDescriptor_t convDesc;
      int arrayLength;
      const int * padA ;
      const int * filterStrideA ;
      const int * upscaleA ;
      cudnnConvolutionMode_t mode;
      cudnnDataType_t dataType;
      char ____buf[];
    } data;
  } * t2d_msg;
  unsigned int t2d_msg_maxlen = sizeof(*t2d_msg) + arrayLength * sizeof(const int) + arrayLength * sizeof(const int) + arrayLength * sizeof(const int);
  unsigned int t2d_msg_msgcuroffset = 0;
  t2d_msg = ( typeof(t2d_msg) ) malloc ( t2d_msg_maxlen );
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetConvolutionNdDescriptor );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.convDesc = convDesc;
  t2d_msg->data.arrayLength = arrayLength;
  t2d_msg->data.padA = padA;
  if( padA ) {
    hfcuda_am_node_t* _____padA_MEMCHECK = hfcuda_am_mem_check( (int *) padA, devId );
    uint8_t _____padA_PASSONHOST = ! (_____padA_MEMCHECK && _____padA_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____padA_PASSONHOST & 0x1) << 0);
    if(  _____padA_PASSONHOST ) {
      memcpy( &t2d_msg->data.____buf[ t2d_msg_msgcuroffset ], padA, arrayLength * sizeof(const int) );
      t2d_msg_msgcuroffset += arrayLength * sizeof(const int);
    }
  }
  t2d_msg->data.filterStrideA = filterStrideA;
  if( filterStrideA ) {
    hfcuda_am_node_t* _____filterStrideA_MEMCHECK = hfcuda_am_mem_check( (int *) filterStrideA, devId );
    uint8_t _____filterStrideA_PASSONHOST = ! (_____filterStrideA_MEMCHECK && _____filterStrideA_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____filterStrideA_PASSONHOST & 0x1) << 1);
    if(  _____filterStrideA_PASSONHOST ) {
      memcpy( &t2d_msg->data.____buf[ t2d_msg_msgcuroffset ], filterStrideA, arrayLength * sizeof(const int) );
      t2d_msg_msgcuroffset += arrayLength * sizeof(const int);
    }
  }
  t2d_msg->data.upscaleA = upscaleA;
  if( upscaleA ) {
    hfcuda_am_node_t* _____upscaleA_MEMCHECK = hfcuda_am_mem_check( (int *) upscaleA, devId );
    uint8_t _____upscaleA_PASSONHOST = ! (_____upscaleA_MEMCHECK && _____upscaleA_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____upscaleA_PASSONHOST & 0x1) << 2);
    if(  _____upscaleA_PASSONHOST ) {
      memcpy( &t2d_msg->data.____buf[ t2d_msg_msgcuroffset ], upscaleA, arrayLength * sizeof(const int) );
      t2d_msg_msgcuroffset += arrayLength * sizeof(const int);
    }
  }
  t2d_msg->data.mode = mode;
  t2d_msg->data.dataType = dataType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) + t2d_msg_msgcuroffset ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetConvolutionNdDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetDropoutDescriptor ( cudnnDropoutDescriptor_t dropoutDesc, cudnnHandle_t handle, float dropout, void * states, size_t stateSizeInBytes, unsigned long long seed )
{
  hfinf( "[trapper] cudnnSetDropoutDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnDropoutDescriptor_t dropoutDesc;
      cudnnHandle_t handle;
      float dropout;
      void * states;
      size_t stateSizeInBytes;
      unsigned long long seed;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetDropoutDescriptor );
  t2d_msg->data.dropoutDesc = dropoutDesc;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dropout = dropout;
  t2d_msg->data.states = states;
  t2d_msg->data.stateSizeInBytes = stateSizeInBytes;
  t2d_msg->data.seed = seed;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetDropoutDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetFilter4dDescriptor ( cudnnFilterDescriptor_t filterDesc, cudnnDataType_t dataType, cudnnTensorFormat_t format, int k, int c, int h, int w )
{
  hfinf( "[trapper] cudnnSetFilter4dDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnFilterDescriptor_t filterDesc;
      cudnnDataType_t dataType;
      cudnnTensorFormat_t format;
      int k;
      int c;
      int h;
      int w;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetFilter4dDescriptor );
  t2d_msg->data.filterDesc = filterDesc;
  t2d_msg->data.dataType = dataType;
  t2d_msg->data.format = format;
  t2d_msg->data.k = k;
  t2d_msg->data.c = c;
  t2d_msg->data.h = h;
  t2d_msg->data.w = w;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetFilter4dDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetFilterNdDescriptor ( cudnnFilterDescriptor_t filterDesc, cudnnDataType_t dataType, cudnnTensorFormat_t format, int nbDims, const int  filterDimA [] )
{
  hfinf( "[trapper] cudnnSetFilterNdDescriptor() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnFilterDescriptor_t filterDesc;
      cudnnDataType_t dataType;
      cudnnTensorFormat_t format;
      int nbDims;
      const int * filterDimA ;
      char ____buf[];
    } data;
  } * t2d_msg;
  unsigned int t2d_msg_maxlen = sizeof(*t2d_msg) + nbDims * sizeof(const int);
  unsigned int t2d_msg_msgcuroffset = 0;
  t2d_msg = ( typeof(t2d_msg) ) malloc ( t2d_msg_maxlen );
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetFilterNdDescriptor );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.filterDesc = filterDesc;
  t2d_msg->data.dataType = dataType;
  t2d_msg->data.format = format;
  t2d_msg->data.nbDims = nbDims;
  t2d_msg->data.filterDimA = filterDimA;
  if( filterDimA ) {
    hfcuda_am_node_t* _____filterDimA_MEMCHECK = hfcuda_am_mem_check( (int *) filterDimA, devId );
    uint8_t _____filterDimA_PASSONHOST = ! (_____filterDimA_MEMCHECK && _____filterDimA_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____filterDimA_PASSONHOST & 0x1) << 0);
    if(  _____filterDimA_PASSONHOST ) {
      memcpy( &t2d_msg->data.____buf[ t2d_msg_msgcuroffset ], filterDimA, nbDims * sizeof(const int) );
      t2d_msg_msgcuroffset += nbDims * sizeof(const int);
    }
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) + t2d_msg_msgcuroffset ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetFilterNdDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetLRNDescriptor ( cudnnLRNDescriptor_t normDesc, unsigned int lrnN, double lrnAlpha, double lrnBeta, double lrnK )
{
  hfinf( "[trapper] cudnnSetLRNDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnLRNDescriptor_t normDesc;
      unsigned int lrnN;
      double lrnAlpha;
      double lrnBeta;
      double lrnK;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetLRNDescriptor );
  t2d_msg->data.normDesc = normDesc;
  t2d_msg->data.lrnN = lrnN;
  t2d_msg->data.lrnAlpha = lrnAlpha;
  t2d_msg->data.lrnBeta = lrnBeta;
  t2d_msg->data.lrnK = lrnK;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetLRNDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetOpTensorDescriptor ( cudnnOpTensorDescriptor_t opTensorDesc, cudnnOpTensorOp_t opTensorOp, cudnnDataType_t opTensorCompType, cudnnNanPropagation_t opTensorNanOpt )
{
  hfinf( "[trapper] cudnnSetOpTensorDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnOpTensorDescriptor_t opTensorDesc;
      cudnnOpTensorOp_t opTensorOp;
      cudnnDataType_t opTensorCompType;
      cudnnNanPropagation_t opTensorNanOpt;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetOpTensorDescriptor );
  t2d_msg->data.opTensorDesc = opTensorDesc;
  t2d_msg->data.opTensorOp = opTensorOp;
  t2d_msg->data.opTensorCompType = opTensorCompType;
  t2d_msg->data.opTensorNanOpt = opTensorNanOpt;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetOpTensorDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetPooling2dDescriptor ( cudnnPoolingDescriptor_t poolingDesc, cudnnPoolingMode_t mode, cudnnNanPropagation_t maxpoolingNanOpt, int windowHeight, int windowWidth, int verticalPadding, int horizontalPadding, int verticalStride, int horizontalStride )
{
  hfinf( "[trapper] cudnnSetPooling2dDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnPoolingDescriptor_t poolingDesc;
      cudnnPoolingMode_t mode;
      cudnnNanPropagation_t maxpoolingNanOpt;
      int windowHeight;
      int windowWidth;
      int verticalPadding;
      int horizontalPadding;
      int verticalStride;
      int horizontalStride;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetPooling2dDescriptor );
  t2d_msg->data.poolingDesc = poolingDesc;
  t2d_msg->data.mode = mode;
  t2d_msg->data.maxpoolingNanOpt = maxpoolingNanOpt;
  t2d_msg->data.windowHeight = windowHeight;
  t2d_msg->data.windowWidth = windowWidth;
  t2d_msg->data.verticalPadding = verticalPadding;
  t2d_msg->data.horizontalPadding = horizontalPadding;
  t2d_msg->data.verticalStride = verticalStride;
  t2d_msg->data.horizontalStride = horizontalStride;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetPooling2dDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetRNNDescriptor ( cudnnRNNDescriptor_t rnnDesc, int hiddenSize, int numLayers, cudnnDropoutDescriptor_t dropoutDesc, cudnnRNNInputMode_t inputMode, cudnnDirectionMode_t direction, cudnnRNNMode_t mode, cudnnDataType_t dataType )
{
  hfinf( "[trapper] cudnnSetRNNDescriptor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnRNNDescriptor_t rnnDesc;
      int hiddenSize;
      int numLayers;
      cudnnDropoutDescriptor_t dropoutDesc;
      cudnnRNNInputMode_t inputMode;
      cudnnDirectionMode_t direction;
      cudnnRNNMode_t mode;
      cudnnDataType_t dataType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetRNNDescriptor );
  t2d_msg->data.rnnDesc = rnnDesc;
  t2d_msg->data.hiddenSize = hiddenSize;
  t2d_msg->data.numLayers = numLayers;
  t2d_msg->data.dropoutDesc = dropoutDesc;
  t2d_msg->data.inputMode = inputMode;
  t2d_msg->data.direction = direction;
  t2d_msg->data.mode = mode;
  t2d_msg->data.dataType = dataType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetRNNDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetSpatialTransformerNdDescriptor ( cudnnSpatialTransformerDescriptor_t stDesc, cudnnSamplerType_t samplerType, cudnnDataType_t dataType, const int nbDims, const int  dimA [] )
{
  hfinf( "[trapper] cudnnSetSpatialTransformerNdDescriptor() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnSpatialTransformerDescriptor_t stDesc;
      cudnnSamplerType_t samplerType;
      cudnnDataType_t dataType;
      int nbDims;
      const int * dimA ;
      char ____buf[];
    } data;
  } * t2d_msg;
  unsigned int t2d_msg_maxlen = sizeof(*t2d_msg) + nbDims * sizeof(const int);
  unsigned int t2d_msg_msgcuroffset = 0;
  t2d_msg = ( typeof(t2d_msg) ) malloc ( t2d_msg_maxlen );
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetSpatialTransformerNdDescriptor );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.stDesc = stDesc;
  t2d_msg->data.samplerType = samplerType;
  t2d_msg->data.dataType = dataType;
  t2d_msg->data.nbDims = nbDims;
  t2d_msg->data.dimA = dimA;
  if( dimA ) {
    hfcuda_am_node_t* _____dimA_MEMCHECK = hfcuda_am_mem_check( (int *) dimA, devId );
    uint8_t _____dimA_PASSONHOST = ! (_____dimA_MEMCHECK && _____dimA_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____dimA_PASSONHOST & 0x1) << 0);
    if(  _____dimA_PASSONHOST ) {
      memcpy( &t2d_msg->data.____buf[ t2d_msg_msgcuroffset ], dimA, nbDims * sizeof(const int) );
      t2d_msg_msgcuroffset += nbDims * sizeof(const int);
    }
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) + t2d_msg_msgcuroffset ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetSpatialTransformerNdDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetStream ( cudnnHandle_t handle, cudaStream_t streamId )
{
  hfinf( "[trapper] cudnnSetStream() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudaStream_t streamId;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetStream );
  t2d_msg->data.handle = handle;
  t2d_msg->data.streamId = streamId;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetStream() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetTensor ( cudnnHandle_t handle, cudnnTensorDescriptor_t yDesc, void * y, const void * valuePtr )
{
  hfinf( "[trapper] cudnnSetTensor() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnTensorDescriptor_t yDesc;
      void * y;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } valuePtr;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetTensor );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  if( valuePtr ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____yDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, yDesc, &____yDesc_dataType ));
    switch( ____yDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.valuePtr.val = *(float*)valuePtr;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.valuePtr.val = *(double*)valuePtr;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____yDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.valuePtr.ptr = NULL;
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetTensor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetTensor4dDescriptor ( cudnnTensorDescriptor_t tensorDesc, cudnnTensorFormat_t format, cudnnDataType_t dataType, int n, int c, int h, int w )
{
  hfinf( "[trapper] cudnnSetTensor4dDescriptor() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnTensorDescriptor_t tensorDesc;
      cudnnTensorFormat_t format;
      cudnnDataType_t dataType;
      int n;
      int c;
      int h;
      int w;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetTensor4dDescriptor );
  t2d_msg->data.tensorDesc = tensorDesc;
  t2d_msg->data.format = format;
  t2d_msg->data.dataType = dataType;
  t2d_msg->data.n = n;
  t2d_msg->data.c = c;
  t2d_msg->data.h = h;
  t2d_msg->data.w = w;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetTensor4dDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  if( d2t_msg.____RETVAL == CUDNN_STATUS_SUCCESS ) {
    hfcheck(hfcuda_set_cudnnDataType( devId, tensorDesc, dataType ));
  }
  
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetTensor4dDescriptorEx ( cudnnTensorDescriptor_t tensorDesc, cudnnDataType_t dataType, int n, int c, int h, int w, int nStride, int cStride, int hStride, int wStride )
{
  hfinf( "[trapper] cudnnSetTensor4dDescriptorEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnTensorDescriptor_t tensorDesc;
      cudnnDataType_t dataType;
      int n;
      int c;
      int h;
      int w;
      int nStride;
      int cStride;
      int hStride;
      int wStride;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetTensor4dDescriptorEx );
  t2d_msg->data.tensorDesc = tensorDesc;
  t2d_msg->data.dataType = dataType;
  t2d_msg->data.n = n;
  t2d_msg->data.c = c;
  t2d_msg->data.h = h;
  t2d_msg->data.w = w;
  t2d_msg->data.nStride = nStride;
  t2d_msg->data.cStride = cStride;
  t2d_msg->data.hStride = hStride;
  t2d_msg->data.wStride = wStride;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetTensor4dDescriptorEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  if( d2t_msg.____RETVAL == CUDNN_STATUS_SUCCESS ) {
    hfcheck(hfcuda_set_cudnnDataType( devId, tensorDesc, dataType ));
  }
  
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSetTensorNdDescriptor ( cudnnTensorDescriptor_t tensorDesc, cudnnDataType_t dataType, int nbDims, const int  dimA [], const int  strideA [] )
{
  hfinf( "[trapper] cudnnSetTensorNdDescriptor() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnTensorDescriptor_t tensorDesc;
      cudnnDataType_t dataType;
      int nbDims;
      const int * dimA ;
      const int * strideA ;
      char ____buf[];
    } data;
  } * t2d_msg;
  unsigned int t2d_msg_maxlen = sizeof(*t2d_msg) + nbDims * sizeof(const int) + nbDims * sizeof(const int);
  unsigned int t2d_msg_msgcuroffset = 0;
  t2d_msg = ( typeof(t2d_msg) ) malloc ( t2d_msg_maxlen );
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSetTensorNdDescriptor );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.tensorDesc = tensorDesc;
  t2d_msg->data.dataType = dataType;
  t2d_msg->data.nbDims = nbDims;
  t2d_msg->data.dimA = dimA;
  if( dimA ) {
    hfcuda_am_node_t* _____dimA_MEMCHECK = hfcuda_am_mem_check( (int *) dimA, devId );
    uint8_t _____dimA_PASSONHOST = ! (_____dimA_MEMCHECK && _____dimA_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____dimA_PASSONHOST & 0x1) << 0);
    if(  _____dimA_PASSONHOST ) {
      memcpy( &t2d_msg->data.____buf[ t2d_msg_msgcuroffset ], dimA, nbDims * sizeof(const int) );
      t2d_msg_msgcuroffset += nbDims * sizeof(const int);
    }
  }
  t2d_msg->data.strideA = strideA;
  if( strideA ) {
    hfcuda_am_node_t* _____strideA_MEMCHECK = hfcuda_am_mem_check( (int *) strideA, devId );
    uint8_t _____strideA_PASSONHOST = ! (_____strideA_MEMCHECK && _____strideA_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____strideA_PASSONHOST & 0x1) << 1);
    if(  _____strideA_PASSONHOST ) {
      memcpy( &t2d_msg->data.____buf[ t2d_msg_msgcuroffset ], strideA, nbDims * sizeof(const int) );
      t2d_msg_msgcuroffset += nbDims * sizeof(const int);
    }
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) + t2d_msg_msgcuroffset ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSetTensorNdDescriptor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  if( d2t_msg.____RETVAL == CUDNN_STATUS_SUCCESS ) {
    hfcheck(hfcuda_set_cudnnDataType( devId, tensorDesc, dataType ));
  }
  
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSoftmaxBackward ( cudnnHandle_t handle, cudnnSoftmaxAlgorithm_t algo, cudnnSoftmaxMode_t mode, const void * alpha, cudnnTensorDescriptor_t yDesc, const void * y, cudnnTensorDescriptor_t dyDesc, const void * dy, const void * beta, cudnnTensorDescriptor_t dxDesc, void * dx )
{
  hfinf( "[trapper] cudnnSoftmaxBackward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnSoftmaxAlgorithm_t algo;
      cudnnSoftmaxMode_t mode;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t yDesc;
      const void * y;
      cudnnTensorDescriptor_t dyDesc;
      const void * dy;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t dxDesc;
      void * dx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSoftmaxBackward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.algo = algo;
  t2d_msg->data.mode = mode;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____yDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, yDesc, &____yDesc_dataType ));
    switch( ____yDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____yDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.dy = dy;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____yDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, yDesc, &____yDesc_dataType ));
    switch( ____yDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____yDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.dxDesc = dxDesc;
  t2d_msg->data.dx = dx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSoftmaxBackward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSoftmaxForward ( cudnnHandle_t handle, cudnnSoftmaxAlgorithm_t algo, cudnnSoftmaxMode_t mode, const void * alpha, cudnnTensorDescriptor_t xDesc, const void * x, const void * beta, cudnnTensorDescriptor_t yDesc, void * y )
{
  hfinf( "[trapper] cudnnSoftmaxForward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnSoftmaxAlgorithm_t algo;
      cudnnSoftmaxMode_t mode;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t yDesc;
      void * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSoftmaxForward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.algo = algo;
  t2d_msg->data.mode = mode;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSoftmaxForward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSpatialTfGridGeneratorBackward ( cudnnHandle_t handle, cudnnSpatialTransformerDescriptor_t stDesc, const void * dgrid, void * dtheta )
{
  hfinf( "[trapper] cudnnSpatialTfGridGeneratorBackward() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cudnnHandle_t handle;
      cudnnSpatialTransformerDescriptor_t stDesc;
      const void * dgrid;
      void * dtheta;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSpatialTfGridGeneratorBackward );
  t2d_msg->data.handle = handle;
  t2d_msg->data.stDesc = stDesc;
  t2d_msg->data.dgrid = dgrid;
  t2d_msg->data.dtheta = dtheta;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSpatialTfGridGeneratorBackward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSpatialTfSamplerBackward ( cudnnHandle_t handle, cudnnSpatialTransformerDescriptor_t stDesc, const void * alpha, cudnnTensorDescriptor_t xDesc, const void * x, const void * beta, cudnnTensorDescriptor_t dxDesc, void * dx, const void * alphaDgrid, cudnnTensorDescriptor_t dyDesc, const void * dy, const void * grid, const void * betaDgrid, void * dgrid )
{
  hfinf( "[trapper] cudnnSpatialTfSamplerBackward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnSpatialTransformerDescriptor_t stDesc;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t dxDesc;
      void * dx;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alphaDgrid;
      cudnnTensorDescriptor_t dyDesc;
      const void * dy;
      const void * grid;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } betaDgrid;
      void * dgrid;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSpatialTfSamplerBackward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.stDesc = stDesc;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.dxDesc = dxDesc;
  t2d_msg->data.dx = dx;
  if( alphaDgrid ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 2);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alphaDgrid.val = *(float*)alphaDgrid;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alphaDgrid.val = *(double*)alphaDgrid;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alphaDgrid.ptr = NULL;
  }
  t2d_msg->data.dyDesc = dyDesc;
  t2d_msg->data.dy = dy;
  t2d_msg->data.grid = grid;
  if( betaDgrid ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 3);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.betaDgrid.val = *(float*)betaDgrid;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.betaDgrid.val = *(double*)betaDgrid;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.betaDgrid.ptr = NULL;
  }
  t2d_msg->data.dgrid = dgrid;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSpatialTfSamplerBackward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnSpatialTfSamplerForward ( cudnnHandle_t handle, cudnnSpatialTransformerDescriptor_t stDesc, const void * alpha, cudnnTensorDescriptor_t xDesc, const void * x, const void * grid, const void * beta, cudnnTensorDescriptor_t yDesc, void * y )
{
  hfinf( "[trapper] cudnnSpatialTfSamplerForward() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      cudnnSpatialTransformerDescriptor_t stDesc;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      const void * grid;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t yDesc;
      void * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnSpatialTfSamplerForward );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.stDesc = stDesc;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  t2d_msg->data.grid = grid;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnSpatialTfSamplerForward() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cudnnStatus_t
cudnnTransformTensor ( cudnnHandle_t handle, const void * alpha, cudnnTensorDescriptor_t xDesc, const void * x, const void * beta, cudnnTensorDescriptor_t yDesc, void * y )
{
  hfinf( "[trapper] cudnnTransformTensor() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cudnnHandle_t handle;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cudnnTensorDescriptor_t xDesc;
      const void * x;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(double) ? sizeof(double)-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(double) ? sizeof(const void *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cudnnTensorDescriptor_t yDesc;
      void * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cudnnTransformTensor );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  if( alpha ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.alpha.val = *(float*)alpha;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.alpha.val = *(double*)alpha;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xDesc = xDesc;
  t2d_msg->data.x = x;
  if( beta ) {
    t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    cudnnDataType_t ____xDesc_dataType;
    hfcheck(hfcuda_get_cudnnDataType( devId, xDesc, &____xDesc_dataType ));
    switch( ____xDesc_dataType ) {
      case CUDNN_DATA_FLOAT:
      case CUDNN_DATA_HALF: {
        *(float*)&t2d_msg->data.beta.val = *(float*)beta;
        break;
      }
      case CUDNN_DATA_DOUBLE: {
        *(double*)&t2d_msg->data.beta.val = *(double*)beta;
        break;
      }
      default: {
        hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, ____xDesc_dataType );
        exit(-1);
      }
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.yDesc = yDesc;
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cudnnStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cudnnTransformTensor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCaxpyi ( cusparseHandle_t handle, int nnz, const cuComplex * alpha, const cuComplex * xVal, const int * xInd, cuComplex * y, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseCaxpyi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * xVal;
      const int * xInd;
      cuComplex * y;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCaxpyi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCaxpyi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCbsr2csr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, cusparseMatDescr_t descrC, cuComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseCbsr2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      cusparseMatDescr_t descrA;
      const cuComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      cusparseMatDescr_t descrC;
      cuComplex * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCbsr2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCbsr2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCbsrmm ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int kb, int nnzb, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, const int blockSize, const cuComplex * B, const int ldb, const cuComplex * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cusparseCbsrmm() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int mb;
      int n;
      int kb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockSize;
      const cuComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCbsrmm );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.kb = kb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCbsrmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCbsrmv ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nb, int nnzb, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const cuComplex * x, const cuComplex * beta, cuComplex * y )
{
  hfinf( "[trapper] cusparseCbsrmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      const cuComplex * x;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCbsrmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCbsrmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCbsrsm2_analysis ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, cusparseMatDescr_t descrA, const cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseCbsrsm2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      cusparseMatDescr_t descrA;
      const cuComplex * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCbsrsm2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCbsrsm2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCbsrsm2_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, cusparseMatDescr_t descrA, cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseCbsrsm2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      cusparseMatDescr_t descrA;
      cuComplex * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCbsrsm2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseCbsrsm2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCbsrsm2_solve ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, const cuComplex * F, int ldf, cuComplex * X, int ldx, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseCbsrsm2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
      const cuComplex * F;
      int ldf;
      cuComplex * X;
      int ldx;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCbsrsm2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  t2d_msg->data.F = F;
  t2d_msg->data.ldf = ldf;
  t2d_msg->data.X = X;
  t2d_msg->data.ldx = ldx;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCbsrsm2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCbsrsv2_analysis ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseCbsrsv2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const cuComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCbsrsv2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCbsrsv2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCbsrsv2_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, cusparseMatDescr_t descrA, cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseCbsrsv2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      cusparseMatDescr_t descrA;
      cuComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCbsrsv2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseCbsrsv2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCbsrsv2_solve ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, const cuComplex * f, cuComplex * x, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseCbsrsv2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
      const cuComplex * f;
      cuComplex * x;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCbsrsv2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCbsrsv2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCbsrxmv ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int sizeOfMask, int mb, int nb, int nnzb, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedMaskPtrA, const int * bsrSortedRowPtrA, const int * bsrSortedEndPtrA, const int * bsrSortedColIndA, int blockDim, const cuComplex * x, const cuComplex * beta, cuComplex * y )
{
  hfinf( "[trapper] cusparseCbsrxmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int sizeOfMask;
      int mb;
      int nb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * bsrSortedValA;
      const int * bsrSortedMaskPtrA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedEndPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      const cuComplex * x;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCbsrxmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.sizeOfMask = sizeOfMask;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedMaskPtrA = bsrSortedMaskPtrA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedEndPtrA = bsrSortedEndPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCbsrxmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsc2dense ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuComplex * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cuComplex * A, int lda )
{
  hfinf( "[trapper] cusparseCcsc2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuComplex * cscSortedValA;
      const int * cscSortedRowIndA;
      const int * cscSortedColPtrA;
      cuComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsc2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsc2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsc2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuComplex * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseCcsc2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuComplex * cscSortedValA;
      const int * cscSortedRowIndA;
      const int * cscSortedColPtrA;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsc2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsc2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsr2bsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int blockDim, cusparseMatDescr_t descrC, cuComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC )
{
  hfinf( "[trapper] cusparseCcsr2bsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      int blockDim;
      cusparseMatDescr_t descrC;
      cuComplex * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsr2bsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsr2bsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsr2csc ( cusparseHandle_t handle, int m, int n, int nnz, const cuComplex * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, cuComplex * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseCcsr2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      const cuComplex * csrSortedVal;
      const int * csrSortedRowPtr;
      const int * csrSortedColInd;
      cuComplex * cscSortedVal;
      int * cscSortedRowInd;
      int * cscSortedColPtr;
      cusparseAction_t copyValues;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsr2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.csrSortedVal = csrSortedVal;
  t2d_msg->data.csrSortedRowPtr = csrSortedRowPtr;
  t2d_msg->data.csrSortedColInd = csrSortedColInd;
  t2d_msg->data.cscSortedVal = cscSortedVal;
  t2d_msg->data.cscSortedRowInd = cscSortedRowInd;
  t2d_msg->data.cscSortedColPtr = cscSortedColPtr;
  t2d_msg->data.copyValues = copyValues;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsr2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsr2csr_compress ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descra, const cuComplex * csrValA, const int * csrColIndA, const int * csrRowPtrA, int nnzA, const int * nnzPerRow, cuComplex * csrValC, int * csrColIndC, int * csrRowPtrC, cuComplex tol )
{
  hfinf( "[trapper] cusparseCcsr2csr_compress() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descra;
      const cuComplex * csrValA;
      const int * csrColIndA;
      const int * csrRowPtrA;
      int nnzA;
      const int * nnzPerRow;
      cuComplex * csrValC;
      int * csrColIndC;
      int * csrRowPtrC;
      cuComplex tol;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsr2csr_compress );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descra = descra;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.tol = tol;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsr2csr_compress() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsr2csru ( cusparseHandle_t handle, int m, int n, int nnz, cusparseMatDescr_t descrA, cuComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseCcsr2csru() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cusparseMatDescr_t descrA;
      cuComplex * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsr2csru );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsr2csru() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsr2dense ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cuComplex * A, int lda )
{
  hfinf( "[trapper] cusparseCcsr2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cuComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsr2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsr2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsr2gebsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrC, cuComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDim, int colBlockDim, void * pBuffer )
{
  hfinf( "[trapper] cusparseCcsr2gebsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrC;
      cuComplex * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
      int rowBlockDim;
      int colBlockDim;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsr2gebsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsr2gebsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsr2gebsr_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseCcsr2gebsr_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      int rowBlockDim;
      int colBlockDim;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsr2gebsr_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseCcsr2gebsr_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsr2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseCcsr2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsr2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsr2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrcolor ( cusparseHandle_t handle, int m, int nnz, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * fractionToColor, int * ncolors, int * coloring, int * reordering, cusparseColorInfo_t info )
{
  hfinf( "[trapper] cusparseCcsrcolor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const float * fractionToColor;
      int * coloring;
      int * reordering;
      cusparseColorInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrcolor );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.fractionToColor = fractionToColor;
  t2d_msg->data.coloring = coloring;
  t2d_msg->data.reordering = reordering;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int ncolors;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( ncolors ) *ncolors = d2t_msg.ncolors;
  hfinf( "[trapper] cusparseCcsrcolor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrgeam ( cusparseHandle_t handle, int m, int n, const cuComplex * alpha, cusparseMatDescr_t descrA, int nnzA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * beta, cusparseMatDescr_t descrB, int nnzB, const cuComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, cusparseMatDescr_t descrC, cuComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseCcsrgeam() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cusparseMatDescr_t descrB;
      int nnzB;
      const cuComplex * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      cusparseMatDescr_t descrC;
      cuComplex * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrgeam );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrgeam() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrgemm ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, cusparseMatDescr_t descrA, int nnzA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const cuComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, cusparseMatDescr_t descrC, cuComplex * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseCcsrgemm() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int m;
      int n;
      int k;
      cusparseMatDescr_t descrA;
      int nnzA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const cuComplex * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      cusparseMatDescr_t descrC;
      cuComplex * csrSortedValC;
      const int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrgemm );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrgemm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrgemm2 ( cusparseHandle_t handle, int m, int n, int k, const cuComplex * alpha, cusparseMatDescr_t descrA, int nnzA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const cuComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cuComplex * beta, cusparseMatDescr_t descrD, int nnzD, const cuComplex * csrSortedValD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, cusparseMatDescr_t descrC, cuComplex * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, csrgemm2Info_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseCcsrgemm2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const cuComplex * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cusparseMatDescr_t descrD;
      int nnzD;
      const cuComplex * csrSortedValD;
      const int * csrSortedRowPtrD;
      const int * csrSortedColIndD;
      cusparseMatDescr_t descrC;
      cuComplex * csrSortedValC;
      const int * csrSortedRowPtrC;
      int * csrSortedColIndC;
      csrgemm2Info_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrgemm2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrD = descrD;
  t2d_msg->data.nnzD = nnzD;
  t2d_msg->data.csrSortedValD = csrSortedValD;
  t2d_msg->data.csrSortedRowPtrD = csrSortedRowPtrD;
  t2d_msg->data.csrSortedColIndD = csrSortedColIndD;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrgemm2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrgemm2_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int k, const cuComplex * alpha, cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cuComplex * beta, cusparseMatDescr_t descrD, int nnzD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, csrgemm2Info_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseCcsrgemm2_bufferSizeExt() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cusparseMatDescr_t descrD;
      int nnzD;
      const int * csrSortedRowPtrD;
      const int * csrSortedColIndD;
      csrgemm2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrgemm2_bufferSizeExt );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrD = descrD;
  t2d_msg->data.nnzD = nnzD;
  t2d_msg->data.csrSortedRowPtrD = csrSortedRowPtrD;
  t2d_msg->data.csrSortedColIndD = csrSortedColIndD;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseCcsrgemm2_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrmm ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int k, int nnz, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cusparseCcsrmm() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const cuComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrmm );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrmm2 ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, int nnz, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cusparseCcsrmm2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const cuComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrmm2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrmm2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrmv ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * x, const cuComplex * beta, cuComplex * y )
{
  hfinf( "[trapper] cusparseCcsrmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const cuComplex * x;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrmv_mp ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * x, const cuComplex * beta, cuComplex * y )
{
  hfinf( "[trapper] cusparseCcsrmv_mp() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const cuComplex * x;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrmv_mp );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrmv_mp() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrsm_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseCcsrsm_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrsm_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrsm_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrsm_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const cuComplex * F, int ldf, cuComplex * X, int ldx )
{
  hfinf( "[trapper] cusparseCcsrsm_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
      const cuComplex * F;
      int ldf;
      cuComplex * X;
      int ldx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrsm_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.F = F;
  t2d_msg->data.ldf = ldf;
  t2d_msg->data.X = X;
  t2d_msg->data.ldx = ldx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrsm_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrsv2_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseCcsrsv2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrsv2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrsv2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrsv2_bufferSize ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseCcsrsv2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrsv2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseCcsrsv2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrsv2_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, const cuComplex * f, cuComplex * x, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseCcsrsv2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
      const cuComplex * f;
      cuComplex * x;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrsv2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrsv2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrsv_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseCcsrsv_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrsv_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrsv_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsrsv_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, const cuComplex * alpha, cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const cuComplex * f, cuComplex * x )
{
  hfinf( "[trapper] cusparseCcsrsv_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
      const cuComplex * f;
      cuComplex * x;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsrsv_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsrsv_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsru2csr ( cusparseHandle_t handle, int m, int n, int nnz, cusparseMatDescr_t descrA, cuComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseCcsru2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cusparseMatDescr_t descrA;
      cuComplex * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsru2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCcsru2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCcsru2csr_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int nnz, cuComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseCcsru2csr_bufferSizeExt() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cuComplex * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCcsru2csr_bufferSizeExt );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseCcsru2csr_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCdense2csc ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuComplex * A, int lda, const int * nnzPerCol, cuComplex * cscSortedValA, int * cscSortedRowIndA, int * cscSortedColPtrA )
{
  hfinf( "[trapper] cusparseCdense2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuComplex * A;
      int lda;
      const int * nnzPerCol;
      cuComplex * cscSortedValA;
      int * cscSortedRowIndA;
      int * cscSortedColPtrA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCdense2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerCol = nnzPerCol;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCdense2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCdense2csr ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuComplex * A, int lda, const int * nnzPerRow, cuComplex * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA )
{
  hfinf( "[trapper] cusparseCdense2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuComplex * A;
      int lda;
      const int * nnzPerRow;
      cuComplex * csrSortedValA;
      int * csrSortedRowPtrA;
      int * csrSortedColIndA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCdense2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCdense2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCdense2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuComplex * A, int lda, const int * nnzPerRow, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseCdense2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuComplex * A;
      int lda;
      const int * nnzPerRow;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCdense2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCdense2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCdotci ( cusparseHandle_t handle, int nnz, const cuComplex * xVal, const int * xInd, const cuComplex * y, cuComplex * resultDevHostPtr, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseCdotci() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int nnz;
      const cuComplex * xVal;
      const int * xInd;
      const cuComplex * y;
      cuComplex * resultDevHostPtr;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCdotci );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.resultDevHostPtr = resultDevHostPtr;
  if( resultDevHostPtr ) {
    hfcuda_am_node_t* _____resultDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) resultDevHostPtr, devId );
    uint8_t _____resultDevHostPtr_PASSONHOST = ! (_____resultDevHostPtr_MEMCHECK && _____resultDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____resultDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    cuComplex resultDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( resultDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *resultDevHostPtr = d2t_msg.resultDevHostPtr;
  }
  hfinf( "[trapper] cusparseCdotci() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCdoti ( cusparseHandle_t handle, int nnz, const cuComplex * xVal, const int * xInd, const cuComplex * y, cuComplex * resultDevHostPtr, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseCdoti() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int nnz;
      const cuComplex * xVal;
      const int * xInd;
      const cuComplex * y;
      cuComplex * resultDevHostPtr;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCdoti );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.resultDevHostPtr = resultDevHostPtr;
  if( resultDevHostPtr ) {
    hfcuda_am_node_t* _____resultDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) resultDevHostPtr, devId );
    uint8_t _____resultDevHostPtr_PASSONHOST = ! (_____resultDevHostPtr_MEMCHECK && _____resultDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____resultDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    cuComplex resultDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( resultDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *resultDevHostPtr = d2t_msg.resultDevHostPtr;
  }
  hfinf( "[trapper] cusparseCdoti() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCgebsr2csr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDim, int colBlockDim, cusparseMatDescr_t descrC, cuComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseCgebsr2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      cusparseMatDescr_t descrA;
      const cuComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDim;
      int colBlockDim;
      cusparseMatDescr_t descrC;
      cuComplex * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCgebsr2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCgebsr2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCgebsr2gebsc ( cusparseHandle_t handle, int mb, int nb, int nnzb, const cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, cuComplex * bscVal, int * bscRowInd, int * bscColPtr, cusparseAction_t copyValues, cusparseIndexBase_t baseIdx, void * pBuffer )
{
  hfinf( "[trapper] cusparseCgebsr2gebsc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int mb;
      int nb;
      int nnzb;
      const cuComplex * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int rowBlockDim;
      int colBlockDim;
      cuComplex * bscVal;
      int * bscRowInd;
      int * bscColPtr;
      cusparseAction_t copyValues;
      cusparseIndexBase_t baseIdx;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCgebsr2gebsc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.bscVal = bscVal;
  t2d_msg->data.bscRowInd = bscRowInd;
  t2d_msg->data.bscColPtr = bscColPtr;
  t2d_msg->data.copyValues = copyValues;
  t2d_msg->data.baseIdx = baseIdx;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCgebsr2gebsc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCgebsr2gebsc_bufferSize ( cusparseHandle_t handle, int mb, int nb, int nnzb, const cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseCgebsr2gebsc_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int mb;
      int nb;
      int nnzb;
      const cuComplex * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int rowBlockDim;
      int colBlockDim;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCgebsr2gebsc_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseCgebsr2gebsc_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCgebsr2gebsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, cusparseMatDescr_t descrC, cuComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDimC, int colBlockDimC, void * pBuffer )
{
  hfinf( "[trapper] cusparseCgebsr2gebsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const cuComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDimA;
      int colBlockDimA;
      cusparseMatDescr_t descrC;
      cuComplex * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
      int rowBlockDimC;
      int colBlockDimC;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCgebsr2gebsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDimA = rowBlockDimA;
  t2d_msg->data.colBlockDimA = colBlockDimA;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  t2d_msg->data.rowBlockDimC = rowBlockDimC;
  t2d_msg->data.colBlockDimC = colBlockDimC;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCgebsr2gebsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCgebsr2gebsr_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseCgebsr2gebsr_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const cuComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDimA;
      int colBlockDimA;
      int rowBlockDimC;
      int colBlockDimC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCgebsr2gebsr_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDimA = rowBlockDimA;
  t2d_msg->data.colBlockDimA = colBlockDimA;
  t2d_msg->data.rowBlockDimC = rowBlockDimC;
  t2d_msg->data.colBlockDimC = colBlockDimC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseCgebsr2gebsr_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCgemmi ( cusparseHandle_t handle, int m, int n, int k, int nnz, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * cscValB, const int * cscColPtrB, const int * cscRowIndB, const cuComplex * beta, cuComplex * C, int ldc )
{
  hfinf( "[trapper] cusparseCgemmi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      const cuComplex * cscValB;
      const int * cscColPtrB;
      const int * cscRowIndB;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCgemmi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.cscValB = cscValB;
  t2d_msg->data.cscColPtrB = cscColPtrB;
  t2d_msg->data.cscRowIndB = cscRowIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCgemmi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCgemvi ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, int nnz, const cuComplex * xVal, const int * xInd, const cuComplex * beta, cuComplex * y, cusparseIndexBase_t idxBase, void * pBuffer )
{
  hfinf( "[trapper] cusparseCgemvi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      const cuComplex * A;
      int lda;
      int nnz;
      const cuComplex * xVal;
      const int * xInd;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
      cusparseIndexBase_t idxBase;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCgemvi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCgemvi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCgemvi_bufferSize ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, int * pBufferSize )
{
  hfinf( "[trapper] cusparseCgemvi_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCgemvi_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSize;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSize ) *pBufferSize = d2t_msg.pBufferSize;
  hfinf( "[trapper] cusparseCgemvi_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCgthr ( cusparseHandle_t handle, int nnz, const cuComplex * y, cuComplex * xVal, const int * xInd, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseCgthr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      const cuComplex * y;
      cuComplex * xVal;
      const int * xInd;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCgthr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.y = y;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCgthr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCgthrz ( cusparseHandle_t handle, int nnz, cuComplex * y, cuComplex * xVal, const int * xInd, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseCgthrz() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      cuComplex * y;
      cuComplex * xVal;
      const int * xInd;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCgthrz );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.y = y;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCgthrz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseChyb2csc ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cuComplex * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr )
{
  hfinf( "[trapper] cusparseChyb2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      cuComplex * cscSortedVal;
      int * cscSortedRowInd;
      int * cscSortedColPtr;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseChyb2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.cscSortedVal = cscSortedVal;
  t2d_msg->data.cscSortedRowInd = cscSortedRowInd;
  t2d_msg->data.cscSortedColPtr = cscSortedColPtr;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseChyb2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseChyb2csr ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cuComplex * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA )
{
  hfinf( "[trapper] cusparseChyb2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      cuComplex * csrSortedValA;
      int * csrSortedRowPtrA;
      int * csrSortedColIndA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseChyb2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseChyb2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseChyb2dense ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cuComplex * A, int lda )
{
  hfinf( "[trapper] cusparseChyb2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      cuComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseChyb2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseChyb2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseChybmv ( cusparseHandle_t handle, cusparseOperation_t transA, const cuComplex * alpha, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, const cuComplex * x, const cuComplex * beta, cuComplex * y )
{
  hfinf( "[trapper] cusparseChybmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      const cuComplex * x;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } beta;
      cuComplex * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseChybmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseChybmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseChybsv_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseChybsv_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseChybsv_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseChybsv_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseChybsv_solve ( cusparseHandle_t handle, cusparseOperation_t trans, const cuComplex * alpha, cusparseMatDescr_t descra, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info, const cuComplex * f, cuComplex * x )
{
  hfinf( "[trapper] cusparseChybsv_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t trans;
      union {
        struct {
          char ___dummy0[sizeof(const cuComplex *) < sizeof(cuComplex) ? sizeof(cuComplex)-sizeof(const cuComplex *) : 0];
          const cuComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuComplex *) > sizeof(cuComplex) ? sizeof(const cuComplex *)-sizeof(cuComplex) : 0];
          cuComplex val;
        };
      } alpha;
      cusparseMatDescr_t descra;
      cusparseHybMat_t hybA;
      cusparseSolveAnalysisInfo_t info;
      const cuComplex * f;
      cuComplex * x;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseChybsv_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descra = descra;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseChybsv_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCnnz ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const cuComplex * A, int lda, int * nnzPerRowCol, int * nnzTotalDevHostPtr )
{
  hfinf( "[trapper] cusparseCnnz() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuComplex * A;
      int lda;
      int * nnzPerRowCol;
      int * nnzTotalDevHostPtr;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCnnz );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRowCol = nnzPerRowCol;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseCnnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCnnz_compress ( cusparseHandle_t handle, int m, cusparseMatDescr_t descr, const cuComplex * csrValA, const int * csrRowPtrA, int * nnzPerRow, int * nnzC, cuComplex tol )
{
  hfinf( "[trapper] cusparseCnnz_compress() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      cusparseMatDescr_t descr;
      const cuComplex * csrValA;
      const int * csrRowPtrA;
      int * nnzPerRow;
      int * nnzC;
      cuComplex tol;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCnnz_compress );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.descr = descr;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.nnzC = nnzC;
  t2d_msg->data.tol = tol;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCnnz_compress() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreate ( cusparseHandle_t * handle )
{
  hfinf( "[trapper] cusparseCreate() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreate );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    cusparseHandle_t handle;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( handle ) *handle = d2t_msg.handle;
  hfinf( "[trapper] cusparseCreate() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateBsric02Info ( bsric02Info_t * info )
{
  hfinf( "[trapper] cusparseCreateBsric02Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateBsric02Info );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    bsric02Info_t info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cusparseCreateBsric02Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateBsrilu02Info ( bsrilu02Info_t * info )
{
  hfinf( "[trapper] cusparseCreateBsrilu02Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateBsrilu02Info );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    bsrilu02Info_t info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cusparseCreateBsrilu02Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateBsrsm2Info ( bsrsm2Info_t * info )
{
  hfinf( "[trapper] cusparseCreateBsrsm2Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateBsrsm2Info );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    bsrsm2Info_t info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cusparseCreateBsrsm2Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateBsrsv2Info ( bsrsv2Info_t * info )
{
  hfinf( "[trapper] cusparseCreateBsrsv2Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateBsrsv2Info );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    bsrsv2Info_t info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cusparseCreateBsrsv2Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateCsrgemm2Info ( csrgemm2Info_t * info )
{
  hfinf( "[trapper] cusparseCreateCsrgemm2Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateCsrgemm2Info );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    csrgemm2Info_t info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cusparseCreateCsrgemm2Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateCsric02Info ( csric02Info_t * info )
{
  hfinf( "[trapper] cusparseCreateCsric02Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateCsric02Info );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    csric02Info_t info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cusparseCreateCsric02Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateCsrilu02Info ( csrilu02Info_t * info )
{
  hfinf( "[trapper] cusparseCreateCsrilu02Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateCsrilu02Info );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    csrilu02Info_t info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cusparseCreateCsrilu02Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateCsrsv2Info ( csrsv2Info_t * info )
{
  hfinf( "[trapper] cusparseCreateCsrsv2Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateCsrsv2Info );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    csrsv2Info_t info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cusparseCreateCsrsv2Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateCsru2csrInfo ( csru2csrInfo_t * info )
{
  hfinf( "[trapper] cusparseCreateCsru2csrInfo() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateCsru2csrInfo );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    csru2csrInfo_t info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cusparseCreateCsru2csrInfo() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateHybMat ( cusparseHybMat_t * hybA )
{
  hfinf( "[trapper] cusparseCreateHybMat() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateHybMat );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    cusparseHybMat_t hybA;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( hybA ) *hybA = d2t_msg.hybA;
  hfinf( "[trapper] cusparseCreateHybMat() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateIdentityPermutation ( cusparseHandle_t handle, int n, int * p )
{
  hfinf( "[trapper] cusparseCreateIdentityPermutation() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int n;
      int * p;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateIdentityPermutation );
  t2d_msg->data.handle = handle;
  t2d_msg->data.n = n;
  t2d_msg->data.p = p;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCreateIdentityPermutation() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateMatDescr ( cusparseMatDescr_t * descrA )
{
  hfinf( "[trapper] cusparseCreateMatDescr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateMatDescr );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    cusparseMatDescr_t descrA;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( descrA ) *descrA = d2t_msg.descrA;
  hfinf( "[trapper] cusparseCreateMatDescr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreatePruneInfo ( pruneInfo_t * info )
{
  hfinf( "[trapper] cusparseCreatePruneInfo() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreatePruneInfo );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    pruneInfo_t info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cusparseCreatePruneInfo() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCreateSolveAnalysisInfo ( cusparseSolveAnalysisInfo_t * info )
{
  hfinf( "[trapper] cusparseCreateSolveAnalysisInfo() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCreateSolveAnalysisInfo );
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    cusparseSolveAnalysisInfo_t info;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( info ) *info = d2t_msg.info;
  hfinf( "[trapper] cusparseCreateSolveAnalysisInfo() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCsctr ( cusparseHandle_t handle, int nnz, const cuComplex * xVal, const int * xInd, cuComplex * y, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseCsctr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      const cuComplex * xVal;
      const int * xInd;
      cuComplex * y;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCsctr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCsctr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCsr2cscEx ( cusparseHandle_t handle, int m, int n, int nnz, const void * csrSortedVal, cudaDataType csrSortedValtype, const int * csrSortedRowPtr, const int * csrSortedColInd, void * cscSortedVal, cudaDataType cscSortedValtype, int * cscSortedRowInd, int * cscSortedColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase, cudaDataType executiontype )
{
  hfinf( "[trapper] cusparseCsr2cscEx() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      const void * csrSortedVal;
      cudaDataType csrSortedValtype;
      const int * csrSortedRowPtr;
      const int * csrSortedColInd;
      void * cscSortedVal;
      cudaDataType cscSortedValtype;
      int * cscSortedRowInd;
      int * cscSortedColPtr;
      cusparseAction_t copyValues;
      cusparseIndexBase_t idxBase;
      cudaDataType executiontype;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCsr2cscEx );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.csrSortedVal = csrSortedVal;
  t2d_msg->data.csrSortedValtype = csrSortedValtype;
  t2d_msg->data.csrSortedRowPtr = csrSortedRowPtr;
  t2d_msg->data.csrSortedColInd = csrSortedColInd;
  t2d_msg->data.cscSortedVal = cscSortedVal;
  t2d_msg->data.cscSortedValtype = cscSortedValtype;
  t2d_msg->data.cscSortedRowInd = cscSortedRowInd;
  t2d_msg->data.cscSortedColPtr = cscSortedColPtr;
  t2d_msg->data.copyValues = copyValues;
  t2d_msg->data.idxBase = idxBase;
  t2d_msg->data.executiontype = executiontype;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCsr2cscEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCsrmvEx ( cusparseHandle_t handle, cusparseAlgMode_t alg, cusparseOperation_t transA, int m, int n, int nnz, const void * alpha, cudaDataType alphatype, cusparseMatDescr_t descrA, const void * csrValA, cudaDataType csrValAtype, const int * csrRowPtrA, const int * csrColIndA, const void * x, cudaDataType xtype, const void * beta, cudaDataType betatype, void * y, cudaDataType ytype, cudaDataType executiontype, void * buffer )
{
  hfinf( "[trapper] cusparseCsrmvEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseAlgMode_t alg;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } alpha;
      cudaDataType alphatype;
      cusparseMatDescr_t descrA;
      const void * csrValA;
      cudaDataType csrValAtype;
      const int * csrRowPtrA;
      const int * csrColIndA;
      const void * x;
      cudaDataType xtype;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } beta;
      cudaDataType betatype;
      void * y;
      cudaDataType ytype;
      cudaDataType executiontype;
      void * buffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCsrmvEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.alg = alg;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (void *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      switch( alphatype ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.alpha.val[0] = *(uint8_t*)alpha;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.alpha.val[0] = *(uint16_t*)alpha;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.alpha.val[0] = *(uint32_t*)alpha;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          *(((uint64_t*)&t2d_msg->data.alpha.val[0]) + 1) = *(((uint64_t*)alpha) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, alphatype);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.alphatype = alphatype;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrValAtype = csrValAtype;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.x = x;
  t2d_msg->data.xtype = xtype;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (void *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      switch( betatype ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.beta.val[0] = *(uint8_t*)beta;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.beta.val[0] = *(uint16_t*)beta;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.beta.val[0] = *(uint32_t*)beta;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.beta.val[0] = *(uint64_t*)beta;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.beta.val[0] = *(uint64_t*)beta;
          *(((uint64_t*)&t2d_msg->data.beta.val[0]) + 1) = *(((uint64_t*)beta) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, betatype);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.betatype = betatype;
  t2d_msg->data.y = y;
  t2d_msg->data.ytype = ytype;
  t2d_msg->data.executiontype = executiontype;
  t2d_msg->data.buffer = buffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCsrmvEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCsrmvEx_bufferSize ( cusparseHandle_t handle, cusparseAlgMode_t alg, cusparseOperation_t transA, int m, int n, int nnz, const void * alpha, cudaDataType alphatype, cusparseMatDescr_t descrA, const void * csrValA, cudaDataType csrValAtype, const int * csrRowPtrA, const int * csrColIndA, const void * x, cudaDataType xtype, const void * beta, cudaDataType betatype, void * y, cudaDataType ytype, cudaDataType executiontype, size_t * bufferSizeInBytes )
{
  hfinf( "[trapper] cusparseCsrmvEx_bufferSize() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseAlgMode_t alg;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } alpha;
      cudaDataType alphatype;
      cusparseMatDescr_t descrA;
      const void * csrValA;
      cudaDataType csrValAtype;
      const int * csrRowPtrA;
      const int * csrColIndA;
      const void * x;
      cudaDataType xtype;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } beta;
      cudaDataType betatype;
      void * y;
      cudaDataType ytype;
      cudaDataType executiontype;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCsrmvEx_bufferSize );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.alg = alg;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (void *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      switch( alphatype ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.alpha.val[0] = *(uint8_t*)alpha;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.alpha.val[0] = *(uint16_t*)alpha;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.alpha.val[0] = *(uint32_t*)alpha;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          *(((uint64_t*)&t2d_msg->data.alpha.val[0]) + 1) = *(((uint64_t*)alpha) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, alphatype);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.alphatype = alphatype;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrValAtype = csrValAtype;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.x = x;
  t2d_msg->data.xtype = xtype;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (void *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      switch( betatype ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.beta.val[0] = *(uint8_t*)beta;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.beta.val[0] = *(uint16_t*)beta;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.beta.val[0] = *(uint32_t*)beta;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.beta.val[0] = *(uint64_t*)beta;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.beta.val[0] = *(uint64_t*)beta;
          *(((uint64_t*)&t2d_msg->data.beta.val[0]) + 1) = *(((uint64_t*)beta) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, betatype);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.betatype = betatype;
  t2d_msg->data.y = y;
  t2d_msg->data.ytype = ytype;
  t2d_msg->data.executiontype = executiontype;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t bufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( bufferSizeInBytes ) *bufferSizeInBytes = d2t_msg.bufferSizeInBytes;
  hfinf( "[trapper] cusparseCsrmvEx_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCsrsv_analysisEx ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const void * csrSortedValA, cudaDataType csrSortedValAtype, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, cudaDataType executiontype )
{
  hfinf( "[trapper] cusparseCsrsv_analysisEx() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const void * csrSortedValA;
      cudaDataType csrSortedValAtype;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
      cudaDataType executiontype;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCsrsv_analysisEx );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedValAtype = csrSortedValAtype;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.executiontype = executiontype;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCsrsv_analysisEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseCsrsv_solveEx ( cusparseHandle_t handle, cusparseOperation_t transA, int m, const void * alpha, cudaDataType alphatype, cusparseMatDescr_t descrA, const void * csrSortedValA, cudaDataType csrSortedValAtype, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const void * f, cudaDataType ftype, void * x, cudaDataType xtype, cudaDataType executiontype )
{
  hfinf( "[trapper] cusparseCsrsv_solveEx() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      union {
        struct {
          char ___dummy0[sizeof(const void *) < sizeof(uint64_t) * 2 ? sizeof(uint64_t) * 2-sizeof(const void *) : 0];
          const void * ptr;
        };
        struct {
          char ___dummy1[sizeof(const void *) > sizeof(uint64_t) * 2 ? sizeof(const void *)-sizeof(uint64_t) * 2 : 0];
          char val[sizeof(uint64_t) * 2] /* support for 64bit complex */;
        };
      } alpha;
      cudaDataType alphatype;
      cusparseMatDescr_t descrA;
      const void * csrSortedValA;
      cudaDataType csrSortedValAtype;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
      const void * f;
      cudaDataType ftype;
      void * x;
      cudaDataType xtype;
      cudaDataType executiontype;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseCsrsv_solveEx );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (void *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      switch( alphatype ) {
        case CUDA_R_8I:
        case CUDA_R_8U: {  // 8bit real
          *(uint8_t*)&t2d_msg->data.alpha.val[0] = *(uint8_t*)alpha;
          break;
        }
        case CUDA_R_16F:
        case CUDA_C_8I:
        case CUDA_C_8U: {  // 8bit complex / 16bit real
          *(uint16_t*)&t2d_msg->data.alpha.val[0] = *(uint16_t*)alpha;
          break;
        }
        case CUDA_C_16F:
        case CUDA_R_32I:
        case CUDA_R_32U:
        case CUDA_R_32F: {  // 16bit complex / 32bit real
          *(uint32_t*)&t2d_msg->data.alpha.val[0] = *(uint32_t*)alpha;
          break;
        }
        case CUDA_C_32I:
        case CUDA_C_32F:
        case CUDA_C_32U:
        case CUDA_R_64F: {  // 32bit complex / 64bit real
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          break;
        }
        case CUDA_C_64F: {  // 64bit complex
          *(uint64_t*)&t2d_msg->data.alpha.val[0] = *(uint64_t*)alpha;
          *(((uint64_t*)&t2d_msg->data.alpha.val[0]) + 1) = *(((uint64_t*)alpha) + 1);
          break;
        }
        default: {
          hferr("ERR (%s:%s:%s): case not supported! %d\n", __FILE__, __LINE__, __FUNCTION__, alphatype);
          exit(-1);
        }
      }
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.alphatype = alphatype;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedValAtype = csrSortedValAtype;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.ftype = ftype;
  t2d_msg->data.x = x;
  t2d_msg->data.xtype = xtype;
  t2d_msg->data.executiontype = executiontype;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseCsrsv_solveEx() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDaxpyi ( cusparseHandle_t handle, int nnz, const double * alpha, const double * xVal, const int * xInd, double * y, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseDaxpyi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * xVal;
      const int * xInd;
      double * y;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDaxpyi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDaxpyi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDbsr2csr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, cusparseMatDescr_t descrC, double * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseDbsr2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      cusparseMatDescr_t descrA;
      const double * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      cusparseMatDescr_t descrC;
      double * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDbsr2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDbsr2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDbsrmm ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int kb, int nnzb, const double * alpha, cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, const int blockSize, const double * B, const int ldb, const double * beta, double * C, int ldc )
{
  hfinf( "[trapper] cusparseDbsrmm() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int mb;
      int n;
      int kb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockSize;
      const double * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDbsrmm );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.kb = kb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDbsrmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDbsrmv ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nb, int nnzb, const double * alpha, cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const double * x, const double * beta, double * y )
{
  hfinf( "[trapper] cusparseDbsrmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      const double * x;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDbsrmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDbsrmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDbsrsm2_analysis ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, cusparseMatDescr_t descrA, const double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseDbsrsm2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      cusparseMatDescr_t descrA;
      const double * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDbsrsm2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDbsrsm2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDbsrsm2_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, cusparseMatDescr_t descrA, double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDbsrsm2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      cusparseMatDescr_t descrA;
      double * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDbsrsm2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDbsrsm2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDbsrsm2_solve ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const double * alpha, cusparseMatDescr_t descrA, const double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, const double * F, int ldf, double * X, int ldx, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseDbsrsm2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
      const double * F;
      int ldf;
      double * X;
      int ldx;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDbsrsm2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  t2d_msg->data.F = F;
  t2d_msg->data.ldf = ldf;
  t2d_msg->data.X = X;
  t2d_msg->data.ldx = ldx;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDbsrsm2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDbsrsv2_analysis ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseDbsrsv2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const double * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDbsrsv2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDbsrsv2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDbsrsv2_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, cusparseMatDescr_t descrA, double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDbsrsv2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      cusparseMatDescr_t descrA;
      double * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDbsrsv2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDbsrsv2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDbsrsv2_solve ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const double * alpha, cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, const double * f, double * x, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseDbsrsv2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
      const double * f;
      double * x;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDbsrsv2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDbsrsv2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDbsrxmv ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int sizeOfMask, int mb, int nb, int nnzb, const double * alpha, cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedMaskPtrA, const int * bsrSortedRowPtrA, const int * bsrSortedEndPtrA, const int * bsrSortedColIndA, int blockDim, const double * x, const double * beta, double * y )
{
  hfinf( "[trapper] cusparseDbsrxmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int sizeOfMask;
      int mb;
      int nb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * bsrSortedValA;
      const int * bsrSortedMaskPtrA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedEndPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      const double * x;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDbsrxmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.sizeOfMask = sizeOfMask;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedMaskPtrA = bsrSortedMaskPtrA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedEndPtrA = bsrSortedEndPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDbsrxmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsc2dense ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const double * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, double * A, int lda )
{
  hfinf( "[trapper] cusparseDcsc2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const double * cscSortedValA;
      const int * cscSortedRowIndA;
      const int * cscSortedColPtrA;
      double * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsc2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsc2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsc2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const double * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseDcsc2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const double * cscSortedValA;
      const int * cscSortedRowIndA;
      const int * cscSortedColPtrA;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsc2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsc2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsr2bsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int blockDim, cusparseMatDescr_t descrC, double * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC )
{
  hfinf( "[trapper] cusparseDcsr2bsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      int blockDim;
      cusparseMatDescr_t descrC;
      double * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsr2bsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsr2bsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsr2csc ( cusparseHandle_t handle, int m, int n, int nnz, const double * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, double * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseDcsr2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      const double * csrSortedVal;
      const int * csrSortedRowPtr;
      const int * csrSortedColInd;
      double * cscSortedVal;
      int * cscSortedRowInd;
      int * cscSortedColPtr;
      cusparseAction_t copyValues;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsr2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.csrSortedVal = csrSortedVal;
  t2d_msg->data.csrSortedRowPtr = csrSortedRowPtr;
  t2d_msg->data.csrSortedColInd = csrSortedColInd;
  t2d_msg->data.cscSortedVal = cscSortedVal;
  t2d_msg->data.cscSortedRowInd = cscSortedRowInd;
  t2d_msg->data.cscSortedColPtr = cscSortedColPtr;
  t2d_msg->data.copyValues = copyValues;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsr2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsr2csr_compress ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descra, const double * csrValA, const int * csrColIndA, const int * csrRowPtrA, int nnzA, const int * nnzPerRow, double * csrValC, int * csrColIndC, int * csrRowPtrC, double tol )
{
  hfinf( "[trapper] cusparseDcsr2csr_compress() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descra;
      const double * csrValA;
      const int * csrColIndA;
      const int * csrRowPtrA;
      int nnzA;
      const int * nnzPerRow;
      double * csrValC;
      int * csrColIndC;
      int * csrRowPtrC;
      double tol;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsr2csr_compress );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descra = descra;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.tol = tol;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsr2csr_compress() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsr2csru ( cusparseHandle_t handle, int m, int n, int nnz, cusparseMatDescr_t descrA, double * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseDcsr2csru() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cusparseMatDescr_t descrA;
      double * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsr2csru );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsr2csru() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsr2dense ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, double * A, int lda )
{
  hfinf( "[trapper] cusparseDcsr2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      double * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsr2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsr2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsr2gebsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrC, double * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDim, int colBlockDim, void * pBuffer )
{
  hfinf( "[trapper] cusparseDcsr2gebsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrC;
      double * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
      int rowBlockDim;
      int colBlockDim;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsr2gebsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsr2gebsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsr2gebsr_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDcsr2gebsr_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      int rowBlockDim;
      int colBlockDim;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsr2gebsr_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDcsr2gebsr_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsr2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseDcsr2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsr2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsr2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrcolor ( cusparseHandle_t handle, int m, int nnz, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * fractionToColor, int * ncolors, int * coloring, int * reordering, cusparseColorInfo_t info )
{
  hfinf( "[trapper] cusparseDcsrcolor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const double * fractionToColor;
      int * coloring;
      int * reordering;
      cusparseColorInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrcolor );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.fractionToColor = fractionToColor;
  t2d_msg->data.coloring = coloring;
  t2d_msg->data.reordering = reordering;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int ncolors;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( ncolors ) *ncolors = d2t_msg.ncolors;
  hfinf( "[trapper] cusparseDcsrcolor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrgeam ( cusparseHandle_t handle, int m, int n, const double * alpha, cusparseMatDescr_t descrA, int nnzA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * beta, cusparseMatDescr_t descrB, int nnzB, const double * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, cusparseMatDescr_t descrC, double * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseDcsrgeam() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cusparseMatDescr_t descrB;
      int nnzB;
      const double * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      cusparseMatDescr_t descrC;
      double * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrgeam );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrgeam() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrgemm ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, cusparseMatDescr_t descrA, int nnzA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const double * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, cusparseMatDescr_t descrC, double * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseDcsrgemm() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int m;
      int n;
      int k;
      cusparseMatDescr_t descrA;
      int nnzA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const double * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      cusparseMatDescr_t descrC;
      double * csrSortedValC;
      const int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrgemm );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrgemm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrgemm2 ( cusparseHandle_t handle, int m, int n, int k, const double * alpha, cusparseMatDescr_t descrA, int nnzA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const double * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const double * beta, cusparseMatDescr_t descrD, int nnzD, const double * csrSortedValD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, cusparseMatDescr_t descrC, double * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, csrgemm2Info_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseDcsrgemm2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const double * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cusparseMatDescr_t descrD;
      int nnzD;
      const double * csrSortedValD;
      const int * csrSortedRowPtrD;
      const int * csrSortedColIndD;
      cusparseMatDescr_t descrC;
      double * csrSortedValC;
      const int * csrSortedRowPtrC;
      int * csrSortedColIndC;
      csrgemm2Info_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrgemm2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrD = descrD;
  t2d_msg->data.nnzD = nnzD;
  t2d_msg->data.csrSortedValD = csrSortedValD;
  t2d_msg->data.csrSortedRowPtrD = csrSortedRowPtrD;
  t2d_msg->data.csrSortedColIndD = csrSortedColIndD;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrgemm2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrgemm2_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int k, const double * alpha, cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const double * beta, cusparseMatDescr_t descrD, int nnzD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, csrgemm2Info_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDcsrgemm2_bufferSizeExt() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      cusparseMatDescr_t descrD;
      int nnzD;
      const int * csrSortedRowPtrD;
      const int * csrSortedColIndD;
      csrgemm2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrgemm2_bufferSizeExt );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrD = descrD;
  t2d_msg->data.nnzD = nnzD;
  t2d_msg->data.csrSortedRowPtrD = csrSortedRowPtrD;
  t2d_msg->data.csrSortedColIndD = csrSortedColIndD;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDcsrgemm2_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrmm ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int k, int nnz, const double * alpha, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * B, int ldb, const double * beta, double * C, int ldc )
{
  hfinf( "[trapper] cusparseDcsrmm() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const double * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrmm );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrmm2 ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, int nnz, const double * alpha, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * B, int ldb, const double * beta, double * C, int ldc )
{
  hfinf( "[trapper] cusparseDcsrmm2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const double * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrmm2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrmm2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrmv ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const double * alpha, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * x, const double * beta, double * y )
{
  hfinf( "[trapper] cusparseDcsrmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const double * x;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrmv_mp ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const double * alpha, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * x, const double * beta, double * y )
{
  hfinf( "[trapper] cusparseDcsrmv_mp() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const double * x;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrmv_mp );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrmv_mp() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrsm_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseDcsrsm_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrsm_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrsm_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrsm_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const double * alpha, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const double * F, int ldf, double * X, int ldx )
{
  hfinf( "[trapper] cusparseDcsrsm_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
      const double * F;
      int ldf;
      double * X;
      int ldx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrsm_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.F = F;
  t2d_msg->data.ldf = ldf;
  t2d_msg->data.X = X;
  t2d_msg->data.ldx = ldx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrsm_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrsv2_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseDcsrsv2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrsv2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrsv2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrsv2_bufferSize ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDcsrsv2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrsv2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDcsrsv2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrsv2_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const double * alpha, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, const double * f, double * x, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseDcsrsv2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
      const double * f;
      double * x;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrsv2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrsv2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrsv_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseDcsrsv_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrsv_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrsv_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsrsv_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, const double * alpha, cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const double * f, double * x )
{
  hfinf( "[trapper] cusparseDcsrsv_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const double * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
      const double * f;
      double * x;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsrsv_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsrsv_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsru2csr ( cusparseHandle_t handle, int m, int n, int nnz, cusparseMatDescr_t descrA, double * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseDcsru2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cusparseMatDescr_t descrA;
      double * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsru2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDcsru2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDcsru2csr_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int nnz, double * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDcsru2csr_bufferSizeExt() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      double * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDcsru2csr_bufferSizeExt );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDcsru2csr_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDdense2csc ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const double * A, int lda, const int * nnzPerCol, double * cscSortedValA, int * cscSortedRowIndA, int * cscSortedColPtrA )
{
  hfinf( "[trapper] cusparseDdense2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const double * A;
      int lda;
      const int * nnzPerCol;
      double * cscSortedValA;
      int * cscSortedRowIndA;
      int * cscSortedColPtrA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDdense2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerCol = nnzPerCol;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDdense2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDdense2csr ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const double * A, int lda, const int * nnzPerRow, double * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA )
{
  hfinf( "[trapper] cusparseDdense2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const double * A;
      int lda;
      const int * nnzPerRow;
      double * csrSortedValA;
      int * csrSortedRowPtrA;
      int * csrSortedColIndA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDdense2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDdense2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDdense2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const double * A, int lda, const int * nnzPerRow, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseDdense2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const double * A;
      int lda;
      const int * nnzPerRow;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDdense2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDdense2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDdoti ( cusparseHandle_t handle, int nnz, const double * xVal, const int * xInd, const double * y, double * resultDevHostPtr, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseDdoti() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int nnz;
      const double * xVal;
      const int * xInd;
      const double * y;
      double * resultDevHostPtr;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDdoti );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.resultDevHostPtr = resultDevHostPtr;
  if( resultDevHostPtr ) {
    hfcuda_am_node_t* _____resultDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (double *) resultDevHostPtr, devId );
    uint8_t _____resultDevHostPtr_PASSONHOST = ! (_____resultDevHostPtr_MEMCHECK && _____resultDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____resultDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    double resultDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( resultDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *resultDevHostPtr = d2t_msg.resultDevHostPtr;
  }
  hfinf( "[trapper] cusparseDdoti() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroy ( cusparseHandle_t handle )
{
  hfinf( "[trapper] cusparseDestroy() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroy );
  t2d_msg->data.handle = handle;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroy() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyBsric02Info ( bsric02Info_t info )
{
  hfinf( "[trapper] cusparseDestroyBsric02Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      bsric02Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyBsric02Info );
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyBsric02Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyBsrilu02Info ( bsrilu02Info_t info )
{
  hfinf( "[trapper] cusparseDestroyBsrilu02Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      bsrilu02Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyBsrilu02Info );
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyBsrilu02Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyBsrsm2Info ( bsrsm2Info_t info )
{
  hfinf( "[trapper] cusparseDestroyBsrsm2Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      bsrsm2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyBsrsm2Info );
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyBsrsm2Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyBsrsv2Info ( bsrsv2Info_t info )
{
  hfinf( "[trapper] cusparseDestroyBsrsv2Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      bsrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyBsrsv2Info );
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyBsrsv2Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyCsrgemm2Info ( csrgemm2Info_t info )
{
  hfinf( "[trapper] cusparseDestroyCsrgemm2Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      csrgemm2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyCsrgemm2Info );
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyCsrgemm2Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyCsric02Info ( csric02Info_t info )
{
  hfinf( "[trapper] cusparseDestroyCsric02Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      csric02Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyCsric02Info );
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyCsric02Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyCsrilu02Info ( csrilu02Info_t info )
{
  hfinf( "[trapper] cusparseDestroyCsrilu02Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      csrilu02Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyCsrilu02Info );
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyCsrilu02Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyCsrsv2Info ( csrsv2Info_t info )
{
  hfinf( "[trapper] cusparseDestroyCsrsv2Info() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      csrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyCsrsv2Info );
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyCsrsv2Info() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyCsru2csrInfo ( csru2csrInfo_t info )
{
  hfinf( "[trapper] cusparseDestroyCsru2csrInfo() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      csru2csrInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyCsru2csrInfo );
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyCsru2csrInfo() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyHybMat ( cusparseHybMat_t hybA )
{
  hfinf( "[trapper] cusparseDestroyHybMat() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHybMat_t hybA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyHybMat );
  t2d_msg->data.hybA = hybA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyHybMat() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyMatDescr ( cusparseMatDescr_t descrA )
{
  hfinf( "[trapper] cusparseDestroyMatDescr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseMatDescr_t descrA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyMatDescr );
  t2d_msg->data.descrA = descrA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyMatDescr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroyPruneInfo ( pruneInfo_t info )
{
  hfinf( "[trapper] cusparseDestroyPruneInfo() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      pruneInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroyPruneInfo );
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroyPruneInfo() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDestroySolveAnalysisInfo ( cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseDestroySolveAnalysisInfo() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDestroySolveAnalysisInfo );
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDestroySolveAnalysisInfo() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDgebsr2csr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDim, int colBlockDim, cusparseMatDescr_t descrC, double * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseDgebsr2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      cusparseMatDescr_t descrA;
      const double * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDim;
      int colBlockDim;
      cusparseMatDescr_t descrC;
      double * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDgebsr2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDgebsr2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDgebsr2gebsc ( cusparseHandle_t handle, int mb, int nb, int nnzb, const double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, double * bscVal, int * bscRowInd, int * bscColPtr, cusparseAction_t copyValues, cusparseIndexBase_t baseIdx, void * pBuffer )
{
  hfinf( "[trapper] cusparseDgebsr2gebsc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int mb;
      int nb;
      int nnzb;
      const double * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int rowBlockDim;
      int colBlockDim;
      double * bscVal;
      int * bscRowInd;
      int * bscColPtr;
      cusparseAction_t copyValues;
      cusparseIndexBase_t baseIdx;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDgebsr2gebsc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.bscVal = bscVal;
  t2d_msg->data.bscRowInd = bscRowInd;
  t2d_msg->data.bscColPtr = bscColPtr;
  t2d_msg->data.copyValues = copyValues;
  t2d_msg->data.baseIdx = baseIdx;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDgebsr2gebsc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDgebsr2gebsc_bufferSize ( cusparseHandle_t handle, int mb, int nb, int nnzb, const double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDgebsr2gebsc_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int mb;
      int nb;
      int nnzb;
      const double * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int rowBlockDim;
      int colBlockDim;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDgebsr2gebsc_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDgebsr2gebsc_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDgebsr2gebsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, cusparseMatDescr_t descrC, double * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDimC, int colBlockDimC, void * pBuffer )
{
  hfinf( "[trapper] cusparseDgebsr2gebsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const double * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDimA;
      int colBlockDimA;
      cusparseMatDescr_t descrC;
      double * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
      int rowBlockDimC;
      int colBlockDimC;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDgebsr2gebsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDimA = rowBlockDimA;
  t2d_msg->data.colBlockDimA = colBlockDimA;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  t2d_msg->data.rowBlockDimC = rowBlockDimC;
  t2d_msg->data.colBlockDimC = colBlockDimC;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDgebsr2gebsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDgebsr2gebsr_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDgebsr2gebsr_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const double * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDimA;
      int colBlockDimA;
      int rowBlockDimC;
      int colBlockDimC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDgebsr2gebsr_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDimA = rowBlockDimA;
  t2d_msg->data.colBlockDimA = colBlockDimA;
  t2d_msg->data.rowBlockDimC = rowBlockDimC;
  t2d_msg->data.colBlockDimC = colBlockDimC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDgebsr2gebsr_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDgemmi ( cusparseHandle_t handle, int m, int n, int k, int nnz, const double * alpha, const double * A, int lda, const double * cscValB, const int * cscColPtrB, const int * cscRowIndB, const double * beta, double * C, int ldc )
{
  hfinf( "[trapper] cusparseDgemmi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      const double * cscValB;
      const int * cscColPtrB;
      const int * cscRowIndB;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDgemmi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.cscValB = cscValB;
  t2d_msg->data.cscColPtrB = cscColPtrB;
  t2d_msg->data.cscRowIndB = cscRowIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDgemmi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDgemvi ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const double * alpha, const double * A, int lda, int nnz, const double * xVal, const int * xInd, const double * beta, double * y, cusparseIndexBase_t idxBase, void * pBuffer )
{
  hfinf( "[trapper] cusparseDgemvi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      const double * A;
      int lda;
      int nnz;
      const double * xVal;
      const int * xInd;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * y;
      cusparseIndexBase_t idxBase;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDgemvi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDgemvi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDgemvi_bufferSize ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, int * pBufferSize )
{
  hfinf( "[trapper] cusparseDgemvi_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDgemvi_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSize;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSize ) *pBufferSize = d2t_msg.pBufferSize;
  hfinf( "[trapper] cusparseDgemvi_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDgthr ( cusparseHandle_t handle, int nnz, const double * y, double * xVal, const int * xInd, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseDgthr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      const double * y;
      double * xVal;
      const int * xInd;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDgthr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.y = y;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDgthr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDgthrz ( cusparseHandle_t handle, int nnz, double * y, double * xVal, const int * xInd, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseDgthrz() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      double * y;
      double * xVal;
      const int * xInd;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDgthrz );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.y = y;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDgthrz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDhyb2csc ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, double * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr )
{
  hfinf( "[trapper] cusparseDhyb2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      double * cscSortedVal;
      int * cscSortedRowInd;
      int * cscSortedColPtr;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDhyb2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.cscSortedVal = cscSortedVal;
  t2d_msg->data.cscSortedRowInd = cscSortedRowInd;
  t2d_msg->data.cscSortedColPtr = cscSortedColPtr;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDhyb2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDhyb2csr ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, double * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA )
{
  hfinf( "[trapper] cusparseDhyb2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      double * csrSortedValA;
      int * csrSortedRowPtrA;
      int * csrSortedColIndA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDhyb2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDhyb2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDhyb2dense ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, double * A, int lda )
{
  hfinf( "[trapper] cusparseDhyb2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      double * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDhyb2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDhyb2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDhybmv ( cusparseHandle_t handle, cusparseOperation_t transA, const double * alpha, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, const double * x, const double * beta, double * y )
{
  hfinf( "[trapper] cusparseDhybmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      const double * x;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } beta;
      double * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDhybmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (double *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDhybmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDhybsv_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseDhybsv_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDhybsv_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDhybsv_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDhybsv_solve ( cusparseHandle_t handle, cusparseOperation_t trans, const double * alpha, cusparseMatDescr_t descra, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info, const double * f, double * x )
{
  hfinf( "[trapper] cusparseDhybsv_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t trans;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } alpha;
      cusparseMatDescr_t descra;
      cusparseHybMat_t hybA;
      cusparseSolveAnalysisInfo_t info;
      const double * f;
      double * x;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDhybsv_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (double *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descra = descra;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDhybsv_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDnnz ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const double * A, int lda, int * nnzPerRowCol, int * nnzTotalDevHostPtr )
{
  hfinf( "[trapper] cusparseDnnz() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const double * A;
      int lda;
      int * nnzPerRowCol;
      int * nnzTotalDevHostPtr;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDnnz );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRowCol = nnzPerRowCol;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseDnnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDnnz_compress ( cusparseHandle_t handle, int m, cusparseMatDescr_t descr, const double * csrValA, const int * csrRowPtrA, int * nnzPerRow, int * nnzC, double tol )
{
  hfinf( "[trapper] cusparseDnnz_compress() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      cusparseMatDescr_t descr;
      const double * csrValA;
      const int * csrRowPtrA;
      int * nnzPerRow;
      int * nnzC;
      double tol;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDnnz_compress );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.descr = descr;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.nnzC = nnzC;
  t2d_msg->data.tol = tol;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDnnz_compress() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneCsr2csr ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const double * csrValA, const int * csrRowPtrA, const int * csrColIndA, const double * threshold, cusparseMatDescr_t descrC, double * csrValC, const int * csrRowPtrC, int * csrColIndC, void * pBuffer )
{
  hfinf( "[trapper] cusparseDpruneCsr2csr() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const double * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      double * csrValC;
      const int * csrRowPtrC;
      int * csrColIndC;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneCsr2csr );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (double *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDpruneCsr2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneCsr2csrByPercentage ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const double * csrValA, const int * csrRowPtrA, const int * csrColIndA, float percentage, cusparseMatDescr_t descrC, double * csrValC, const int * csrRowPtrC, int * csrColIndC, pruneInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseDpruneCsr2csrByPercentage() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const double * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      float percentage;
      cusparseMatDescr_t descrC;
      double * csrValC;
      const int * csrRowPtrC;
      int * csrColIndC;
      pruneInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneCsr2csrByPercentage );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDpruneCsr2csrByPercentage() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneCsr2csrByPercentage_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const double * csrValA, const int * csrRowPtrA, const int * csrColIndA, float percentage, cusparseMatDescr_t descrC, const double * csrValC, const int * csrRowPtrC, const int * csrColIndC, pruneInfo_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDpruneCsr2csrByPercentage_bufferSizeExt() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const double * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      float percentage;
      cusparseMatDescr_t descrC;
      const double * csrValC;
      const int * csrRowPtrC;
      const int * csrColIndC;
      pruneInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneCsr2csrByPercentage_bufferSizeExt );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDpruneCsr2csrByPercentage_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneCsr2csrNnz ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const double * csrValA, const int * csrRowPtrA, const int * csrColIndA, const double * threshold, cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, void * pBuffer )
{
  hfinf( "[trapper] cusparseDpruneCsr2csrNnz() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const double * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      int * csrRowPtrC;
      int * nnzTotalDevHostPtr;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneCsr2csrNnz );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (double *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 1);
  }
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 1) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseDpruneCsr2csrNnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneCsr2csrNnzByPercentage ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const double * csrValA, const int * csrRowPtrA, const int * csrColIndA, float percentage, cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, pruneInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseDpruneCsr2csrNnzByPercentage() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const double * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      float percentage;
      cusparseMatDescr_t descrC;
      int * csrRowPtrC;
      int * nnzTotalDevHostPtr;
      pruneInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneCsr2csrNnzByPercentage );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseDpruneCsr2csrNnzByPercentage() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneCsr2csr_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const double * csrValA, const int * csrRowPtrA, const int * csrColIndA, const double * threshold, cusparseMatDescr_t descrC, const double * csrValC, const int * csrRowPtrC, const int * csrColIndC, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDpruneCsr2csr_bufferSizeExt() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const double * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      const double * csrValC;
      const int * csrRowPtrC;
      const int * csrColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneCsr2csr_bufferSizeExt );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (double *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDpruneCsr2csr_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneDense2csr ( cusparseHandle_t handle, int m, int n, const double * A, int lda, const double * threshold, cusparseMatDescr_t descrC, double * csrValC, const int * csrRowPtrC, int * csrColIndC, void * pBuffer )
{
  hfinf( "[trapper] cusparseDpruneDense2csr() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      const double * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      double * csrValC;
      const int * csrRowPtrC;
      int * csrColIndC;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneDense2csr );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (double *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDpruneDense2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneDense2csrByPercentage ( cusparseHandle_t handle, int m, int n, const double * A, int lda, float percentage, cusparseMatDescr_t descrC, double * csrValC, const int * csrRowPtrC, int * csrColIndC, pruneInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseDpruneDense2csrByPercentage() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      const double * A;
      int lda;
      float percentage;
      cusparseMatDescr_t descrC;
      double * csrValC;
      const int * csrRowPtrC;
      int * csrColIndC;
      pruneInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneDense2csrByPercentage );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDpruneDense2csrByPercentage() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneDense2csrByPercentage_bufferSizeExt ( cusparseHandle_t handle, int m, int n, const double * A, int lda, float percentage, cusparseMatDescr_t descrC, const double * csrValC, const int * csrRowPtrC, const int * csrColIndC, pruneInfo_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDpruneDense2csrByPercentage_bufferSizeExt() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      const double * A;
      int lda;
      float percentage;
      cusparseMatDescr_t descrC;
      const double * csrValC;
      const int * csrRowPtrC;
      const int * csrColIndC;
      pruneInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneDense2csrByPercentage_bufferSizeExt );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDpruneDense2csrByPercentage_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneDense2csrNnz ( cusparseHandle_t handle, int m, int n, const double * A, int lda, const double * threshold, cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, void * pBuffer )
{
  hfinf( "[trapper] cusparseDpruneDense2csrNnz() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      const double * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      int * csrRowPtrC;
      int * nnzTotalDevHostPtr;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneDense2csrNnz );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (double *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 1);
  }
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 1) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseDpruneDense2csrNnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneDense2csrNnzByPercentage ( cusparseHandle_t handle, int m, int n, const double * A, int lda, float percentage, cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, pruneInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseDpruneDense2csrNnzByPercentage() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      const double * A;
      int lda;
      float percentage;
      cusparseMatDescr_t descrC;
      int * csrRowPtrC;
      int * nnzTotalDevHostPtr;
      pruneInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneDense2csrNnzByPercentage );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseDpruneDense2csrNnzByPercentage() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDpruneDense2csr_bufferSizeExt ( cusparseHandle_t handle, int m, int n, const double * A, int lda, const double * threshold, cusparseMatDescr_t descrC, const double * csrValC, const int * csrRowPtrC, const int * csrColIndC, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseDpruneDense2csr_bufferSizeExt() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      const double * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const double *) < sizeof(double) ? sizeof(double)-sizeof(const double *) : 0];
          const double * ptr;
        };
        struct {
          char ___dummy1[sizeof(const double *) > sizeof(double) ? sizeof(const double *)-sizeof(double) : 0];
          double val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      const double * csrValC;
      const int * csrRowPtrC;
      const int * csrColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDpruneDense2csr_bufferSizeExt );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (double *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseDpruneDense2csr_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDroti ( cusparseHandle_t handle, int nnz, double * xVal, const int * xInd, double * y, const double * c, const double * s, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseDroti() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      double * xVal;
      const int * xInd;
      double * y;
      const double * c;
      const double * s;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDroti );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.c = c;
  t2d_msg->data.s = s;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDroti() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseDsctr ( cusparseHandle_t handle, int nnz, const double * xVal, const int * xInd, double * y, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseDsctr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      const double * xVal;
      const int * xInd;
      double * y;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseDsctr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseDsctr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseDiagType_t
cusparseGetMatDiagType ( cusparseMatDescr_t descrA )
{
  hfinf( "[trapper] cusparseGetMatDiagType() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseMatDescr_t descrA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseGetMatDiagType );
  t2d_msg->data.descrA = descrA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseDiagType_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseGetMatDiagType() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseFillMode_t
cusparseGetMatFillMode ( cusparseMatDescr_t descrA )
{
  hfinf( "[trapper] cusparseGetMatFillMode() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseMatDescr_t descrA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseGetMatFillMode );
  t2d_msg->data.descrA = descrA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseFillMode_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseGetMatFillMode() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseIndexBase_t
cusparseGetMatIndexBase ( cusparseMatDescr_t descrA )
{
  hfinf( "[trapper] cusparseGetMatIndexBase() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseMatDescr_t descrA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseGetMatIndexBase );
  t2d_msg->data.descrA = descrA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseIndexBase_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseGetMatIndexBase() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseMatrixType_t
cusparseGetMatType ( cusparseMatDescr_t descrA )
{
  hfinf( "[trapper] cusparseGetMatType() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseMatDescr_t descrA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseGetMatType );
  t2d_msg->data.descrA = descrA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseMatrixType_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseGetMatType() [DONE]\n" );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseGetStream ( cusparseHandle_t handle, cudaStream_t * streamId )
{
  hfinf( "[trapper] cusparseGetStream() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseGetStream );
  t2d_msg->data.handle = handle;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    cudaStream_t streamId;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( streamId ) *streamId = d2t_msg.streamId;
  hfinf( "[trapper] cusparseGetStream() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseGetVersion ( cusparseHandle_t handle, int * version )
{
  hfinf( "[trapper] cusparseGetVersion() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseGetVersion );
  t2d_msg->data.handle = handle;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int version;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( version ) *version = d2t_msg.version;
  hfinf( "[trapper] cusparseGetVersion() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSaxpyi ( cusparseHandle_t handle, int nnz, const float * alpha, const float * xVal, const int * xInd, float * y, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseSaxpyi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * xVal;
      const int * xInd;
      float * y;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSaxpyi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSaxpyi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSbsr2csr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, cusparseMatDescr_t descrC, float * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseSbsr2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      cusparseMatDescr_t descrA;
      const float * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      cusparseMatDescr_t descrC;
      float * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSbsr2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSbsr2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSbsrmm ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int kb, int nnzb, const float * alpha, cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, const int blockSize, const float * B, const int ldb, const float * beta, float * C, int ldc )
{
  hfinf( "[trapper] cusparseSbsrmm() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int mb;
      int n;
      int kb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockSize;
      const float * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSbsrmm );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.kb = kb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSbsrmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSbsrmv ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nb, int nnzb, const float * alpha, cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const float * x, const float * beta, float * y )
{
  hfinf( "[trapper] cusparseSbsrmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      const float * x;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSbsrmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSbsrmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSbsrsm2_analysis ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, cusparseMatDescr_t descrA, const float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseSbsrsm2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      cusparseMatDescr_t descrA;
      const float * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSbsrsm2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSbsrsm2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSbsrsm2_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, cusparseMatDescr_t descrA, float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseSbsrsm2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      cusparseMatDescr_t descrA;
      float * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSbsrsm2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseSbsrsm2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSbsrsm2_solve ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const float * alpha, cusparseMatDescr_t descrA, const float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, const float * F, int ldf, float * X, int ldx, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseSbsrsm2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
      const float * F;
      int ldf;
      float * X;
      int ldx;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSbsrsm2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  t2d_msg->data.F = F;
  t2d_msg->data.ldf = ldf;
  t2d_msg->data.X = X;
  t2d_msg->data.ldx = ldx;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSbsrsm2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSbsrsv2_analysis ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseSbsrsv2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const float * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSbsrsv2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSbsrsv2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSbsrsv2_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, cusparseMatDescr_t descrA, float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseSbsrsv2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      cusparseMatDescr_t descrA;
      float * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSbsrsv2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseSbsrsv2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSbsrsv2_solve ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const float * alpha, cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, const float * f, float * x, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseSbsrsv2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
      const float * f;
      float * x;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSbsrsv2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSbsrsv2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSbsrxmv ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int sizeOfMask, int mb, int nb, int nnzb, const float * alpha, cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedMaskPtrA, const int * bsrSortedRowPtrA, const int * bsrSortedEndPtrA, const int * bsrSortedColIndA, int blockDim, const float * x, const float * beta, float * y )
{
  hfinf( "[trapper] cusparseSbsrxmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int sizeOfMask;
      int mb;
      int nb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * bsrSortedValA;
      const int * bsrSortedMaskPtrA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedEndPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      const float * x;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSbsrxmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.sizeOfMask = sizeOfMask;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedMaskPtrA = bsrSortedMaskPtrA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedEndPtrA = bsrSortedEndPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSbsrxmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsc2dense ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const float * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, float * A, int lda )
{
  hfinf( "[trapper] cusparseScsc2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const float * cscSortedValA;
      const int * cscSortedRowIndA;
      const int * cscSortedColPtrA;
      float * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsc2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsc2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsc2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const float * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseScsc2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const float * cscSortedValA;
      const int * cscSortedRowIndA;
      const int * cscSortedColPtrA;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsc2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsc2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsr2bsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int blockDim, cusparseMatDescr_t descrC, float * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC )
{
  hfinf( "[trapper] cusparseScsr2bsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      int blockDim;
      cusparseMatDescr_t descrC;
      float * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsr2bsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsr2bsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsr2csc ( cusparseHandle_t handle, int m, int n, int nnz, const float * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, float * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseScsr2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      const float * csrSortedVal;
      const int * csrSortedRowPtr;
      const int * csrSortedColInd;
      float * cscSortedVal;
      int * cscSortedRowInd;
      int * cscSortedColPtr;
      cusparseAction_t copyValues;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsr2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.csrSortedVal = csrSortedVal;
  t2d_msg->data.csrSortedRowPtr = csrSortedRowPtr;
  t2d_msg->data.csrSortedColInd = csrSortedColInd;
  t2d_msg->data.cscSortedVal = cscSortedVal;
  t2d_msg->data.cscSortedRowInd = cscSortedRowInd;
  t2d_msg->data.cscSortedColPtr = cscSortedColPtr;
  t2d_msg->data.copyValues = copyValues;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsr2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsr2csr_compress ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descra, const float * csrValA, const int * csrColIndA, const int * csrRowPtrA, int nnzA, const int * nnzPerRow, float * csrValC, int * csrColIndC, int * csrRowPtrC, float tol )
{
  hfinf( "[trapper] cusparseScsr2csr_compress() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descra;
      const float * csrValA;
      const int * csrColIndA;
      const int * csrRowPtrA;
      int nnzA;
      const int * nnzPerRow;
      float * csrValC;
      int * csrColIndC;
      int * csrRowPtrC;
      float tol;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsr2csr_compress );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descra = descra;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.tol = tol;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsr2csr_compress() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsr2csru ( cusparseHandle_t handle, int m, int n, int nnz, cusparseMatDescr_t descrA, float * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseScsr2csru() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cusparseMatDescr_t descrA;
      float * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsr2csru );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsr2csru() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsr2dense ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float * A, int lda )
{
  hfinf( "[trapper] cusparseScsr2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      float * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsr2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsr2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsr2gebsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrC, float * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDim, int colBlockDim, void * pBuffer )
{
  hfinf( "[trapper] cusparseScsr2gebsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrC;
      float * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
      int rowBlockDim;
      int colBlockDim;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsr2gebsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsr2gebsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsr2gebsr_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseScsr2gebsr_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      int rowBlockDim;
      int colBlockDim;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsr2gebsr_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseScsr2gebsr_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsr2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseScsr2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsr2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsr2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrcolor ( cusparseHandle_t handle, int m, int nnz, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * fractionToColor, int * ncolors, int * coloring, int * reordering, cusparseColorInfo_t info )
{
  hfinf( "[trapper] cusparseScsrcolor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const float * fractionToColor;
      int * coloring;
      int * reordering;
      cusparseColorInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrcolor );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.fractionToColor = fractionToColor;
  t2d_msg->data.coloring = coloring;
  t2d_msg->data.reordering = reordering;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int ncolors;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( ncolors ) *ncolors = d2t_msg.ncolors;
  hfinf( "[trapper] cusparseScsrcolor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrgeam ( cusparseHandle_t handle, int m, int n, const float * alpha, cusparseMatDescr_t descrA, int nnzA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * beta, cusparseMatDescr_t descrB, int nnzB, const float * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, cusparseMatDescr_t descrC, float * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseScsrgeam() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      cusparseMatDescr_t descrB;
      int nnzB;
      const float * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      cusparseMatDescr_t descrC;
      float * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrgeam );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrgeam() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrgemm ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, cusparseMatDescr_t descrA, const int nnzA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, const int nnzB, const float * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, cusparseMatDescr_t descrC, float * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseScsrgemm() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int m;
      int n;
      int k;
      cusparseMatDescr_t descrA;
      int nnzA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const float * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      cusparseMatDescr_t descrC;
      float * csrSortedValC;
      const int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrgemm );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrgemm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrgemm2 ( cusparseHandle_t handle, int m, int n, int k, const float * alpha, cusparseMatDescr_t descrA, int nnzA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const float * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const float * beta, cusparseMatDescr_t descrD, int nnzD, const float * csrSortedValD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, cusparseMatDescr_t descrC, float * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, csrgemm2Info_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseScsrgemm2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const float * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      cusparseMatDescr_t descrD;
      int nnzD;
      const float * csrSortedValD;
      const int * csrSortedRowPtrD;
      const int * csrSortedColIndD;
      cusparseMatDescr_t descrC;
      float * csrSortedValC;
      const int * csrSortedRowPtrC;
      int * csrSortedColIndC;
      csrgemm2Info_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrgemm2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrD = descrD;
  t2d_msg->data.nnzD = nnzD;
  t2d_msg->data.csrSortedValD = csrSortedValD;
  t2d_msg->data.csrSortedRowPtrD = csrSortedRowPtrD;
  t2d_msg->data.csrSortedColIndD = csrSortedColIndD;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrgemm2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrgemm2_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int k, const float * alpha, cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const float * beta, cusparseMatDescr_t descrD, int nnzD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, csrgemm2Info_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseScsrgemm2_bufferSizeExt() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      cusparseMatDescr_t descrD;
      int nnzD;
      const int * csrSortedRowPtrD;
      const int * csrSortedColIndD;
      csrgemm2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrgemm2_bufferSizeExt );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrD = descrD;
  t2d_msg->data.nnzD = nnzD;
  t2d_msg->data.csrSortedRowPtrD = csrSortedRowPtrD;
  t2d_msg->data.csrSortedColIndD = csrSortedColIndD;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseScsrgemm2_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrmm ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int k, int nnz, const float * alpha, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * B, int ldb, const float * beta, float * C, int ldc )
{
  hfinf( "[trapper] cusparseScsrmm() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const float * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrmm );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrmm2 ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, int nnz, const float * alpha, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * B, int ldb, const float * beta, float * C, int ldc )
{
  hfinf( "[trapper] cusparseScsrmm2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const float * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrmm2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrmm2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrmv ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const float * alpha, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * x, const float * beta, float * y )
{
  hfinf( "[trapper] cusparseScsrmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const float * x;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrmv_mp ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const float * alpha, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * x, const float * beta, float * y )
{
  hfinf( "[trapper] cusparseScsrmv_mp() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const float * x;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrmv_mp );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrmv_mp() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrsm_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseScsrsm_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrsm_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrsm_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrsm_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const float * alpha, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const float * F, int ldf, float * X, int ldx )
{
  hfinf( "[trapper] cusparseScsrsm_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
      const float * F;
      int ldf;
      float * X;
      int ldx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrsm_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.F = F;
  t2d_msg->data.ldf = ldf;
  t2d_msg->data.X = X;
  t2d_msg->data.ldx = ldx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrsm_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrsv2_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseScsrsv2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrsv2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrsv2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrsv2_bufferSize ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseScsrsv2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrsv2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseScsrsv2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrsv2_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const float * alpha, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, const float * f, float * x, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseScsrsv2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
      const float * f;
      float * x;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrsv2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrsv2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrsv_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseScsrsv_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrsv_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrsv_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsrsv_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, const float * alpha, cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const float * f, float * x )
{
  hfinf( "[trapper] cusparseScsrsv_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const float * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
      const float * f;
      float * x;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsrsv_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsrsv_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsru2csr ( cusparseHandle_t handle, int m, int n, int nnz, cusparseMatDescr_t descrA, float * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseScsru2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cusparseMatDescr_t descrA;
      float * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsru2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseScsru2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseScsru2csr_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int nnz, float * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseScsru2csr_bufferSizeExt() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      float * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseScsru2csr_bufferSizeExt );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseScsru2csr_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSdense2csc ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const float * A, int lda, const int * nnzPerCol, float * cscSortedValA, int * cscSortedRowIndA, int * cscSortedColPtrA )
{
  hfinf( "[trapper] cusparseSdense2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const float * A;
      int lda;
      const int * nnzPerCol;
      float * cscSortedValA;
      int * cscSortedRowIndA;
      int * cscSortedColPtrA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSdense2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerCol = nnzPerCol;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSdense2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSdense2csr ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const float * A, int lda, const int * nnzPerRow, float * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA )
{
  hfinf( "[trapper] cusparseSdense2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const float * A;
      int lda;
      const int * nnzPerRow;
      float * csrSortedValA;
      int * csrSortedRowPtrA;
      int * csrSortedColIndA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSdense2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSdense2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSdense2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const float * A, int lda, const int * nnzPerRow, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseSdense2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const float * A;
      int lda;
      const int * nnzPerRow;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSdense2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSdense2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSdoti ( cusparseHandle_t handle, int nnz, const float * xVal, const int * xInd, const float * y, float * resultDevHostPtr, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseSdoti() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int nnz;
      const float * xVal;
      const int * xInd;
      const float * y;
      float * resultDevHostPtr;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSdoti );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.resultDevHostPtr = resultDevHostPtr;
  if( resultDevHostPtr ) {
    hfcuda_am_node_t* _____resultDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (float *) resultDevHostPtr, devId );
    uint8_t _____resultDevHostPtr_PASSONHOST = ! (_____resultDevHostPtr_MEMCHECK && _____resultDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____resultDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    float resultDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( resultDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *resultDevHostPtr = d2t_msg.resultDevHostPtr;
  }
  hfinf( "[trapper] cusparseSdoti() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSetMatDiagType ( cusparseMatDescr_t descrA, cusparseDiagType_t diagType )
{
  hfinf( "[trapper] cusparseSetMatDiagType() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseMatDescr_t descrA;
      cusparseDiagType_t diagType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSetMatDiagType );
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.diagType = diagType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSetMatDiagType() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSetMatFillMode ( cusparseMatDescr_t descrA, cusparseFillMode_t fillMode )
{
  hfinf( "[trapper] cusparseSetMatFillMode() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseMatDescr_t descrA;
      cusparseFillMode_t fillMode;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSetMatFillMode );
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.fillMode = fillMode;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSetMatFillMode() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSetMatIndexBase ( cusparseMatDescr_t descrA, cusparseIndexBase_t base )
{
  hfinf( "[trapper] cusparseSetMatIndexBase() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseMatDescr_t descrA;
      cusparseIndexBase_t base;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSetMatIndexBase );
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.base = base;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSetMatIndexBase() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSetMatType ( cusparseMatDescr_t descrA, cusparseMatrixType_t type )
{
  hfinf( "[trapper] cusparseSetMatType() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseMatDescr_t descrA;
      cusparseMatrixType_t type;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSetMatType );
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.type = type;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSetMatType() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSetPointerMode ( cusparseHandle_t handle, cusparsePointerMode_t mode )
{
  hfinf( "[trapper] cusparseSetPointerMode() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparsePointerMode_t mode;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSetPointerMode );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mode = mode;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSetPointerMode() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSetStream ( cusparseHandle_t handle, cudaStream_t streamId )
{
  hfinf( "[trapper] cusparseSetStream() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cudaStream_t streamId;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSetStream );
  t2d_msg->data.handle = handle;
  t2d_msg->data.streamId = streamId;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSetStream() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSgebsr2csr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDim, int colBlockDim, cusparseMatDescr_t descrC, float * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseSgebsr2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      cusparseMatDescr_t descrA;
      const float * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDim;
      int colBlockDim;
      cusparseMatDescr_t descrC;
      float * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSgebsr2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSgebsr2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSgebsr2gebsc ( cusparseHandle_t handle, int mb, int nb, int nnzb, const float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, float * bscVal, int * bscRowInd, int * bscColPtr, cusparseAction_t copyValues, cusparseIndexBase_t baseIdx, void * pBuffer )
{
  hfinf( "[trapper] cusparseSgebsr2gebsc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int mb;
      int nb;
      int nnzb;
      const float * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int rowBlockDim;
      int colBlockDim;
      float * bscVal;
      int * bscRowInd;
      int * bscColPtr;
      cusparseAction_t copyValues;
      cusparseIndexBase_t baseIdx;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSgebsr2gebsc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.bscVal = bscVal;
  t2d_msg->data.bscRowInd = bscRowInd;
  t2d_msg->data.bscColPtr = bscColPtr;
  t2d_msg->data.copyValues = copyValues;
  t2d_msg->data.baseIdx = baseIdx;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSgebsr2gebsc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSgebsr2gebsc_bufferSize ( cusparseHandle_t handle, int mb, int nb, int nnzb, const float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseSgebsr2gebsc_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int mb;
      int nb;
      int nnzb;
      const float * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int rowBlockDim;
      int colBlockDim;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSgebsr2gebsc_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseSgebsr2gebsc_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSgebsr2gebsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, cusparseMatDescr_t descrC, float * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDimC, int colBlockDimC, void * pBuffer )
{
  hfinf( "[trapper] cusparseSgebsr2gebsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const float * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDimA;
      int colBlockDimA;
      cusparseMatDescr_t descrC;
      float * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
      int rowBlockDimC;
      int colBlockDimC;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSgebsr2gebsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDimA = rowBlockDimA;
  t2d_msg->data.colBlockDimA = colBlockDimA;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  t2d_msg->data.rowBlockDimC = rowBlockDimC;
  t2d_msg->data.colBlockDimC = colBlockDimC;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSgebsr2gebsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSgebsr2gebsr_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseSgebsr2gebsr_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const float * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDimA;
      int colBlockDimA;
      int rowBlockDimC;
      int colBlockDimC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSgebsr2gebsr_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDimA = rowBlockDimA;
  t2d_msg->data.colBlockDimA = colBlockDimA;
  t2d_msg->data.rowBlockDimC = rowBlockDimC;
  t2d_msg->data.colBlockDimC = colBlockDimC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseSgebsr2gebsr_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSgemmi ( cusparseHandle_t handle, int m, int n, int k, int nnz, const float * alpha, const float * A, int lda, const float * cscValB, const int * cscColPtrB, const int * cscRowIndB, const float * beta, float * C, int ldc )
{
  hfinf( "[trapper] cusparseSgemmi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      const float * cscValB;
      const int * cscColPtrB;
      const int * cscRowIndB;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSgemmi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.cscValB = cscValB;
  t2d_msg->data.cscColPtrB = cscColPtrB;
  t2d_msg->data.cscRowIndB = cscRowIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSgemmi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSgemvi ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const float * alpha, const float * A, int lda, int nnz, const float * xVal, const int * xInd, const float * beta, float * y, cusparseIndexBase_t idxBase, void * pBuffer )
{
  hfinf( "[trapper] cusparseSgemvi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      const float * A;
      int lda;
      int nnz;
      const float * xVal;
      const int * xInd;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * y;
      cusparseIndexBase_t idxBase;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSgemvi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSgemvi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSgemvi_bufferSize ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, int * pBufferSize )
{
  hfinf( "[trapper] cusparseSgemvi_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSgemvi_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSize;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSize ) *pBufferSize = d2t_msg.pBufferSize;
  hfinf( "[trapper] cusparseSgemvi_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSgthr ( cusparseHandle_t handle, int nnz, const float * y, float * xVal, const int * xInd, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseSgthr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      const float * y;
      float * xVal;
      const int * xInd;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSgthr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.y = y;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSgthr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSgthrz ( cusparseHandle_t handle, int nnz, float * y, float * xVal, const int * xInd, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseSgthrz() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      float * y;
      float * xVal;
      const int * xInd;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSgthrz );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.y = y;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSgthrz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseShyb2csc ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, float * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr )
{
  hfinf( "[trapper] cusparseShyb2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      float * cscSortedVal;
      int * cscSortedRowInd;
      int * cscSortedColPtr;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseShyb2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.cscSortedVal = cscSortedVal;
  t2d_msg->data.cscSortedRowInd = cscSortedRowInd;
  t2d_msg->data.cscSortedColPtr = cscSortedColPtr;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseShyb2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseShyb2csr ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, float * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA )
{
  hfinf( "[trapper] cusparseShyb2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      float * csrSortedValA;
      int * csrSortedRowPtrA;
      int * csrSortedColIndA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseShyb2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseShyb2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseShyb2dense ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, float * A, int lda )
{
  hfinf( "[trapper] cusparseShyb2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      float * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseShyb2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseShyb2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseShybmv ( cusparseHandle_t handle, cusparseOperation_t transA, const float * alpha, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, const float * x, const float * beta, float * y )
{
  hfinf( "[trapper] cusparseShybmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      const float * x;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } beta;
      float * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseShybmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (float *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseShybmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseShybsv_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseShybsv_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseShybsv_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseShybsv_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseShybsv_solve ( cusparseHandle_t handle, cusparseOperation_t trans, const float * alpha, cusparseMatDescr_t descra, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info, const float * f, float * x )
{
  hfinf( "[trapper] cusparseShybsv_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t trans;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } alpha;
      cusparseMatDescr_t descra;
      cusparseHybMat_t hybA;
      cusparseSolveAnalysisInfo_t info;
      const float * f;
      float * x;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseShybsv_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (float *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descra = descra;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseShybsv_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSnnz ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const float * A, int lda, int * nnzPerRowCol, int * nnzTotalDevHostPtr )
{
  hfinf( "[trapper] cusparseSnnz() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const float * A;
      int lda;
      int * nnzPerRowCol;
      int * nnzTotalDevHostPtr;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSnnz );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRowCol = nnzPerRowCol;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseSnnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSnnz_compress ( cusparseHandle_t handle, int m, cusparseMatDescr_t descr, const float * csrValA, const int * csrRowPtrA, int * nnzPerRow, int * nnzC, float tol )
{
  hfinf( "[trapper] cusparseSnnz_compress() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      cusparseMatDescr_t descr;
      const float * csrValA;
      const int * csrRowPtrA;
      int * nnzPerRow;
      int * nnzC;
      float tol;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSnnz_compress );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.descr = descr;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.nnzC = nnzC;
  t2d_msg->data.tol = tol;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSnnz_compress() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneCsr2csr ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const float * csrValA, const int * csrRowPtrA, const int * csrColIndA, const float * threshold, cusparseMatDescr_t descrC, float * csrValC, const int * csrRowPtrC, int * csrColIndC, void * pBuffer )
{
  hfinf( "[trapper] cusparseSpruneCsr2csr() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const float * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      float * csrValC;
      const int * csrRowPtrC;
      int * csrColIndC;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneCsr2csr );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (float *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSpruneCsr2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneCsr2csrByPercentage ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const float * csrValA, const int * csrRowPtrA, const int * csrColIndA, float percentage, cusparseMatDescr_t descrC, float * csrValC, const int * csrRowPtrC, int * csrColIndC, pruneInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseSpruneCsr2csrByPercentage() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const float * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      float percentage;
      cusparseMatDescr_t descrC;
      float * csrValC;
      const int * csrRowPtrC;
      int * csrColIndC;
      pruneInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneCsr2csrByPercentage );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSpruneCsr2csrByPercentage() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneCsr2csrByPercentage_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const float * csrValA, const int * csrRowPtrA, const int * csrColIndA, float percentage, cusparseMatDescr_t descrC, const float * csrValC, const int * csrRowPtrC, const int * csrColIndC, pruneInfo_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseSpruneCsr2csrByPercentage_bufferSizeExt() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const float * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      float percentage;
      cusparseMatDescr_t descrC;
      const float * csrValC;
      const int * csrRowPtrC;
      const int * csrColIndC;
      pruneInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneCsr2csrByPercentage_bufferSizeExt );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseSpruneCsr2csrByPercentage_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneCsr2csrNnz ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const float * csrValA, const int * csrRowPtrA, const int * csrColIndA, const float * threshold, cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, void * pBuffer )
{
  hfinf( "[trapper] cusparseSpruneCsr2csrNnz() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const float * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      int * csrRowPtrC;
      int * nnzTotalDevHostPtr;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneCsr2csrNnz );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (float *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 1);
  }
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 1) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseSpruneCsr2csrNnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneCsr2csrNnzByPercentage ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const float * csrValA, const int * csrRowPtrA, const int * csrColIndA, float percentage, cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, pruneInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseSpruneCsr2csrNnzByPercentage() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const float * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      float percentage;
      cusparseMatDescr_t descrC;
      int * csrRowPtrC;
      int * nnzTotalDevHostPtr;
      pruneInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneCsr2csrNnzByPercentage );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseSpruneCsr2csrNnzByPercentage() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneCsr2csr_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int nnzA, cusparseMatDescr_t descrA, const float * csrValA, const int * csrRowPtrA, const int * csrColIndA, const float * threshold, cusparseMatDescr_t descrC, const float * csrValC, const int * csrRowPtrC, const int * csrColIndC, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseSpruneCsr2csr_bufferSizeExt() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int nnzA;
      cusparseMatDescr_t descrA;
      const float * csrValA;
      const int * csrRowPtrA;
      const int * csrColIndA;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      const float * csrValC;
      const int * csrRowPtrC;
      const int * csrColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneCsr2csr_bufferSizeExt );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (float *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseSpruneCsr2csr_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneDense2csr ( cusparseHandle_t handle, int m, int n, const float * A, int lda, const float * threshold, cusparseMatDescr_t descrC, float * csrValC, const int * csrRowPtrC, int * csrColIndC, void * pBuffer )
{
  hfinf( "[trapper] cusparseSpruneDense2csr() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      const float * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      float * csrValC;
      const int * csrRowPtrC;
      int * csrColIndC;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneDense2csr );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (float *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSpruneDense2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneDense2csrByPercentage ( cusparseHandle_t handle, int m, int n, const float * A, int lda, float percentage, cusparseMatDescr_t descrC, float * csrValC, const int * csrRowPtrC, int * csrColIndC, pruneInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseSpruneDense2csrByPercentage() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      const float * A;
      int lda;
      float percentage;
      cusparseMatDescr_t descrC;
      float * csrValC;
      const int * csrRowPtrC;
      int * csrColIndC;
      pruneInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneDense2csrByPercentage );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSpruneDense2csrByPercentage() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneDense2csrByPercentage_bufferSizeExt ( cusparseHandle_t handle, int m, int n, const float * A, int lda, float percentage, cusparseMatDescr_t descrC, const float * csrValC, const int * csrRowPtrC, const int * csrColIndC, pruneInfo_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseSpruneDense2csrByPercentage_bufferSizeExt() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      const float * A;
      int lda;
      float percentage;
      cusparseMatDescr_t descrC;
      const float * csrValC;
      const int * csrRowPtrC;
      const int * csrColIndC;
      pruneInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneDense2csrByPercentage_bufferSizeExt );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseSpruneDense2csrByPercentage_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneDense2csrNnz ( cusparseHandle_t handle, int m, int n, const float * A, int lda, const float * threshold, cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, void * pBuffer )
{
  hfinf( "[trapper] cusparseSpruneDense2csrNnz() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      const float * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      int * csrRowPtrC;
      int * nnzTotalDevHostPtr;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneDense2csrNnz );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (float *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 1);
  }
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 1) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseSpruneDense2csrNnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneDense2csrNnzByPercentage ( cusparseHandle_t handle, int m, int n, const float * A, int lda, float percentage, cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, pruneInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseSpruneDense2csrNnzByPercentage() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      const float * A;
      int lda;
      float percentage;
      cusparseMatDescr_t descrC;
      int * csrRowPtrC;
      int * nnzTotalDevHostPtr;
      pruneInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneDense2csrNnzByPercentage );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.percentage = percentage;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseSpruneDense2csrNnzByPercentage() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSpruneDense2csr_bufferSizeExt ( cusparseHandle_t handle, int m, int n, const float * A, int lda, const float * threshold, cusparseMatDescr_t descrC, const float * csrValC, const int * csrRowPtrC, const int * csrColIndC, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseSpruneDense2csr_bufferSizeExt() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      const float * A;
      int lda;
      union {
        struct {
          char ___dummy0[sizeof(const float *) < sizeof(float) ? sizeof(float)-sizeof(const float *) : 0];
          const float * ptr;
        };
        struct {
          char ___dummy1[sizeof(const float *) > sizeof(float) ? sizeof(const float *)-sizeof(float) : 0];
          float val;
        };
      } threshold;
      cusparseMatDescr_t descrC;
      const float * csrValC;
      const int * csrRowPtrC;
      const int * csrColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSpruneDense2csr_bufferSizeExt );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  if( threshold ) {
    hfcuda_am_node_t* _____threshold_MEMCHECK = hfcuda_am_mem_check( (float *) threshold, devId );
    bool _____threshold_PASSONHOST = ! (_____threshold_MEMCHECK && _____threshold_MEMCHECK->isdevice );
    if( _____threshold_PASSONHOST ) {
      t2d_msg->data.threshold.val = *threshold;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.threshold.ptr = threshold;
    }
  }
  else {
    t2d_msg->data.threshold.ptr = NULL;
  }
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.csrColIndC = csrColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseSpruneDense2csr_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSroti ( cusparseHandle_t handle, int nnz, float * xVal, const int * xInd, float * y, const float * c, const float * s, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseSroti() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      float * xVal;
      const int * xInd;
      float * y;
      const float * c;
      const float * s;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSroti );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.c = c;
  t2d_msg->data.s = s;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSroti() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseSsctr ( cusparseHandle_t handle, int nnz, const float * xVal, const int * xInd, float * y, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseSsctr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      const float * xVal;
      const int * xInd;
      float * y;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseSsctr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseSsctr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXbsrsm2_zeroPivot ( cusparseHandle_t handle, bsrsm2Info_t info, int * position )
{
  hfinf( "[trapper] cusparseXbsrsm2_zeroPivot() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      bsrsm2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXbsrsm2_zeroPivot );
  t2d_msg->data.handle = handle;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int position;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( position ) *position = d2t_msg.position;
  hfinf( "[trapper] cusparseXbsrsm2_zeroPivot() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXbsrsv2_zeroPivot ( cusparseHandle_t handle, bsrsv2Info_t info, int * position )
{
  hfinf( "[trapper] cusparseXbsrsv2_zeroPivot() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      bsrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXbsrsv2_zeroPivot );
  t2d_msg->data.handle = handle;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int position;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( position ) *position = d2t_msg.position;
  hfinf( "[trapper] cusparseXbsrsv2_zeroPivot() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcoo2csr ( cusparseHandle_t handle, const int * cooRowInd, int nnz, int m, int * csrSortedRowPtr, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseXcoo2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      const int * cooRowInd;
      int nnz;
      int m;
      int * csrSortedRowPtr;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcoo2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.cooRowInd = cooRowInd;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.m = m;
  t2d_msg->data.csrSortedRowPtr = csrSortedRowPtr;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseXcoo2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcoosortByColumn ( cusparseHandle_t handle, int m, int n, int nnz, int * cooRowsA, int * cooColsA, int * P, void * pBuffer )
{
  hfinf( "[trapper] cusparseXcoosortByColumn() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      int * cooRowsA;
      int * cooColsA;
      int * P;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcoosortByColumn );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.cooRowsA = cooRowsA;
  t2d_msg->data.cooColsA = cooColsA;
  t2d_msg->data.P = P;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseXcoosortByColumn() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcoosortByRow ( cusparseHandle_t handle, int m, int n, int nnz, int * cooRowsA, int * cooColsA, int * P, void * pBuffer )
{
  hfinf( "[trapper] cusparseXcoosortByRow() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      int * cooRowsA;
      int * cooColsA;
      int * P;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcoosortByRow );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.cooRowsA = cooRowsA;
  t2d_msg->data.cooColsA = cooColsA;
  t2d_msg->data.P = P;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseXcoosortByRow() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcoosort_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int nnz, const int * cooRowsA, const int * cooColsA, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseXcoosort_bufferSizeExt() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      const int * cooRowsA;
      const int * cooColsA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcoosort_bufferSizeExt );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.cooRowsA = cooRowsA;
  t2d_msg->data.cooColsA = cooColsA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseXcoosort_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcscsort ( cusparseHandle_t handle, int m, int n, int nnz, cusparseMatDescr_t descrA, const int * cscColPtrA, int * cscRowIndA, int * P, void * pBuffer )
{
  hfinf( "[trapper] cusparseXcscsort() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cusparseMatDescr_t descrA;
      const int * cscColPtrA;
      int * cscRowIndA;
      int * P;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcscsort );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.cscColPtrA = cscColPtrA;
  t2d_msg->data.cscRowIndA = cscRowIndA;
  t2d_msg->data.P = P;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseXcscsort() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcscsort_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int nnz, const int * cscColPtrA, const int * cscRowIndA, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseXcscsort_bufferSizeExt() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      const int * cscColPtrA;
      const int * cscRowIndA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcscsort_bufferSizeExt );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.cscColPtrA = cscColPtrA;
  t2d_msg->data.cscRowIndA = cscRowIndA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseXcscsort_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcsr2bsrNnz ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int blockDim, cusparseMatDescr_t descrC, int * bsrSortedRowPtrC, int * nnzTotalDevHostPtr )
{
  hfinf( "[trapper] cusparseXcsr2bsrNnz() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      int blockDim;
      cusparseMatDescr_t descrC;
      int * bsrSortedRowPtrC;
      int * nnzTotalDevHostPtr;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcsr2bsrNnz );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseXcsr2bsrNnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcsr2coo ( cusparseHandle_t handle, const int * csrSortedRowPtr, int nnz, int m, int * cooRowInd, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseXcsr2coo() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      const int * csrSortedRowPtr;
      int nnz;
      int m;
      int * cooRowInd;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcsr2coo );
  t2d_msg->data.handle = handle;
  t2d_msg->data.csrSortedRowPtr = csrSortedRowPtr;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.m = m;
  t2d_msg->data.cooRowInd = cooRowInd;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseXcsr2coo() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcsr2gebsrNnz ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrC, int * bsrSortedRowPtrC, int rowBlockDim, int colBlockDim, int * nnzTotalDevHostPtr, void * pBuffer )
{
  hfinf( "[trapper] cusparseXcsr2gebsrNnz() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrC;
      int * bsrSortedRowPtrC;
      int rowBlockDim;
      int colBlockDim;
      int * nnzTotalDevHostPtr;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcsr2gebsrNnz );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseXcsr2gebsrNnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcsrgeamNnz ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr )
{
  hfinf( "[trapper] cusparseXcsrgeamNnz() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      int nnzA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      cusparseMatDescr_t descrC;
      int * csrSortedRowPtrC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcsrgeamNnz );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr ) *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  hfinf( "[trapper] cusparseXcsrgeamNnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcsrgemm2Nnz ( cusparseHandle_t handle, int m, int n, int k, cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, cusparseMatDescr_t descrD, int nnzD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr, csrgemm2Info_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseXcsrgemm2Nnz() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      cusparseMatDescr_t descrA;
      int nnzA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      cusparseMatDescr_t descrD;
      int nnzD;
      const int * csrSortedRowPtrD;
      const int * csrSortedColIndD;
      cusparseMatDescr_t descrC;
      int * csrSortedRowPtrC;
      csrgemm2Info_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcsrgemm2Nnz );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  t2d_msg->data.descrD = descrD;
  t2d_msg->data.nnzD = nnzD;
  t2d_msg->data.csrSortedRowPtrD = csrSortedRowPtrD;
  t2d_msg->data.csrSortedColIndD = csrSortedColIndD;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr ) *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  hfinf( "[trapper] cusparseXcsrgemm2Nnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcsrgemmNnz ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, cusparseMatDescr_t descrA, const int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, const int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr )
{
  hfinf( "[trapper] cusparseXcsrgemmNnz() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int m;
      int n;
      int k;
      cusparseMatDescr_t descrA;
      int nnzA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      cusparseMatDescr_t descrC;
      int * csrSortedRowPtrC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcsrgemmNnz );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr ) *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  hfinf( "[trapper] cusparseXcsrgemmNnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcsrsort ( cusparseHandle_t handle, int m, int n, int nnz, cusparseMatDescr_t descrA, const int * csrRowPtrA, int * csrColIndA, int * P, void * pBuffer )
{
  hfinf( "[trapper] cusparseXcsrsort() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cusparseMatDescr_t descrA;
      const int * csrRowPtrA;
      int * csrColIndA;
      int * P;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcsrsort );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.P = P;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseXcsrsort() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcsrsort_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int nnz, const int * csrRowPtrA, const int * csrColIndA, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseXcsrsort_bufferSizeExt() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      const int * csrRowPtrA;
      const int * csrColIndA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcsrsort_bufferSizeExt );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.csrColIndA = csrColIndA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseXcsrsort_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXcsrsv2_zeroPivot ( cusparseHandle_t handle, csrsv2Info_t info, int * position )
{
  hfinf( "[trapper] cusparseXcsrsv2_zeroPivot() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      csrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXcsrsv2_zeroPivot );
  t2d_msg->data.handle = handle;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int position;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( position ) *position = d2t_msg.position;
  hfinf( "[trapper] cusparseXcsrsv2_zeroPivot() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseXgebsr2gebsrNnz ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, cusparseMatDescr_t descrA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, cusparseMatDescr_t descrC, int * bsrSortedRowPtrC, int rowBlockDimC, int colBlockDimC, int * nnzTotalDevHostPtr, void * pBuffer )
{
  hfinf( "[trapper] cusparseXgebsr2gebsrNnz() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDimA;
      int colBlockDimA;
      cusparseMatDescr_t descrC;
      int * bsrSortedRowPtrC;
      int rowBlockDimC;
      int colBlockDimC;
      int * nnzTotalDevHostPtr;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseXgebsr2gebsrNnz );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDimA = rowBlockDimA;
  t2d_msg->data.colBlockDimA = colBlockDimA;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.rowBlockDimC = rowBlockDimC;
  t2d_msg->data.colBlockDimC = colBlockDimC;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseXgebsr2gebsrNnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZaxpyi ( cusparseHandle_t handle, int nnz, const cuDoubleComplex * alpha, const cuDoubleComplex * xVal, const int * xInd, cuDoubleComplex * y, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseZaxpyi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * xVal;
      const int * xInd;
      cuDoubleComplex * y;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZaxpyi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZaxpyi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZbsr2csr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, cusparseMatDescr_t descrC, cuDoubleComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseZbsr2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      cusparseMatDescr_t descrC;
      cuDoubleComplex * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZbsr2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZbsr2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZbsrmm ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int kb, int nnzb, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, const int blockSize, const cuDoubleComplex * B, const int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cusparseZbsrmm() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int mb;
      int n;
      int kb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockSize;
      const cuDoubleComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZbsrmm );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.kb = kb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZbsrmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZbsrmv ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nb, int nnzb, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const cuDoubleComplex * x, const cuDoubleComplex * beta, cuDoubleComplex * y )
{
  hfinf( "[trapper] cusparseZbsrmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      const cuDoubleComplex * x;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZbsrmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZbsrmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZbsrsm2_analysis ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseZbsrsm2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZbsrsm2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZbsrsm2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZbsrsm2_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseZbsrsm2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      cusparseMatDescr_t descrA;
      cuDoubleComplex * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZbsrsm2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseZbsrsm2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZbsrsm2_solve ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, const cuDoubleComplex * F, int ldf, cuDoubleComplex * X, int ldx, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseZbsrsm2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      cusparseOperation_t transXY;
      int mb;
      int n;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int blockSize;
      bsrsm2Info_t info;
      const cuDoubleComplex * F;
      int ldf;
      cuDoubleComplex * X;
      int ldx;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZbsrsm2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transXY = transXY;
  t2d_msg->data.mb = mb;
  t2d_msg->data.n = n;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.blockSize = blockSize;
  t2d_msg->data.info = info;
  t2d_msg->data.F = F;
  t2d_msg->data.ldf = ldf;
  t2d_msg->data.X = X;
  t2d_msg->data.ldx = ldx;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZbsrsm2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZbsrsv2_analysis ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseZbsrsv2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZbsrsv2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZbsrsv2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZbsrsv2_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseZbsrsv2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      cusparseMatDescr_t descrA;
      cuDoubleComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZbsrsv2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseZbsrsv2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZbsrsv2_solve ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, const cuDoubleComplex * f, cuDoubleComplex * x, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseZbsrsv2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int mb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      bsrsv2Info_t info;
      const cuDoubleComplex * f;
      cuDoubleComplex * x;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZbsrsv2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZbsrsv2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZbsrxmv ( cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int sizeOfMask, int mb, int nb, int nnzb, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedMaskPtrA, const int * bsrSortedRowPtrA, const int * bsrSortedEndPtrA, const int * bsrSortedColIndA, int blockDim, const cuDoubleComplex * x, const cuDoubleComplex * beta, cuDoubleComplex * y )
{
  hfinf( "[trapper] cusparseZbsrxmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      cusparseOperation_t transA;
      int sizeOfMask;
      int mb;
      int nb;
      int nnzb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * bsrSortedValA;
      const int * bsrSortedMaskPtrA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedEndPtrA;
      const int * bsrSortedColIndA;
      int blockDim;
      const cuDoubleComplex * x;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZbsrxmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.transA = transA;
  t2d_msg->data.sizeOfMask = sizeOfMask;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedMaskPtrA = bsrSortedMaskPtrA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedEndPtrA = bsrSortedEndPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZbsrxmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsc2dense ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuDoubleComplex * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cuDoubleComplex * A, int lda )
{
  hfinf( "[trapper] cusparseZcsc2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * cscSortedValA;
      const int * cscSortedRowIndA;
      const int * cscSortedColPtrA;
      cuDoubleComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsc2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsc2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsc2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuDoubleComplex * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseZcsc2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * cscSortedValA;
      const int * cscSortedRowIndA;
      const int * cscSortedColPtrA;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsc2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsc2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsr2bsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int blockDim, cusparseMatDescr_t descrC, cuDoubleComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC )
{
  hfinf( "[trapper] cusparseZcsr2bsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      int blockDim;
      cusparseMatDescr_t descrC;
      cuDoubleComplex * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsr2bsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.blockDim = blockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsr2bsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsr2csc ( cusparseHandle_t handle, int m, int n, int nnz, const cuDoubleComplex * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, cuDoubleComplex * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseZcsr2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      const cuDoubleComplex * csrSortedVal;
      const int * csrSortedRowPtr;
      const int * csrSortedColInd;
      cuDoubleComplex * cscSortedVal;
      int * cscSortedRowInd;
      int * cscSortedColPtr;
      cusparseAction_t copyValues;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsr2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.csrSortedVal = csrSortedVal;
  t2d_msg->data.csrSortedRowPtr = csrSortedRowPtr;
  t2d_msg->data.csrSortedColInd = csrSortedColInd;
  t2d_msg->data.cscSortedVal = cscSortedVal;
  t2d_msg->data.cscSortedRowInd = cscSortedRowInd;
  t2d_msg->data.cscSortedColPtr = cscSortedColPtr;
  t2d_msg->data.copyValues = copyValues;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsr2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsr2csr_compress ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descra, const cuDoubleComplex * csrValA, const int * csrColIndA, const int * csrRowPtrA, int nnzA, const int * nnzPerRow, cuDoubleComplex * csrValC, int * csrColIndC, int * csrRowPtrC, cuDoubleComplex tol )
{
  hfinf( "[trapper] cusparseZcsr2csr_compress() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descra;
      const cuDoubleComplex * csrValA;
      const int * csrColIndA;
      const int * csrRowPtrA;
      int nnzA;
      const int * nnzPerRow;
      cuDoubleComplex * csrValC;
      int * csrColIndC;
      int * csrRowPtrC;
      cuDoubleComplex tol;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsr2csr_compress );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descra = descra;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrColIndA = csrColIndA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.csrValC = csrValC;
  t2d_msg->data.csrColIndC = csrColIndC;
  t2d_msg->data.csrRowPtrC = csrRowPtrC;
  t2d_msg->data.tol = tol;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsr2csr_compress() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsr2csru ( cusparseHandle_t handle, int m, int n, int nnz, cusparseMatDescr_t descrA, cuDoubleComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseZcsr2csru() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cusparseMatDescr_t descrA;
      cuDoubleComplex * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsr2csru );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsr2csru() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsr2dense ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cuDoubleComplex * A, int lda )
{
  hfinf( "[trapper] cusparseZcsr2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cuDoubleComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsr2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsr2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsr2gebsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrC, cuDoubleComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDim, int colBlockDim, void * pBuffer )
{
  hfinf( "[trapper] cusparseZcsr2gebsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrC;
      cuDoubleComplex * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
      int rowBlockDim;
      int colBlockDim;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsr2gebsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsr2gebsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsr2gebsr_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseZcsr2gebsr_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      int rowBlockDim;
      int colBlockDim;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsr2gebsr_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseZcsr2gebsr_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsr2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseZcsr2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsr2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsr2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrcolor ( cusparseHandle_t handle, int m, int nnz, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * fractionToColor, int * ncolors, int * coloring, int * reordering, cusparseColorInfo_t info )
{
  hfinf( "[trapper] cusparseZcsrcolor() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const double * fractionToColor;
      int * coloring;
      int * reordering;
      cusparseColorInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrcolor );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.fractionToColor = fractionToColor;
  t2d_msg->data.coloring = coloring;
  t2d_msg->data.reordering = reordering;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int ncolors;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( ncolors ) *ncolors = d2t_msg.ncolors;
  hfinf( "[trapper] cusparseZcsrcolor() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrgeam ( cusparseHandle_t handle, int m, int n, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, int nnzA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * beta, cusparseMatDescr_t descrB, int nnzB, const cuDoubleComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, cusparseMatDescr_t descrC, cuDoubleComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseZcsrgeam() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cusparseMatDescr_t descrB;
      int nnzB;
      const cuDoubleComplex * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      cusparseMatDescr_t descrC;
      cuDoubleComplex * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrgeam );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrgeam() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrgemm ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, cusparseMatDescr_t descrA, int nnzA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const cuDoubleComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, cusparseMatDescr_t descrC, cuDoubleComplex * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseZcsrgemm() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int m;
      int n;
      int k;
      cusparseMatDescr_t descrA;
      int nnzA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const cuDoubleComplex * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      cusparseMatDescr_t descrC;
      cuDoubleComplex * csrSortedValC;
      const int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrgemm );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrgemm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrgemm2 ( cusparseHandle_t handle, int m, int n, int k, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, int nnzA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const cuDoubleComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cuDoubleComplex * beta, cusparseMatDescr_t descrD, int nnzD, const cuDoubleComplex * csrSortedValD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, cusparseMatDescr_t descrC, cuDoubleComplex * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, csrgemm2Info_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseZcsrgemm2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const cuDoubleComplex * csrSortedValB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cusparseMatDescr_t descrD;
      int nnzD;
      const cuDoubleComplex * csrSortedValD;
      const int * csrSortedRowPtrD;
      const int * csrSortedColIndD;
      cusparseMatDescr_t descrC;
      cuDoubleComplex * csrSortedValC;
      const int * csrSortedRowPtrC;
      int * csrSortedColIndC;
      csrgemm2Info_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrgemm2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedValB = csrSortedValB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrD = descrD;
  t2d_msg->data.nnzD = nnzD;
  t2d_msg->data.csrSortedValD = csrSortedValD;
  t2d_msg->data.csrSortedRowPtrD = csrSortedRowPtrD;
  t2d_msg->data.csrSortedColIndD = csrSortedColIndD;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrgemm2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrgemm2_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int k, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cuDoubleComplex * beta, cusparseMatDescr_t descrD, int nnzD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, csrgemm2Info_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseZcsrgemm2_bufferSizeExt() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      int nnzA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseMatDescr_t descrB;
      int nnzB;
      const int * csrSortedRowPtrB;
      const int * csrSortedColIndB;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cusparseMatDescr_t descrD;
      int nnzD;
      const int * csrSortedRowPtrD;
      const int * csrSortedColIndD;
      csrgemm2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrgemm2_bufferSizeExt );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.nnzA = nnzA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.descrB = descrB;
  t2d_msg->data.nnzB = nnzB;
  t2d_msg->data.csrSortedRowPtrB = csrSortedRowPtrB;
  t2d_msg->data.csrSortedColIndB = csrSortedColIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.descrD = descrD;
  t2d_msg->data.nnzD = nnzD;
  t2d_msg->data.csrSortedRowPtrD = csrSortedRowPtrD;
  t2d_msg->data.csrSortedColIndD = csrSortedColIndD;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseZcsrgemm2_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrmm ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int k, int nnz, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cusparseZcsrmm() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const cuDoubleComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrmm );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrmm() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrmm2 ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, int nnz, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cusparseZcsrmm2() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseOperation_t transB;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const cuDoubleComplex * B;
      int ldb;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrmm2 );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.transB = transB;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.B = B;
  t2d_msg->data.ldb = ldb;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrmm2() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrmv ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * x, const cuDoubleComplex * beta, cuDoubleComplex * y )
{
  hfinf( "[trapper] cusparseZcsrmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const cuDoubleComplex * x;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrmv_mp ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * x, const cuDoubleComplex * beta, cuDoubleComplex * y )
{
  hfinf( "[trapper] cusparseZcsrmv_mp() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      const cuDoubleComplex * x;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrmv_mp );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrmv_mp() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrsm_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseZcsrsm_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrsm_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrsm_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrsm_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const cuDoubleComplex * F, int ldf, cuDoubleComplex * X, int ldx )
{
  hfinf( "[trapper] cusparseZcsrsm_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
      const cuDoubleComplex * F;
      int ldf;
      cuDoubleComplex * X;
      int ldx;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrsm_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.F = F;
  t2d_msg->data.ldf = ldf;
  t2d_msg->data.X = X;
  t2d_msg->data.ldx = ldx;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrsm_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrsv2_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseZcsrsv2_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrsv2_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrsv2_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrsv2_bufferSize ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseZcsrsv2_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrsv2_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseZcsrsv2_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrsv2_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, const cuDoubleComplex * f, cuDoubleComplex * x, cusparseSolvePolicy_t policy, void * pBuffer )
{
  hfinf( "[trapper] cusparseZcsrsv2_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      csrsv2Info_t info;
      const cuDoubleComplex * f;
      cuDoubleComplex * x;
      cusparseSolvePolicy_t policy;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrsv2_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  t2d_msg->data.policy = policy;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrsv2_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrsv_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseZcsrsv_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int nnz;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrsv_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrsv_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsrsv_solve ( cusparseHandle_t handle, cusparseOperation_t transA, int m, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const cuDoubleComplex * f, cuDoubleComplex * x )
{
  hfinf( "[trapper] cusparseZcsrsv_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * csrSortedValA;
      const int * csrSortedRowPtrA;
      const int * csrSortedColIndA;
      cusparseSolveAnalysisInfo_t info;
      const cuDoubleComplex * f;
      cuDoubleComplex * x;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsrsv_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsrsv_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsru2csr ( cusparseHandle_t handle, int m, int n, int nnz, cusparseMatDescr_t descrA, cuDoubleComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer )
{
  hfinf( "[trapper] cusparseZcsru2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cusparseMatDescr_t descrA;
      cuDoubleComplex * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsru2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZcsru2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZcsru2csr_bufferSizeExt ( cusparseHandle_t handle, int m, int n, int nnz, cuDoubleComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, size_t * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseZcsru2csr_bufferSizeExt() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      int nnz;
      cuDoubleComplex * csrVal;
      const int * csrRowPtr;
      int * csrColInd;
      csru2csrInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZcsru2csr_bufferSizeExt );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.csrVal = csrVal;
  t2d_msg->data.csrRowPtr = csrRowPtr;
  t2d_msg->data.csrColInd = csrColInd;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    size_t pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseZcsru2csr_bufferSizeExt() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZdense2csc ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuDoubleComplex * A, int lda, const int * nnzPerCol, cuDoubleComplex * cscSortedValA, int * cscSortedRowIndA, int * cscSortedColPtrA )
{
  hfinf( "[trapper] cusparseZdense2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * A;
      int lda;
      const int * nnzPerCol;
      cuDoubleComplex * cscSortedValA;
      int * cscSortedRowIndA;
      int * cscSortedColPtrA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZdense2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerCol = nnzPerCol;
  t2d_msg->data.cscSortedValA = cscSortedValA;
  t2d_msg->data.cscSortedRowIndA = cscSortedRowIndA;
  t2d_msg->data.cscSortedColPtrA = cscSortedColPtrA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZdense2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZdense2csr ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuDoubleComplex * A, int lda, const int * nnzPerRow, cuDoubleComplex * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA )
{
  hfinf( "[trapper] cusparseZdense2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * A;
      int lda;
      const int * nnzPerRow;
      cuDoubleComplex * csrSortedValA;
      int * csrSortedRowPtrA;
      int * csrSortedColIndA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZdense2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZdense2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZdense2hyb ( cusparseHandle_t handle, int m, int n, cusparseMatDescr_t descrA, const cuDoubleComplex * A, int lda, const int * nnzPerRow, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType )
{
  hfinf( "[trapper] cusparseZdense2hyb() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * A;
      int lda;
      const int * nnzPerRow;
      cusparseHybMat_t hybA;
      int userEllWidth;
      cusparseHybPartition_t partitionType;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZdense2hyb );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.userEllWidth = userEllWidth;
  t2d_msg->data.partitionType = partitionType;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZdense2hyb() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZdotci ( cusparseHandle_t handle, int nnz, const cuDoubleComplex * xVal, const int * xInd, const cuDoubleComplex * y, cuDoubleComplex * resultDevHostPtr, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseZdotci() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int nnz;
      const cuDoubleComplex * xVal;
      const int * xInd;
      const cuDoubleComplex * y;
      cuDoubleComplex * resultDevHostPtr;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZdotci );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.resultDevHostPtr = resultDevHostPtr;
  if( resultDevHostPtr ) {
    hfcuda_am_node_t* _____resultDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) resultDevHostPtr, devId );
    uint8_t _____resultDevHostPtr_PASSONHOST = ! (_____resultDevHostPtr_MEMCHECK && _____resultDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____resultDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    cuDoubleComplex resultDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( resultDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *resultDevHostPtr = d2t_msg.resultDevHostPtr;
  }
  hfinf( "[trapper] cusparseZdotci() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZdoti ( cusparseHandle_t handle, int nnz, const cuDoubleComplex * xVal, const int * xInd, const cuDoubleComplex * y, cuDoubleComplex * resultDevHostPtr, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseZdoti() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int nnz;
      const cuDoubleComplex * xVal;
      const int * xInd;
      const cuDoubleComplex * y;
      cuDoubleComplex * resultDevHostPtr;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZdoti );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.resultDevHostPtr = resultDevHostPtr;
  if( resultDevHostPtr ) {
    hfcuda_am_node_t* _____resultDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) resultDevHostPtr, devId );
    uint8_t _____resultDevHostPtr_PASSONHOST = ! (_____resultDevHostPtr_MEMCHECK && _____resultDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____resultDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    cuDoubleComplex resultDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( resultDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *resultDevHostPtr = d2t_msg.resultDevHostPtr;
  }
  hfinf( "[trapper] cusparseZdoti() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZgebsr2csr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDim, int colBlockDim, cusparseMatDescr_t descrC, cuDoubleComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC )
{
  hfinf( "[trapper] cusparseZgebsr2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDim;
      int colBlockDim;
      cusparseMatDescr_t descrC;
      cuDoubleComplex * csrSortedValC;
      int * csrSortedRowPtrC;
      int * csrSortedColIndC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZgebsr2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.csrSortedValC = csrSortedValC;
  t2d_msg->data.csrSortedRowPtrC = csrSortedRowPtrC;
  t2d_msg->data.csrSortedColIndC = csrSortedColIndC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZgebsr2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZgebsr2gebsc ( cusparseHandle_t handle, int mb, int nb, int nnzb, const cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, cuDoubleComplex * bscVal, int * bscRowInd, int * bscColPtr, cusparseAction_t copyValues, cusparseIndexBase_t baseIdx, void * pBuffer )
{
  hfinf( "[trapper] cusparseZgebsr2gebsc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int mb;
      int nb;
      int nnzb;
      const cuDoubleComplex * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int rowBlockDim;
      int colBlockDim;
      cuDoubleComplex * bscVal;
      int * bscRowInd;
      int * bscColPtr;
      cusparseAction_t copyValues;
      cusparseIndexBase_t baseIdx;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZgebsr2gebsc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  t2d_msg->data.bscVal = bscVal;
  t2d_msg->data.bscRowInd = bscRowInd;
  t2d_msg->data.bscColPtr = bscColPtr;
  t2d_msg->data.copyValues = copyValues;
  t2d_msg->data.baseIdx = baseIdx;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZgebsr2gebsc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZgebsr2gebsc_bufferSize ( cusparseHandle_t handle, int mb, int nb, int nnzb, const cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseZgebsr2gebsc_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int mb;
      int nb;
      int nnzb;
      const cuDoubleComplex * bsrSortedVal;
      const int * bsrSortedRowPtr;
      const int * bsrSortedColInd;
      int rowBlockDim;
      int colBlockDim;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZgebsr2gebsc_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.bsrSortedVal = bsrSortedVal;
  t2d_msg->data.bsrSortedRowPtr = bsrSortedRowPtr;
  t2d_msg->data.bsrSortedColInd = bsrSortedColInd;
  t2d_msg->data.rowBlockDim = rowBlockDim;
  t2d_msg->data.colBlockDim = colBlockDim;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseZgebsr2gebsc_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZgebsr2gebsr ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, cusparseMatDescr_t descrC, cuDoubleComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDimC, int colBlockDimC, void * pBuffer )
{
  hfinf( "[trapper] cusparseZgebsr2gebsr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDimA;
      int colBlockDimA;
      cusparseMatDescr_t descrC;
      cuDoubleComplex * bsrSortedValC;
      int * bsrSortedRowPtrC;
      int * bsrSortedColIndC;
      int rowBlockDimC;
      int colBlockDimC;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZgebsr2gebsr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDimA = rowBlockDimA;
  t2d_msg->data.colBlockDimA = colBlockDimA;
  t2d_msg->data.descrC = descrC;
  t2d_msg->data.bsrSortedValC = bsrSortedValC;
  t2d_msg->data.bsrSortedRowPtrC = bsrSortedRowPtrC;
  t2d_msg->data.bsrSortedColIndC = bsrSortedColIndC;
  t2d_msg->data.rowBlockDimC = rowBlockDimC;
  t2d_msg->data.colBlockDimC = colBlockDimC;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZgebsr2gebsr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZgebsr2gebsr_bufferSize ( cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, int * pBufferSizeInBytes )
{
  hfinf( "[trapper] cusparseZgebsr2gebsr_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int mb;
      int nb;
      int nnzb;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * bsrSortedValA;
      const int * bsrSortedRowPtrA;
      const int * bsrSortedColIndA;
      int rowBlockDimA;
      int colBlockDimA;
      int rowBlockDimC;
      int colBlockDimC;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZgebsr2gebsr_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.mb = mb;
  t2d_msg->data.nb = nb;
  t2d_msg->data.nnzb = nnzb;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.bsrSortedValA = bsrSortedValA;
  t2d_msg->data.bsrSortedRowPtrA = bsrSortedRowPtrA;
  t2d_msg->data.bsrSortedColIndA = bsrSortedColIndA;
  t2d_msg->data.rowBlockDimA = rowBlockDimA;
  t2d_msg->data.colBlockDimA = colBlockDimA;
  t2d_msg->data.rowBlockDimC = rowBlockDimC;
  t2d_msg->data.colBlockDimC = colBlockDimC;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSizeInBytes;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSizeInBytes ) *pBufferSizeInBytes = d2t_msg.pBufferSizeInBytes;
  hfinf( "[trapper] cusparseZgebsr2gebsr_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZgemmi ( cusparseHandle_t handle, int m, int n, int k, int nnz, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * cscValB, const int * cscColPtrB, const int * cscRowIndB, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc )
{
  hfinf( "[trapper] cusparseZgemmi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      int m;
      int n;
      int k;
      int nnz;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      const cuDoubleComplex * cscValB;
      const int * cscColPtrB;
      const int * cscRowIndB;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * C;
      int ldc;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZgemmi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.k = k;
  t2d_msg->data.nnz = nnz;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.cscValB = cscValB;
  t2d_msg->data.cscColPtrB = cscColPtrB;
  t2d_msg->data.cscRowIndB = cscRowIndB;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.C = C;
  t2d_msg->data.ldc = ldc;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZgemmi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZgemvi ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, int nnz, const cuDoubleComplex * xVal, const int * xInd, const cuDoubleComplex * beta, cuDoubleComplex * y, cusparseIndexBase_t idxBase, void * pBuffer )
{
  hfinf( "[trapper] cusparseZgemvi() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      const cuDoubleComplex * A;
      int lda;
      int nnz;
      const cuDoubleComplex * xVal;
      const int * xInd;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
      cusparseIndexBase_t idxBase;
      void * pBuffer;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZgemvi );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  t2d_msg->data.pBuffer = pBuffer;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZgemvi() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZgemvi_bufferSize ( cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, int * pBufferSize )
{
  hfinf( "[trapper] cusparseZgemvi_bufferSize() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      int m;
      int n;
      int nnz;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZgemvi_bufferSize );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.nnz = nnz;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int pBufferSize;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( pBufferSize ) *pBufferSize = d2t_msg.pBufferSize;
  hfinf( "[trapper] cusparseZgemvi_bufferSize() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZgthr ( cusparseHandle_t handle, int nnz, const cuDoubleComplex * y, cuDoubleComplex * xVal, const int * xInd, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseZgthr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      const cuDoubleComplex * y;
      cuDoubleComplex * xVal;
      const int * xInd;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZgthr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.y = y;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZgthr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZgthrz ( cusparseHandle_t handle, int nnz, cuDoubleComplex * y, cuDoubleComplex * xVal, const int * xInd, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseZgthrz() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      cuDoubleComplex * y;
      cuDoubleComplex * xVal;
      const int * xInd;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZgthrz );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.y = y;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZgthrz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZhyb2csc ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cuDoubleComplex * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr )
{
  hfinf( "[trapper] cusparseZhyb2csc() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      cuDoubleComplex * cscSortedVal;
      int * cscSortedRowInd;
      int * cscSortedColPtr;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZhyb2csc );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.cscSortedVal = cscSortedVal;
  t2d_msg->data.cscSortedRowInd = cscSortedRowInd;
  t2d_msg->data.cscSortedColPtr = cscSortedColPtr;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZhyb2csc() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZhyb2csr ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cuDoubleComplex * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA )
{
  hfinf( "[trapper] cusparseZhyb2csr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      cuDoubleComplex * csrSortedValA;
      int * csrSortedRowPtrA;
      int * csrSortedColIndA;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZhyb2csr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.csrSortedValA = csrSortedValA;
  t2d_msg->data.csrSortedRowPtrA = csrSortedRowPtrA;
  t2d_msg->data.csrSortedColIndA = csrSortedColIndA;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZhyb2csr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZhyb2dense ( cusparseHandle_t handle, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cuDoubleComplex * A, int lda )
{
  hfinf( "[trapper] cusparseZhyb2dense() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      cuDoubleComplex * A;
      int lda;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZhyb2dense );
  t2d_msg->data.handle = handle;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZhyb2dense() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZhybmv ( cusparseHandle_t handle, cusparseOperation_t transA, const cuDoubleComplex * alpha, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, const cuDoubleComplex * x, const cuDoubleComplex * beta, cuDoubleComplex * y )
{
  hfinf( "[trapper] cusparseZhybmv() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      const cuDoubleComplex * x;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } beta;
      cuDoubleComplex * y;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZhybmv );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.x = x;
  if( beta ) {
    hfcuda_am_node_t* _____beta_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) beta, devId );
    bool _____beta_PASSONHOST = ! (_____beta_MEMCHECK && _____beta_MEMCHECK->isdevice );
    if( _____beta_PASSONHOST ) {
      t2d_msg->data.beta.val = *beta;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 1);
    }
    else {
      t2d_msg->data.beta.ptr = beta;
    }
  }
  else {
    t2d_msg->data.beta.ptr = NULL;
  }
  t2d_msg->data.y = y;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZhybmv() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZhybsv_analysis ( cusparseHandle_t handle, cusparseOperation_t transA, cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info )
{
  hfinf( "[trapper] cusparseZhybsv_analysis() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      cusparseOperation_t transA;
      cusparseMatDescr_t descrA;
      cusparseHybMat_t hybA;
      cusparseSolveAnalysisInfo_t info;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZhybsv_analysis );
  t2d_msg->data.handle = handle;
  t2d_msg->data.transA = transA;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.info = info;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZhybsv_analysis() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZhybsv_solve ( cusparseHandle_t handle, cusparseOperation_t trans, const cuDoubleComplex * alpha, cusparseMatDescr_t descra, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info, const cuDoubleComplex * f, cuDoubleComplex * x )
{
  hfinf( "[trapper] cusparseZhybsv_solve() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseOperation_t trans;
      union {
        struct {
          char ___dummy0[sizeof(const cuDoubleComplex *) < sizeof(cuDoubleComplex) ? sizeof(cuDoubleComplex)-sizeof(const cuDoubleComplex *) : 0];
          const cuDoubleComplex * ptr;
        };
        struct {
          char ___dummy1[sizeof(const cuDoubleComplex *) > sizeof(cuDoubleComplex) ? sizeof(const cuDoubleComplex *)-sizeof(cuDoubleComplex) : 0];
          cuDoubleComplex val;
        };
      } alpha;
      cusparseMatDescr_t descra;
      cusparseHybMat_t hybA;
      cusparseSolveAnalysisInfo_t info;
      const cuDoubleComplex * f;
      cuDoubleComplex * x;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZhybsv_solve );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.trans = trans;
  if( alpha ) {
    hfcuda_am_node_t* _____alpha_MEMCHECK = hfcuda_am_mem_check( (cuDoubleComplex *) alpha, devId );
    bool _____alpha_PASSONHOST = ! (_____alpha_MEMCHECK && _____alpha_MEMCHECK->isdevice );
    if( _____alpha_PASSONHOST ) {
      t2d_msg->data.alpha.val = *alpha;
      t2d_msg->data.____CAT2_BITMAP |= (0x1 << 0);
    }
    else {
      t2d_msg->data.alpha.ptr = alpha;
    }
  }
  else {
    t2d_msg->data.alpha.ptr = NULL;
  }
  t2d_msg->data.descra = descra;
  t2d_msg->data.hybA = hybA;
  t2d_msg->data.info = info;
  t2d_msg->data.f = f;
  t2d_msg->data.x = x;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZhybsv_solve() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZnnz ( cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, cusparseMatDescr_t descrA, const cuDoubleComplex * A, int lda, int * nnzPerRowCol, int * nnzTotalDevHostPtr )
{
  hfinf( "[trapper] cusparseZnnz() [CALL]\n" );
  
  int devId;
  hfcheck(hfcuda_vdm_get_device(&devId));
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      uint8_t ____CAT2_BITMAP;
      cusparseHandle_t handle;
      cusparseDirection_t dirA;
      int m;
      int n;
      cusparseMatDescr_t descrA;
      const cuDoubleComplex * A;
      int lda;
      int * nnzPerRowCol;
      int * nnzTotalDevHostPtr;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZnnz );
  t2d_msg->data.____CAT2_BITMAP = 0;
  t2d_msg->data.handle = handle;
  t2d_msg->data.dirA = dirA;
  t2d_msg->data.m = m;
  t2d_msg->data.n = n;
  t2d_msg->data.descrA = descrA;
  t2d_msg->data.A = A;
  t2d_msg->data.lda = lda;
  t2d_msg->data.nnzPerRowCol = nnzPerRowCol;
  t2d_msg->data.nnzTotalDevHostPtr = nnzTotalDevHostPtr;
  if( nnzTotalDevHostPtr ) {
    hfcuda_am_node_t* _____nnzTotalDevHostPtr_MEMCHECK = hfcuda_am_mem_check( (int *) nnzTotalDevHostPtr, devId );
    uint8_t _____nnzTotalDevHostPtr_PASSONHOST = ! (_____nnzTotalDevHostPtr_MEMCHECK && _____nnzTotalDevHostPtr_MEMCHECK->isdevice );
    t2d_msg->data.____CAT2_BITMAP |= ((_____nnzTotalDevHostPtr_PASSONHOST & 0x1) << 0);
  }
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  if( nnzTotalDevHostPtr && ((t2d_msg->data.____CAT2_BITMAP >> 0) & 0x1) ) {
    *nnzTotalDevHostPtr = d2t_msg.nnzTotalDevHostPtr;
  }
  hfinf( "[trapper] cusparseZnnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZnnz_compress ( cusparseHandle_t handle, int m, cusparseMatDescr_t descr, const cuDoubleComplex * csrValA, const int * csrRowPtrA, int * nnzPerRow, int * nnzC, cuDoubleComplex tol )
{
  hfinf( "[trapper] cusparseZnnz_compress() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int m;
      cusparseMatDescr_t descr;
      const cuDoubleComplex * csrValA;
      const int * csrRowPtrA;
      int * nnzPerRow;
      int * nnzC;
      cuDoubleComplex tol;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZnnz_compress );
  t2d_msg->data.handle = handle;
  t2d_msg->data.m = m;
  t2d_msg->data.descr = descr;
  t2d_msg->data.csrValA = csrValA;
  t2d_msg->data.csrRowPtrA = csrRowPtrA;
  t2d_msg->data.nnzPerRow = nnzPerRow;
  t2d_msg->data.nnzC = nnzC;
  t2d_msg->data.tol = tol;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZnnz_compress() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



/*************************************************
* DO NOT EDIT - AUTOMATICALLY GENERATED FUNCTION *
*************************************************/
cusparseStatus_t
cusparseZsctr ( cusparseHandle_t handle, int nnz, const cuDoubleComplex * xVal, const int * xInd, cuDoubleComplex * y, cusparseIndexBase_t idxBase )
{
  hfinf( "[trapper] cusparseZsctr() [CALL]\n" );
  
  struct __attribute__((packed)) {
    hf_msgdescr_t header;
    struct __attribute__((packed)) {
      cusparseHandle_t handle;
      int nnz;
      const cuDoubleComplex * xVal;
      const int * xInd;
      cuDoubleComplex * y;
      cusparseIndexBase_t idxBase;
    } data;
  } * t2d_msg;
  typeof(*t2d_msg) ____constSize_t2d_msg;
  t2d_msg = &____constSize_t2d_msg; /* constant buffer size */
  
  HF_MSGDESCR_SET( &t2d_msg->header, HFCUDA_cusparseZsctr );
  t2d_msg->data.handle = handle;
  t2d_msg->data.nnz = nnz;
  t2d_msg->data.xVal = xVal;
  t2d_msg->data.xInd = xInd;
  t2d_msg->data.y = y;
  t2d_msg->data.idxBase = idxBase;
  
  hfcheck( hfcuda_comm_send( t2d_msg, sizeof(*t2d_msg) ));
  struct {
    cusparseStatus_t ____RETVAL;
  } d2t_msg;
  hfcheck( hfcuda_comm_recv( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[trapper] cusparseZsctr() [DONE] status=%d\n", d2t_msg.____RETVAL );
  return d2t_msg.____RETVAL;
}



